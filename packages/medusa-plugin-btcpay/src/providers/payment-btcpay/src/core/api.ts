/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * BTCPay Greenfield API
 * # Introduction  The BTCPay Server Greenfield API is a REST API. Our API has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  # Authentication  You can authenticate either via Basic Auth or an API key. It's recommended to use an API key for better security. You can create an API key in the BTCPay Server UI under `Account` -> `Manage Account` -> `API keys`. You can restrict the API key for one or multiple stores and for specific permissions. For testing purposes, you can give it the 'Unrestricted access' permission. On production you should limit the permissions to the actual endpoints you use, you can see the required permission on the API docs at the top of each endpoint under `AUTHORIZATIONS`.  If you want to simplify the process of creating API keys for your users, you can use the [Authorization endpoint](https://docs.btcpayserver.org/API/Greenfield/v1/#tag/Authorization) to predefine permissions and redirect your users to the BTCPay Server Authorization UI. You can find more information about this on the [API Authorization Flow docs](https://docs.btcpayserver.org/BTCPayServer/greenfield-authorization/) page.  # Usage examples  Use **Basic Auth** to read store information with cURL: ```bash BTCPAY_INSTANCE=\"https://mainnet.demo.btcpayserver.org\" USER=\"MyTestUser@gmail.com\" PASSWORD=\"notverysecurepassword\" PERMISSION=\"btcpay.store.canmodifystoresettings\" BODY=\"$(echo \"{}\" | jq --arg \"a\" \"$PERMISSION\" '. + {permissions:[$a]}')\"  API_KEY=\"$(curl -s \\      -H \"Content-Type: application/json\" \\      --user \"$USER:$PASSWORD\" \\      -X POST \\      -d \"$BODY\" \\      \"$BTCPAY_INSTANCE/api/v1/api-keys\" | jq -r .apiKey)\" ```   Use an **API key** to read store information with cURL: ```bash STORE_ID=\"yourStoreId\"  curl -s \\      -H \"Content-Type: application/json\" \\      -H \"Authorization: token $API_KEY\" \\      -X GET \\      \"$BTCPAY_INSTANCE/api/v1/stores/$STORE_ID\" ```  You can find more examples on our docs for different programming languages: - [cURL](https://docs.btcpayserver.org/Development/GreenFieldExample/) - [Javascript/Node.Js](https://docs.btcpayserver.org/Development/GreenFieldExample-NodeJS/) - [PHP](https://docs.btcpayserver.org/Development/GreenFieldExample-PHP/)  
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AddOnChainWalletObjectLinkRequest
 */
export interface AddOnChainWalletObjectLinkRequest extends OnChainWalletObjectId {
    /**
     * The data of the link
     * @type {{ [key: string]: any; }}
     * @memberof AddOnChainWalletObjectLinkRequest
     */
    data?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ApiKeyData
 */
export interface ApiKeyData {
    /**
     * The API Key to use for API Key Authentication
     * @type {string}
     * @memberof ApiKeyData
     */
    apiKey?: string;
    /**
     * The label given by the user to this API Key
     * @type {string}
     * @memberof ApiKeyData
     */
    label?: string;
    /**
     * The permissions associated to this API Key (can be scoped to a specific store)
     * @type {Array<string>}
     * @memberof ApiKeyData
     */
    permissions?: Array<string>;
}
/**
 * 
 * @export
 * @interface AppBaseData
 */
export interface AppBaseData {
    /**
     * Id of the app
     * @type {string}
     * @memberof AppBaseData
     */
    id?: string;
    /**
     * Name given to the app when it was created
     * @type {string}
     * @memberof AppBaseData
     */
    appName?: string;
    /**
     * Id of the store to which the app belongs
     * @type {StoreId}
     * @memberof AppBaseData
     */
    storeId?: StoreId;
    /**
     * UNIX timestamp for when the app was created
     * @type {number}
     * @memberof AppBaseData
     */
    created?: number;
    /**
     * Type of the app which was created
     * @type {string}
     * @memberof AppBaseData
     */
    appType?: string;
    /**
     * If true, the app does not appear in the apps list by default.
     * @type {boolean}
     * @memberof AppBaseData
     */
    archived?: boolean;
}
/**
 * 
 * @export
 * @interface AppIdImageBody
 */
export interface AppIdImageBody {
    /**
     * The image
     * @type {Blob}
     * @memberof AppIdImageBody
     */
    file?: Blob;
}
/**
 * 
 * @export
 * @interface AppItem
 */
export interface AppItem {
    /**
     * Unique ID of the item
     * @type {string}
     * @memberof AppItem
     */
    id?: string;
    /**
     * The display name of the item
     * @type {string}
     * @memberof AppItem
     */
    title?: string;
    /**
     * A description text for the item
     * @type {string}
     * @memberof AppItem
     */
    description?: string;
    /**
     * An image URL for the item
     * @type {string}
     * @memberof AppItem
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof AppItem
     */
    price?: string;
    /**
     * 
     * @type {string}
     * @memberof AppItem
     */
    priceType?: AppItem.PriceTypeEnum;
    /**
     * A custom text for the buy button for the item
     * @type {string}
     * @memberof AppItem
     */
    buyButtonText?: string;
    /**
     * The remaining stock the item
     * @type {number}
     * @memberof AppItem
     */
    inventory?: number;
    /**
     * If true, the item does not appear in the list by default.
     * @type {boolean}
     * @memberof AppItem
     */
    disabled?: boolean;
}

/**
 * @export
 * @namespace AppItem
 */
export namespace AppItem {
    /**
     * @export
     * @enum {string}
     */
    export enum PriceTypeEnum {
        Fixed = <any>'Fixed',
        Minimum = <any>'Minimum',
        Topup = <any>'Topup'
    }
}
/**
 * 
 * @export
 * @interface AppItemStats
 */
export interface AppItemStats {
    /**
     * Item ID
     * @type {string}
     * @memberof AppItemStats
     */
    itemCode?: string;
    /**
     * Item Name
     * @type {string}
     * @memberof AppItemStats
     */
    title?: string;
    /**
     * Total sales of that item
     * @type {number}
     * @memberof AppItemStats
     */
    salesCount?: number;
    /**
     * The total amount of sales of that item
     * @type {string}
     * @memberof AppItemStats
     */
    total?: string;
    /**
     * The formatted total amount of sales of that item
     * @type {string}
     * @memberof AppItemStats
     */
    totalFormatted?: string;
}
/**
 * 
 * @export
 * @interface AppSalesStats
 */
export interface AppSalesStats {
    /**
     * Total sales in that period
     * @type {number}
     * @memberof AppSalesStats
     */
    salesCount?: number;
    /**
     * 
     * @type {Array<AppSalesStatsItem>}
     * @memberof AppSalesStats
     */
    series?: Array<AppSalesStatsItem>;
}
/**
 * 
 * @export
 * @interface AppSalesStatsItem
 */
export interface AppSalesStatsItem {
    /**
     * UNIX timestamp of the beginning of that day
     * @type {number}
     * @memberof AppSalesStatsItem
     */
    date?: number;
    /**
     * Short date as label
     * @type {string}
     * @memberof AppSalesStatsItem
     */
    label?: string;
    /**
     * Total sales on that day
     * @type {number}
     * @memberof AppSalesStatsItem
     */
    salesCount?: number;
}
/**
 * 
 * @export
 * @interface ApplicationHealthData
 */
export interface ApplicationHealthData {
    /**
     * True if the instance is fully synchronized, according to NBXplorer
     * @type {boolean}
     * @memberof ApplicationHealthData
     */
    _synchronized?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationServerInfoData
 */
export interface ApplicationServerInfoData {
    /**
     * BTCPay Server version
     * @type {string}
     * @memberof ApplicationServerInfoData
     */
    version?: string;
    /**
     * The Tor hostname
     * @type {string}
     * @memberof ApplicationServerInfoData
     */
    onion?: string;
    /**
     * The payment methods this server supports
     * @type {Array<string>}
     * @memberof ApplicationServerInfoData
     */
    supportedPaymentMethods?: Array<string>;
    /**
     * True if the instance is fully synchronized, according to NBXplorer
     * @type {boolean}
     * @memberof ApplicationServerInfoData
     */
    fullySynched?: boolean;
    /**
     * 
     * @type {Array<ApplicationServerInfoSyncStatusData>}
     * @memberof ApplicationServerInfoData
     */
    syncStatus?: Array<ApplicationServerInfoSyncStatusData>;
}
/**
 * Detailed sync status of the internal full node
 * @export
 * @interface ApplicationServerInfoNodeStatusData
 */
export interface ApplicationServerInfoNodeStatusData {
    /**
     * The height of the chain of header of the internal full node
     * @type {number}
     * @memberof ApplicationServerInfoNodeStatusData
     */
    headers?: number;
    /**
     * The height of the latest validated block of the internal full node
     * @type {number}
     * @memberof ApplicationServerInfoNodeStatusData
     */
    blocks?: number;
    /**
     * The current synchronization progress
     * @type {number}
     * @memberof ApplicationServerInfoNodeStatusData
     */
    verificationProgress?: number;
}
/**
 * Detailed sync status
 * @export
 * @interface ApplicationServerInfoSyncStatusData
 */
export interface ApplicationServerInfoSyncStatusData {
    /**
     * 
     * @type {PaymentMethodId}
     * @memberof ApplicationServerInfoSyncStatusData
     */
    paymentMethodId?: PaymentMethodId;
    /**
     * 
     * @type {ApplicationServerInfoNodeStatusData}
     * @memberof ApplicationServerInfoSyncStatusData
     */
    nodeInformation?: ApplicationServerInfoNodeStatusData;
    /**
     * The height of the chain of header of the internal indexer
     * @type {number}
     * @memberof ApplicationServerInfoSyncStatusData
     */
    chainHeight?: number;
    /**
     * The height of the latest indexed block of the internal indexer
     * @type {number}
     * @memberof ApplicationServerInfoSyncStatusData
     */
    syncHeight?: number;
    /**
     * True if the full node and the indexer are fully synchronized
     * @type {boolean}
     * @memberof ApplicationServerInfoSyncStatusData
     */
    available?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationUserData
 */
export interface ApplicationUserData {
    /**
     * The id of the user
     * @type {string}
     * @memberof ApplicationUserData
     */
    id?: string;
    /**
     * The email of the user
     * @type {string}
     * @memberof ApplicationUserData
     */
    email?: string;
    /**
     * The name of the user
     * @type {string}
     * @memberof ApplicationUserData
     */
    name?: string;
    /**
     * The profile picture URL of the user
     * @type {string}
     * @memberof ApplicationUserData
     */
    imageUrl?: string;
    /**
     * The pending invitation URL of the user
     * @type {string}
     * @memberof ApplicationUserData
     */
    invitationUrl?: string;
    /**
     * True if the email has been confirmed by the user
     * @type {boolean}
     * @memberof ApplicationUserData
     */
    emailConfirmed?: boolean;
    /**
     * True if the email requires confirmation to log in
     * @type {boolean}
     * @memberof ApplicationUserData
     */
    requiresEmailConfirmation?: boolean;
    /**
     * True if an admin has approved the user
     * @type {boolean}
     * @memberof ApplicationUserData
     */
    approved?: boolean;
    /**
     * True if the instance requires approval to log in
     * @type {boolean}
     * @memberof ApplicationUserData
     */
    requiresApproval?: boolean;
    /**
     * The creation date of the user as a unix timestamp. Null if created before v1.0.5.6
     * @type {UnixTimestamp}
     * @memberof ApplicationUserData
     */
    created?: UnixTimestamp;
    /**
     * True if an admin has disabled the user
     * @type {boolean}
     * @memberof ApplicationUserData
     */
    disabled?: boolean;
    /**
     * The roles of the user
     * @type {Array<string>}
     * @memberof ApplicationUserData
     */
    roles?: Array<string>;
}
/**
 * 
 * @export
 * @interface ApproveUserRequest
 */
export interface ApproveUserRequest {
    /**
     * Whether to approve or unapprove the user
     * @type {boolean}
     * @memberof ApproveUserRequest
     */
    approved?: boolean;
}
/**
 * 
 * @export
 * @interface CheckoutOptions
 */
export interface CheckoutOptions {
    /**
     * 
     * @type {SpeedPolicy}
     * @memberof CheckoutOptions
     */
    speedPolicy?: SpeedPolicy;
    /**
     * A specific set of payment methods to use for this invoice (ie. BTC, BTC-LightningNetwork). By default, select all payment methods enabled in the store.
     * @type {Array<string>}
     * @memberof CheckoutOptions
     */
    paymentMethods?: Array<string>;
    /**
     * Default payment type for the invoice (e.g., BTC, BTC-LightningNetwork). Default payment method set for the store is used if this parameter is not specified.
     * @type {PaymentMethodId}
     * @memberof CheckoutOptions
     */
    defaultPaymentMethod?: PaymentMethodId;
    /**
     * If true, payment methods are enabled individually upon user interaction in the invoice. Default to store's settings'
     * @type {boolean}
     * @memberof CheckoutOptions
     */
    lazyPaymentMethods?: boolean;
    /**
     * The number of minutes after which an invoice becomes expired. Defaults to the store's settings. (The default store settings is 15)
     * @type {TimeSpanMinutes}
     * @memberof CheckoutOptions
     */
    expirationMinutes?: TimeSpanMinutes;
    /**
     * The number of minutes after an invoice expired after which we are still monitoring for incoming payments. Defaults to the store's settings. (The default store settings is 1440, 1 day)
     * @type {TimeSpanMinutes}
     * @memberof CheckoutOptions
     */
    monitoringMinutes?: TimeSpanMinutes;
    /**
     * A percentage determining whether to count the invoice as paid when the invoice is paid within the specified margin of error. Defaults to the store's settings. (The default store settings is 0)
     * @type {number}
     * @memberof CheckoutOptions
     */
    paymentTolerance?: number;
    /**
     * When the customer has paid the invoice, the URL where the customer will be redirected when clicking on the `return to store` button. You can use placeholders `{InvoiceId}` or `{OrderId}` in the URL, BTCPay Server will replace those with this invoice `id` or `metadata.orderId` respectively.
     * @type {string}
     * @memberof CheckoutOptions
     */
    redirectURL?: string;
    /**
     * When the customer has paid the invoice, and a `redirectURL` is set, the checkout is redirected to `redirectURL` automatically if `redirectAutomatically` is true. Defaults to the store's settings. (The default store settings is false)
     * @type {boolean}
     * @memberof CheckoutOptions
     */
    redirectAutomatically?: boolean;
    /**
     * The language code (eg. en-US, en, fr-FR...) of the language presented to your customer in the checkout page. BTCPay Server tries to match the best language available. If null or not set, will fallback on the store's default language. You can see the list of language codes with [this operation](#operation/langCodes).
     * @type {string}
     * @memberof CheckoutOptions
     */
    defaultLanguage?: string;
}
/**
 * 
 * @export
 * @interface ConnectToNodeRequest
 */
export interface ConnectToNodeRequest {
    /**
     * Node URI in the form `pubkey@endpoint[:port]`
     * @type {string}
     * @memberof ConnectToNodeRequest
     */
    nodeURI?: string;
}
/**
 * 
 * @export
 * @interface CreateInvoiceRequest
 */
export interface CreateInvoiceRequest extends InvoiceDataBase {
    /**
     * The amount of the invoice. If null or unspecified, the invoice will be a top-up invoice. (ie. The invoice will consider any payment as a full payment)
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    amount?: string;
    /**
     * The currency of the invoice (if null, empty or unspecified, the currency will be the store's settings default)'
     * @type {string}
     * @memberof CreateInvoiceRequest
     */
    currency?: string;
    /**
     * Additional search term to help you find this invoice via text search
     * @type {Array<string>}
     * @memberof CreateInvoiceRequest
     */
    additionalSearchTerms?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateLightningInvoiceRequest
 */
export interface CreateLightningInvoiceRequest {
    /**
     * Amount wrapped in a string, represented in a millistatoshi string. (1000 millisatoshi = 1 satoshi)
     * @type {string}
     * @memberof CreateLightningInvoiceRequest
     */
    amount?: string;
    /**
     * Description of the invoice in the BOLT11
     * @type {string}
     * @memberof CreateLightningInvoiceRequest
     */
    description?: string;
    /**
     * If `descriptionHashOnly` is `true` (default is `false`), then the BOLT11 returned contains a hash of the `description`, rather than the `description`, itself. This allows for much longer descriptions, but they must be communicated via some other mechanism.
     * @type {boolean}
     * @memberof CreateLightningInvoiceRequest
     */
    descriptionHashOnly?: boolean;
    /**
     * Expiration time in seconds
     * @type {TimeSpanSeconds}
     * @memberof CreateLightningInvoiceRequest
     */
    expiry?: TimeSpanSeconds;
    /**
     * True if the invoice should include private route hints
     * @type {boolean}
     * @memberof CreateLightningInvoiceRequest
     */
    privateRouteHints?: boolean;
}
/**
 * 
 * @export
 * @interface CreateOnChainTransactionRequest
 */
export interface CreateOnChainTransactionRequest {
    /**
     * What and where to send money
     * @type {Array<CreateOnChainTransactionRequestDestination>}
     * @memberof CreateOnChainTransactionRequest
     */
    destinations?: Array<CreateOnChainTransactionRequestDestination>;
    /**
     * Transaction fee.
     * @type {number}
     * @memberof CreateOnChainTransactionRequest
     */
    feerate?: number;
    /**
     * Whether to attempt to do a BIP78 payjoin if one of the destinations is a BIP21 with payjoin enabled
     * @type {boolean}
     * @memberof CreateOnChainTransactionRequest
     */
    proceedWithPayjoin?: boolean;
    /**
     * Whether to broadcast the transaction after creating it or to simply return the transaction in hex format.
     * @type {boolean}
     * @memberof CreateOnChainTransactionRequest
     */
    proceedWithBroadcast?: boolean;
    /**
     * Whether to send all the spent coins to the destinations (THIS CAN COST YOU SIGNIFICANT AMOUNTS OF MONEY, LEAVE FALSE UNLESS YOU KNOW WHAT YOU ARE DOING).
     * @type {boolean}
     * @memberof CreateOnChainTransactionRequest
     */
    noChange?: boolean;
    /**
     * Whether to enable RBF for the transaction. Leave blank to have it random (beneficial to privacy)
     * @type {boolean}
     * @memberof CreateOnChainTransactionRequest
     */
    rbf?: boolean;
    /**
     * Whether to exclude unconfirmed UTXOs from the transaction.
     * @type {boolean}
     * @memberof CreateOnChainTransactionRequest
     */
    excludeUnconfirmed?: boolean;
    /**
     * Restrict the creation of the transactions from the outpoints provided ONLY (coin selection)
     * @type {Array<string>}
     * @memberof CreateOnChainTransactionRequest
     */
    selectedInputs?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateOnChainTransactionRequestDestination
 */
export interface CreateOnChainTransactionRequestDestination {
    /**
     * A wallet address or a BIP21 payment link
     * @type {string}
     * @memberof CreateOnChainTransactionRequestDestination
     */
    destination?: string;
    /**
     * The amount to send. If `destination` is a BIP21 link, the amount must be the same or null.
     * @type {string}
     * @memberof CreateOnChainTransactionRequestDestination
     */
    amount?: string;
    /**
     * Whether to subtract the transaction fee from the provided amount. This makes the receiver receive less, or in other words: he or she pays the transaction fee. Also useful if you want to clear out your wallet. Must be false if `destination` is a BIP21 link
     * @type {boolean}
     * @memberof CreateOnChainTransactionRequestDestination
     */
    subtractFromAmount?: boolean;
}
/**
 * 
 * @export
 * @interface CreatePayoutRequest
 */
export interface CreatePayoutRequest {
    /**
     * The destination of the payout (can be an address or a BIP21 url)
     * @type {string}
     * @memberof CreatePayoutRequest
     */
    destination?: string;
    /**
     * The amount of the payout in the currency of the pull payment (eg. USD).
     * @type {string}
     * @memberof CreatePayoutRequest
     */
    amount?: string;
    /**
     * 
     * @type {PayoutMethodId}
     * @memberof CreatePayoutRequest
     */
    payoutMethodId?: PayoutMethodId;
}
/**
 * 
 * @export
 * @interface CreatePayoutThroughStoreRequest
 */
export interface CreatePayoutThroughStoreRequest extends CreatePayoutRequest {
    /**
     * The pull payment to create this for. Optional.
     * @type {string}
     * @memberof CreatePayoutThroughStoreRequest
     */
    pullPaymentId?: string;
    /**
     * Whether to approve this payout automatically upon creation
     * @type {boolean}
     * @memberof CreatePayoutThroughStoreRequest
     */
    approved?: boolean;
    /**
     * Additional metadata to store with the payout
     * @type {any}
     * @memberof CreatePayoutThroughStoreRequest
     */
    metadata?: any;
}
/**
 * 
 * @export
 * @interface CrowdfundAppData
 */
export interface CrowdfundAppData extends CrowdfundBaseData {
    /**
     * JSON of perks available in the app
     * @type {any}
     * @memberof CrowdfundAppData
     */
    perks?: any;
}
/**
 * 
 * @export
 * @interface CrowdfundAppRequest
 */
export interface CrowdfundAppRequest extends CrowdfundBaseData {
    /**
     * JSON of perks available in the app
     * @type {string}
     * @memberof CrowdfundAppRequest
     */
    perksTemplate?: string;
}
/**
 * 
 * @export
 * @interface CrowdfundBaseData
 */
export interface CrowdfundBaseData extends AppBaseData {
    /**
     * Display title of the app
     * @type {string}
     * @memberof CrowdfundBaseData
     */
    title?: string;
    /**
     * App description
     * @type {string}
     * @memberof CrowdfundBaseData
     */
    description?: string;
    /**
     * Whether the app is enabled to be viewed by everyone
     * @type {boolean}
     * @memberof CrowdfundBaseData
     */
    enabled?: boolean;
    /**
     * Whether contributions over the set target amount are allowed
     * @type {boolean}
     * @memberof CrowdfundBaseData
     */
    enforceTargetAmount?: boolean;
    /**
     * UNIX timestamp for crowdfund start time (https://www.unixtimestamp.com/)
     * @type {UnixTimestamp}
     * @memberof CrowdfundBaseData
     */
    startDate?: UnixTimestamp;
    /**
     * UNIX timestamp for crowdfund end time (https://www.unixtimestamp.com/)
     * @type {UnixTimestamp}
     * @memberof CrowdfundBaseData
     */
    endDate?: UnixTimestamp;
    /**
     * Target currency for the crowdfund
     * @type {string}
     * @memberof CrowdfundBaseData
     */
    targetCurrency?: string;
    /**
     * Target amount for the crowdfund
     * @type {number}
     * @memberof CrowdfundBaseData
     */
    targetAmount?: number;
    /**
     * URL for image used as a cover image for the app
     * @type {string}
     * @memberof CrowdfundBaseData
     */
    mainImageUrl?: string;
    /**
     * Callback notification url to POST to once when invoice is paid for and once when there are enough blockchain confirmations
     * @type {string}
     * @memberof CrowdfundBaseData
     */
    notificationUrl?: string;
    /**
     * Tagline for the app displayed to user
     * @type {string}
     * @memberof CrowdfundBaseData
     */
    tagline?: string;
    /**
     * Whether Disqus is enabled for the app
     * @type {boolean}
     * @memberof CrowdfundBaseData
     */
    disqusEnabled?: boolean;
    /**
     * Disqus shortname to used for the app
     * @type {string}
     * @memberof CrowdfundBaseData
     */
    disqusShortname?: string;
    /**
     * Whether sounds on new contributions are enabled
     * @type {boolean}
     * @memberof CrowdfundBaseData
     */
    soundsEnabled?: boolean;
    /**
     * Whether background animations on new contributions are enabled
     * @type {boolean}
     * @memberof CrowdfundBaseData
     */
    animationsEnabled?: boolean;
    /**
     * Contribution goal reset frequency amount
     * @type {number}
     * @memberof CrowdfundBaseData
     */
    resetEveryAmount?: number;
    /**
     * Contribution goal reset frequency
     * @type {string}
     * @memberof CrowdfundBaseData
     */
    resetEvery?: string;
    /**
     * Whether perk values are displayed
     * @type {boolean}
     * @memberof CrowdfundBaseData
     */
    displayPerksValue?: boolean;
    /**
     * Whether perks are sorted by popularity
     * @type {boolean}
     * @memberof CrowdfundBaseData
     */
    sortPerksByPopularity?: boolean;
    /**
     * Array of custom sounds which can be used on new contributions
     * @type {Array<string>}
     * @memberof CrowdfundBaseData
     */
    sounds?: Array<string>;
    /**
     * Array of custom HEX colors which can be used for background animations on new contributions
     * @type {Array<string>}
     * @memberof CrowdfundBaseData
     */
    animationColors?: Array<string>;
    /**
     * Used for SEO, the [HTML Lang](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang) of the page
     * @type {string}
     * @memberof CrowdfundBaseData
     */
    htmlLang?: string;
    /**
     * Used for SEO, the [Meta tags](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta) of the page
     * @type {string}
     * @memberof CrowdfundBaseData
     */
    htmlMetaTags?: string;
    /**
     * Form ID to request customer data
     * @type {string}
     * @memberof CrowdfundBaseData
     */
    formId?: string;
}
/**
 * 
 * @export
 * @interface EmailSendBody
 */
export interface EmailSendBody {
    /**
     * Email of the recipient
     * @type {string}
     * @memberof EmailSendBody
     */
    email?: string;
    /**
     * Subject of the email
     * @type {string}
     * @memberof EmailSendBody
     */
    subject?: string;
    /**
     * Body of the email to send as plain text.
     * @type {string}
     * @memberof EmailSendBody
     */
    body?: string;
}
/**
 * 
 * @export
 * @interface EmailSettingsBase
 */
export interface EmailSettingsBase {
    /**
     * The sender email address
     * @type {string}
     * @memberof EmailSettingsBase
     */
    from?: string;
    /**
     * SMTP server host
     * @type {string}
     * @memberof EmailSettingsBase
     */
    server?: string;
    /**
     * SMTP server port
     * @type {number}
     * @memberof EmailSettingsBase
     */
    port?: number;
    /**
     * SMTP username
     * @type {string}
     * @memberof EmailSettingsBase
     */
    login?: string;
    /**
     * Disable TLS certificate security checks
     * @type {boolean}
     * @memberof EmailSettingsBase
     */
    disableCertificateCheck?: boolean;
}
/**
 * 
 * @export
 * @interface FileData
 */
export interface FileData {
    /**
     * The id of the file
     * @type {string}
     * @memberof FileData
     */
    id?: string;
    /**
     * The id of the user that uploaded the file
     * @type {string}
     * @memberof FileData
     */
    userId?: string;
    /**
     * The internal URI of the file
     * @type {string}
     * @memberof FileData
     */
    uri?: string;
    /**
     * The full URL of the file
     * @type {string}
     * @memberof FileData
     */
    url?: string;
    /**
     * The original name of the file
     * @type {string}
     * @memberof FileData
     */
    originalName?: string;
    /**
     * The storage name of the file
     * @type {string}
     * @memberof FileData
     */
    storageName?: string;
    /**
     * The creation date of the file as a unix timestamp
     * @type {UnixTimestamp}
     * @memberof FileData
     */
    created?: UnixTimestamp;
}
/**
 * 
 * @export
 * @interface GenerateOnChainWalletRequest
 */
export interface GenerateOnChainWalletRequest {
    /**
     * A label that will be shown in the UI
     * @type {string}
     * @memberof GenerateOnChainWalletRequest
     */
    label?: string;
    /**
     * 
     * @type {Mnemonic}
     * @memberof GenerateOnChainWalletRequest
     */
    existingMnemonic?: Mnemonic;
    /**
     * A passphrase for the BIP39 mnemonic seed
     * @type {string}
     * @memberof GenerateOnChainWalletRequest
     */
    passphrase?: string;
    /**
     * The account to derive from the BIP39 mnemonic seed
     * @type {number}
     * @memberof GenerateOnChainWalletRequest
     */
    accountNumber?: number;
    /**
     * Whether to store the seed inside BTCPay Server to enable some additional services. IF `false` AND `existingMnemonic` IS NOT SPECIFIED, BE SURE TO SECURELY STORE THE SEED IN THE RESPONSE!
     * @type {boolean}
     * @memberof GenerateOnChainWalletRequest
     */
    savePrivateKeys?: boolean;
    /**
     * Whether to import all addresses generated via BTCPay Server into the underlying node wallet. (Private keys will also be imported if `savePrivateKeys` is set to true.
     * @type {boolean}
     * @memberof GenerateOnChainWalletRequest
     */
    importKeysToRPC?: boolean;
    /**
     * If `existingMnemonic` is not set, a mnemonic is generated using the specified wordList.
     * @type {string}
     * @memberof GenerateOnChainWalletRequest
     */
    wordList?: GenerateOnChainWalletRequest.WordListEnum;
    /**
     * If `existingMnemonic` is not set, a mnemonic is generated using the specified wordCount.
     * @type {number}
     * @memberof GenerateOnChainWalletRequest
     */
    wordCount?: GenerateOnChainWalletRequest.WordCountEnum;
    /**
     * the type of wallet to generate
     * @type {string}
     * @memberof GenerateOnChainWalletRequest
     */
    scriptPubKeyType?: GenerateOnChainWalletRequest.ScriptPubKeyTypeEnum;
}

/**
 * @export
 * @namespace GenerateOnChainWalletRequest
 */
export namespace GenerateOnChainWalletRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum WordListEnum {
        ChineseSimplified = <any>'ChineseSimplified',
        ChineseTraditional = <any>'ChineseTraditional',
        Czech = <any>'Czech',
        English = <any>'English',
        French = <any>'French',
        Japanese = <any>'Japanese',
        PortugueseBrazil = <any>'PortugueseBrazil',
        Spanish = <any>'Spanish'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum WordCountEnum {
        NUMBER_12 = <any>12,
        NUMBER_15 = <any>15,
        NUMBER_18 = <any>18,
        NUMBER_21 = <any>21,
        NUMBER_24 = <any>24
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ScriptPubKeyTypeEnum {
        Legacy = <any>'Legacy',
        Segwit = <any>'Segwit',
        SegwitP2SH = <any>'SegwitP2SH',
        TaprootBIP86 = <any>'TaprootBIP86'
    }
}
/**
 * 
 * @export
 * @interface GenericPaymentMethodData
 */
export interface GenericPaymentMethodData {
    /**
     * Whether the payment method is enabled
     * @type {boolean}
     * @memberof GenericPaymentMethodData
     */
    enabled?: boolean;
    /**
     * 
     * @type {PaymentMethodId}
     * @memberof GenericPaymentMethodData
     */
    paymentMethodId?: PaymentMethodId;
    /**
     * Associated dynamic data based on payment method type.
     * @type {LNURLPayPaymentMethodBaseData | LightningNetworkPaymentMethodBaseData | OnChainPaymentMethodBaseData | Map}
     * @memberof GenericPaymentMethodData
     */
    config?: LNURLPayPaymentMethodBaseData | LightningNetworkPaymentMethodBaseData | OnChainPaymentMethodBaseData | Map<string, unknown>;
}
/**
 * 
 * @export
 * @interface GetEmailSettings
 */
export interface GetEmailSettings extends EmailSettingsBase {
    /**
     * `true` if the password has been set.
     * @type {boolean}
     * @memberof GetEmailSettings
     */
    passwordSet?: boolean;
}
/**
 * 
 * @export
 * @interface GetServerEmailSettings
 */
export interface GetServerEmailSettings extends GetEmailSettings {
    /**
     * Indicates if stores can use server email settings
     * @type {boolean}
     * @memberof GetServerEmailSettings
     */
    enableStoresToUseServerEmailSettings?: boolean;
}
/**
 * Histogram data for wallet balances over time
 * @export
 * @interface HistogramData
 */
export interface HistogramData {
    /**
     * The timespan of the histogram data
     * @type {string}
     * @memberof HistogramData
     */
    type?: HistogramData.TypeEnum;
    /**
     * The current wallet balance
     * @type {string}
     * @memberof HistogramData
     */
    balance?: string;
    /**
     * An array of historic balances of the wallet
     * @type {Array<string>}
     * @memberof HistogramData
     */
    series?: Array<string>;
    /**
     * An array of timestamps associated with the series data
     * @type {Array<number>}
     * @memberof HistogramData
     */
    labels?: Array<number>;
}

/**
 * @export
 * @namespace HistogramData
 */
export namespace HistogramData {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Month = <any>'Month',
        Week = <any>'Week',
        Year = <any>'Year'
    }
}
/**
 * 
 * @export
 * @interface IdOrEmailApikeysBody
 */
export interface IdOrEmailApikeysBody {
    /**
     * The label of the new API Key
     * @type {string}
     * @memberof IdOrEmailApikeysBody
     */
    label?: string;
    /**
     * The permissions granted to this API Key (See API Key Authentication)
     * @type {Array<string>}
     * @memberof IdOrEmailApikeysBody
     */
    permissions?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * The id of the rate provider
     * @type {string}
     * @memberof InlineResponse200
     */
    id?: string;
    /**
     * The name of the rate provider
     * @type {string}
     * @memberof InlineResponse200
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * The permission id
     * @type {string}
     * @memberof InlineResponse2001
     */
    name?: string;
    /**
     * Permissions included in this array are also granted by this permission
     * @type {Array<string>}
     * @memberof InlineResponse2001
     */
    included?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * The language code
     * @type {string}
     * @memberof InlineResponse2002
     */
    code?: string;
    /**
     * The language name
     * @type {string}
     * @memberof InlineResponse2002
     */
    currentLanguage?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * The lnurl withdraw of the server
     * @type {string}
     * @memberof InlineResponse2003
     */
    LNURLW?: string;
    /**
     * The version of the registration (See [Deterministic Boltcard Key Generation](https://github.com/boltcard/boltcard/blob/main/docs/DETERMINISTIC.md))
     * @type {number}
     * @memberof InlineResponse2003
     */
    version?: number;
    /**
     * The public key K0 of the boltcard
     * @type {string}
     * @memberof InlineResponse2003
     */
    k0?: string;
    /**
     * The public key K1 of the boltcard
     * @type {string}
     * @memberof InlineResponse2003
     */
    k1?: string;
    /**
     * The public key K2 of the boltcard
     * @type {string}
     * @memberof InlineResponse2003
     */
    k2?: string;
    /**
     * The public key K3 of the boltcard
     * @type {string}
     * @memberof InlineResponse2003
     */
    k3?: string;
    /**
     * The public key K4 of the boltcard
     * @type {string}
     * @memberof InlineResponse2003
     */
    k4?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 extends GenericPaymentMethodData {
    /**
     * 
     * @type {Mnemonic}
     * @memberof InlineResponse2005
     */
    mnemonic?: Mnemonic;
    /**
     * 
     * @type {OnChainPaymentMethodBaseData}
     * @memberof InlineResponse2005
     */
    config?: OnChainPaymentMethodBaseData;
}
/**
 * An additional status that describes why an invoice is in its current status.
 * @export
 * @enum {string}
 */
export enum InvoiceAdditionalStatus {
    Invalid = <any>'Invalid',
    Marked = <any>'Marked',
    None = <any>'None',
    PaidLate = <any>'PaidLate',
    PaidOver = <any>'PaidOver',
    PaidPartial = <any>'PaidPartial'
}
/**
 * 
 * @export
 * @interface InvoiceData
 */
export interface InvoiceData extends InvoiceDataBase {
    /**
     * The identifier of the invoice
     * @type {string}
     * @memberof InvoiceData
     */
    id?: string;
    /**
     * The store identifier that the invoice belongs to
     * @type {StoreId}
     * @memberof InvoiceData
     */
    storeId?: StoreId;
    /**
     * The amount of the invoice. Note that the amount will be zero for a top-up invoice that is paid after invoice expiry.
     * @type {string}
     * @memberof InvoiceData
     */
    amount?: string;
    /**
     * The currency of the invoice
     * @type {string}
     * @memberof InvoiceData
     */
    currency?: string;
    /**
     * 
     * @type {InvoiceType}
     * @memberof InvoiceData
     */
    type?: InvoiceType;
    /**
     * The link to the checkout page, where you can redirect the customer
     * @type {string}
     * @memberof InvoiceData
     */
    checkoutLink?: string;
    /**
     * The creation time of the invoice
     * @type {UnixTimestamp}
     * @memberof InvoiceData
     */
    createdTime?: UnixTimestamp;
    /**
     * The expiration time of the invoice
     * @type {UnixTimestamp}
     * @memberof InvoiceData
     */
    expirationTime?: UnixTimestamp;
    /**
     * Expiration time for monitoring of the invoice for any changes
     * @type {UnixTimestamp}
     * @memberof InvoiceData
     */
    monitoringExpiration?: UnixTimestamp;
    /**
     * 
     * @type {InvoiceStatus}
     * @memberof InvoiceData
     */
    status?: InvoiceStatus;
    /**
     * 
     * @type {InvoiceAdditionalStatus}
     * @memberof InvoiceData
     */
    additionalStatus?: InvoiceAdditionalStatus;
    /**
     * The statuses the invoice can be manually marked as
     * @type {Array<InvoiceStatus>}
     * @memberof InvoiceData
     */
    availableStatusesForManualMarking?: Array<InvoiceStatus>;
    /**
     * true if the invoice is archived
     * @type {boolean}
     * @memberof InvoiceData
     */
    archived?: boolean;
}
/**
 * 
 * @export
 * @interface InvoiceDataBase
 */
export interface InvoiceDataBase {
    /**
     * 
     * @type {InvoiceMetadata}
     * @memberof InvoiceDataBase
     */
    metadata?: InvoiceMetadata;
    /**
     * Additional settings to customize the checkout flow
     * @type {CheckoutOptions}
     * @memberof InvoiceDataBase
     */
    checkout?: CheckoutOptions;
    /**
     * Additional settings to customize the public receipt
     * @type {ReceiptOptions}
     * @memberof InvoiceDataBase
     */
    receipt?: ReceiptOptions;
}
/**
 * 
 * @export
 */
export type InvoiceDataList = Array<InvoiceData>
/**
 * 
 * @export
 * @interface InvoiceIdRefundBody
 */
export interface InvoiceIdRefundBody {
    /**
     * Name of the pull payment (Default: 'Refund' followed by the invoice id)
     * @type {string}
     * @memberof InvoiceIdRefundBody
     */
    name?: string;
    /**
     * Description of the pull payment
     * @type {string}
     * @memberof InvoiceIdRefundBody
     */
    description?: string;
    /**
     * 
     * @type {PayoutMethodId}
     * @memberof InvoiceIdRefundBody
     */
    payoutMethodId?: PayoutMethodId;
    /**
     * * `RateThen`: Refund the crypto currency price, at the rate the invoice got paid.  * `CurrentRate`: Refund the crypto currency price, at the current rate.  *`Fiat`: Refund the invoice currency, at the rate when the refund will be sent.  *`OverpaidAmount`: Refund the crypto currency amount that was overpaid.  *`Custom`: Specify the amount, currency, and rate of the refund. (see `customAmount` and `customCurrency`)
     * @type {string}
     * @memberof InvoiceIdRefundBody
     */
    refundVariant?: InvoiceIdRefundBody.RefundVariantEnum;
    /**
     * Optional percentage by which to reduce the refund, e.g. as processing charge or to compensate for the mining fee.
     * @type {string}
     * @memberof InvoiceIdRefundBody
     */
    subtractPercentage?: string;
    /**
     * The amount to refund if the `refundVariant` is `Custom`.
     * @type {string}
     * @memberof InvoiceIdRefundBody
     */
    customAmount?: string;
    /**
     * The currency to refund if the `refundVariant` is `Custom`
     * @type {string}
     * @memberof InvoiceIdRefundBody
     */
    customCurrency?: string;
}

/**
 * @export
 * @namespace InvoiceIdRefundBody
 */
export namespace InvoiceIdRefundBody {
    /**
     * @export
     * @enum {string}
     */
    export enum RefundVariantEnum {
        CurrentRate = <any>'CurrentRate',
        Custom = <any>'Custom',
        Fiat = <any>'Fiat',
        OverpaidAmount = <any>'OverpaidAmount',
        RateThen = <any>'RateThen'
    }
}
/**
 * Additional information around the invoice that can be supplied. The mentioned properties are all optional and you can introduce any json format you wish. See [our documentation](https://docs.btcpayserver.org/Development/InvoiceMetadata/) for more information.
 * @export
 * @interface InvoiceMetadata
 */
export interface InvoiceMetadata {
}
/**
 * 
 * @export
 * @interface InvoicePaymentMethodDataModel
 */
export interface InvoicePaymentMethodDataModel {
    /**
     * 
     * @type {PaymentMethodId}
     * @memberof InvoicePaymentMethodDataModel
     */
    paymentMethodId?: PaymentMethodId;
    /**
     * The currency of the payment method (e.g., \"BTC\" or \"LTC\")
     * @type {string}
     * @memberof InvoicePaymentMethodDataModel
     */
    currency?: string;
    /**
     * The destination the payment must be made to
     * @type {string}
     * @memberof InvoicePaymentMethodDataModel
     */
    destination?: string;
    /**
     * A payment link that helps pay to the payment destination
     * @type {string}
     * @memberof InvoicePaymentMethodDataModel
     */
    paymentLink?: string;
    /**
     * The rate between this payment method's currency and the invoice currency
     * @type {string}
     * @memberof InvoicePaymentMethodDataModel
     */
    rate?: string;
    /**
     * The amount paid by this payment method
     * @type {string}
     * @memberof InvoicePaymentMethodDataModel
     */
    paymentMethodPaid?: string;
    /**
     * The total amount paid by all payment methods to the invoice, converted to this payment method's currency
     * @type {string}
     * @memberof InvoicePaymentMethodDataModel
     */
    totalPaid?: string;
    /**
     * The total amount left to be paid, converted to this payment method's currency (will be negative if overpaid)
     * @type {string}
     * @memberof InvoicePaymentMethodDataModel
     */
    due?: string;
    /**
     * The invoice amount, converted to this payment method's currency
     * @type {string}
     * @memberof InvoicePaymentMethodDataModel
     */
    amount?: string;
    /**
     * The added merchant fee to pay for additional costs incurred by this payment method.
     * @type {string}
     * @memberof InvoicePaymentMethodDataModel
     */
    paymentMethodFee?: string;
    /**
     * Payments made with this payment method.
     * @type {Array<Payment>}
     * @memberof InvoicePaymentMethodDataModel
     */
    payments?: Array<Payment>;
    /**
     * If the payment method is activated (when lazy payments option is enabled
     * @type {boolean}
     * @memberof InvoicePaymentMethodDataModel
     */
    activated?: boolean;
    /**
     * Additional data provided by the payment method.
     * @type {any}
     * @memberof InvoicePaymentMethodDataModel
     */
    additionalData?: any;
}
/**
 * The status of the invoice
 * @export
 * @enum {string}
 */
export enum InvoiceStatus {
    Expired = <any>'Expired',
    Invalid = <any>'Invalid',
    New = <any>'New',
    Processing = <any>'Processing',
    Settled = <any>'Settled'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum InvoiceStatusMark {
    Invalid = <any>'Invalid',
    Settled = <any>'Settled'
}
/**
 * The type of the invoice
 * @export
 * @enum {string}
 */
export enum InvoiceType {
    Standard = <any>'Standard',
    TopUp = <any>'TopUp'
}
/**
 * 
 * @export
 * @interface LNURLData
 */
export interface LNURLData {
    /**
     * Bech32 representation of LNURL
     * @type {string}
     * @memberof LNURLData
     */
    lnurlBech32?: string;
    /**
     * URI representation of LNURL
     * @type {string}
     * @memberof LNURLData
     */
    lnurlUri?: string;
}
/**
 * 
 * @export
 * @interface LNURLPayPaymentMethodBaseData
 */
export interface LNURLPayPaymentMethodBaseData {
    /**
     * Whether to use [LUD-01](https://github.com/fiatjaf/lnurl-rfc/blob/luds/01.md)'s bech32 format or to use [LUD-17](https://github.com/fiatjaf/lnurl-rfc/blob/luds/17.md) url formatting. 
     * @type {boolean}
     * @memberof LNURLPayPaymentMethodBaseData
     */
    useBech32Scheme?: boolean;
    /**
     * Allow comments to be passed on via lnurl.
     * @type {boolean}
     * @memberof LNURLPayPaymentMethodBaseData
     */
    lud12Enabled?: boolean;
}
/**
 * 
 * @export
 * @interface LabelData
 */
export interface LabelData extends Record<string, any> {
    [key: string]: any;

}
/**
 * 
 * @export
 * @interface LightningAddressData
 */
export interface LightningAddressData {
    /**
     * The username of the lightning address
     * @type {string}
     * @memberof LightningAddressData
     */
    username?: string;
    /**
     * The currency to generate the invoices for this lightning address in. Leave null lto use the store default.
     * @type {string}
     * @memberof LightningAddressData
     */
    currencyCode?: string;
    /**
     * The minimum amount in sats this ln address allows
     * @type {string}
     * @memberof LightningAddressData
     */
    min?: string;
    /**
     * The maximum amount in sats this ln address allows
     * @type {string}
     * @memberof LightningAddressData
     */
    max?: string;
    /**
     * The invoice metadata as JSON.
     * @type {any}
     * @memberof LightningAddressData
     */
    invoiceMetadata?: any;
}
/**
 * 
 * @export
 * @interface LightningAutomatedTransferSettings
 */
export interface LightningAutomatedTransferSettings {
    /**
     * 
     * @type {PayoutMethodId}
     * @memberof LightningAutomatedTransferSettings
     */
    payoutMethodId?: PayoutMethodId;
    /**
     * How often should the processor run
     * @type {TimeSpanSeconds}
     * @memberof LightningAutomatedTransferSettings
     */
    intervalSeconds?: TimeSpanSeconds;
    /**
     * How many failures should the processor tolerate before cancelling the payout
     * @type {number}
     * @memberof LightningAutomatedTransferSettings
     */
    cancelPayoutAfterFailures?: number;
    /**
     * Skip the interval when ane eligible payout has been approved (or created with pre-approval)
     * @type {boolean}
     * @memberof LightningAutomatedTransferSettings
     */
    processNewPayoutsInstantly?: boolean;
}
/**
 * 
 * @export
 * @interface LightningChannelData
 */
export interface LightningChannelData {
    /**
     * The public key of the node (Node ID)
     * @type {string}
     * @memberof LightningChannelData
     */
    remoteNode?: string;
    /**
     * Whether the node is public
     * @type {boolean}
     * @memberof LightningChannelData
     */
    isPublic?: boolean;
    /**
     * Whether the node is online
     * @type {boolean}
     * @memberof LightningChannelData
     */
    isActive?: boolean;
    /**
     * The capacity of the channel in millisatoshi
     * @type {string}
     * @memberof LightningChannelData
     */
    capacity?: string;
    /**
     * The local balance of the channel in millisatoshi
     * @type {string}
     * @memberof LightningChannelData
     */
    localBalance?: string;
    /**
     * 
     * @type {string}
     * @memberof LightningChannelData
     */
    channelPoint?: string;
}
/**
 * 
 * @export
 * @interface LightningInvoiceData
 */
export interface LightningInvoiceData {
    /**
     * The invoice's ID
     * @type {string}
     * @memberof LightningInvoiceData
     */
    id?: string;
    /**
     * 
     * @type {LightningInvoiceStatus}
     * @memberof LightningInvoiceData
     */
    status?: LightningInvoiceStatus;
    /**
     * The BOLT11 representation of the invoice
     * @type {string}
     * @memberof LightningInvoiceData
     */
    bOLT11?: string;
    /**
     * The unix timestamp when the invoice got paid
     * @type {UnixTimestamp}
     * @memberof LightningInvoiceData
     */
    paidAt?: UnixTimestamp;
    /**
     * The unix timestamp when the invoice expires
     * @type {UnixTimestamp}
     * @memberof LightningInvoiceData
     */
    expiresAt?: UnixTimestamp;
    /**
     * The amount of the invoice in millisatoshi
     * @type {string}
     * @memberof LightningInvoiceData
     */
    amount?: string;
    /**
     * The amount received in millisatoshi
     * @type {string}
     * @memberof LightningInvoiceData
     */
    amountReceived?: string;
    /**
     * The payment hash
     * @type {string}
     * @memberof LightningInvoiceData
     */
    paymentHash?: string;
    /**
     * The payment preimage (available when status is complete)
     * @type {string}
     * @memberof LightningInvoiceData
     */
    preimage?: string;
    /**
     * The custom TLV records attached to a keysend payment
     * @type {any}
     * @memberof LightningInvoiceData
     */
    customRecords?: any;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum LightningInvoiceStatus {
    Expired = <any>'Expired',
    Paid = <any>'Paid',
    Unpaid = <any>'Unpaid'
}
/**
 * 
 * @export
 * @interface LightningNetworkPaymentMethodBaseData
 */
export interface LightningNetworkPaymentMethodBaseData {
    /**
     * The lightning connection string. Set to 'Internal Node' to use the internal node. (See [this doc](https://github.com/btcpayserver/BTCPayServer.Lightning/blob/master/README.md#examples) for some example)
     * @type {string}
     * @memberof LightningNetworkPaymentMethodBaseData
     */
    connectionstring?: string;
}
/**
 * 
 * @export
 * @interface LightningNodeBalanceData
 */
export interface LightningNodeBalanceData {
    /**
     * On-chain balance of the Lightning node
     * @type {OnchainBalanceData}
     * @memberof LightningNodeBalanceData
     */
    onchain?: OnchainBalanceData;
    /**
     * Off-chain balance of the Lightning node
     * @type {OffchainBalanceData}
     * @memberof LightningNodeBalanceData
     */
    offchain?: OffchainBalanceData;
}
/**
 * 
 * @export
 * @interface LightningNodeInformationData
 */
export interface LightningNodeInformationData {
    /**
     * Node URIs to connect to this node in the form `pubkey@endpoint[:port]`
     * @type {Array<string>}
     * @memberof LightningNodeInformationData
     */
    nodeURIs?: Array<string>;
    /**
     * The block height of the lightning node
     * @type {number}
     * @memberof LightningNodeInformationData
     */
    blockHeight?: number;
    /**
     * The alias of the lightning node
     * @type {string}
     * @memberof LightningNodeInformationData
     */
    alias?: string;
    /**
     * The color attribute of the lightning node
     * @type {string}
     * @memberof LightningNodeInformationData
     */
    color?: string;
    /**
     * The version name of the lightning node
     * @type {string}
     * @memberof LightningNodeInformationData
     */
    version?: string;
    /**
     * The number of peers
     * @type {number}
     * @memberof LightningNodeInformationData
     */
    peersCount?: number;
    /**
     * The number of active channels
     * @type {number}
     * @memberof LightningNodeInformationData
     */
    activeChannelsCount?: number;
    /**
     * The number of inactive channels
     * @type {number}
     * @memberof LightningNodeInformationData
     */
    inactiveChannelsCount?: number;
    /**
     * The number of pending channels
     * @type {number}
     * @memberof LightningNodeInformationData
     */
    pendingChannelsCount?: number;
}
/**
 * 
 * @export
 * @interface LightningPaymentData
 */
export interface LightningPaymentData {
    /**
     * The payment's ID
     * @type {string}
     * @memberof LightningPaymentData
     */
    id?: string;
    /**
     * 
     * @type {LightningPaymentStatus}
     * @memberof LightningPaymentData
     */
    status?: LightningPaymentStatus;
    /**
     * The BOLT11 representation of the payment
     * @type {string}
     * @memberof LightningPaymentData
     */
    bOLT11?: string;
    /**
     * The payment hash
     * @type {string}
     * @memberof LightningPaymentData
     */
    paymentHash?: string;
    /**
     * The payment preimage (available when status is complete)
     * @type {string}
     * @memberof LightningPaymentData
     */
    preimage?: string;
    /**
     * The unix timestamp when the payment got created
     * @type {UnixTimestamp}
     * @memberof LightningPaymentData
     */
    createdAt?: UnixTimestamp;
    /**
     * The total amount (including fees) in millisatoshi
     * @type {string}
     * @memberof LightningPaymentData
     */
    totalAmount?: string;
    /**
     * The total fees in millisatoshi
     * @type {string}
     * @memberof LightningPaymentData
     */
    feeAmount?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum LightningPaymentStatus {
    Complete = <any>'Complete',
    Failed = <any>'Failed',
    Pending = <any>'Pending',
    Unknown = <any>'Unknown'
}
/**
 * 
 * @export
 * @interface LockUserRequest
 */
export interface LockUserRequest {
    /**
     * Whether to lock or unlock the user
     * @type {boolean}
     * @memberof LockUserRequest
     */
    locked?: boolean;
}
/**
 * 
 * @export
 * @interface MarkInvoiceStatusRequest
 */
export interface MarkInvoiceStatusRequest {
    /**
     * Mark an invoice as completed or invalid.
     * @type {InvoiceStatusMark}
     * @memberof MarkInvoiceStatusRequest
     */
    status?: InvoiceStatusMark;
}
/**
 * 
 * @export
 * @interface MePictureBody
 */
export interface MePictureBody {
    /**
     * The profile picture
     * @type {Blob}
     * @memberof MePictureBody
     */
    file?: Blob;
}
/**
 * A BIP39 mnemonic
 * @export
 */
export type Mnemonic = string
/**
 * Check whether network fee should be added to the invoice if on-chain payment is used. ([More information](https://docs.btcpayserver.org/FAQ/Stores/#add-network-fee-to-invoice-vary-with-mining-fees))
 * @export
 * @enum {string}
 */
export enum NetworkFeeMode {
    Always = <any>'Always',
    MultiplePaymentsOnly = <any>'MultiplePaymentsOnly',
    Never = <any>'Never'
}
/**
 * 
 * @export
 * @interface NotificationData
 */
export interface NotificationData {
    /**
     * The id of the notification
     * @type {string}
     * @memberof NotificationData
     */
    id?: string;
    /**
     * The identifier of the notification
     * @type {string}
     * @memberof NotificationData
     */
    identifier?: string;
    /**
     * The type of the notification
     * @type {string}
     * @memberof NotificationData
     */
    type?: string;
    /**
     * The html body of the notifications
     * @type {string}
     * @memberof NotificationData
     */
    body?: string;
    /**
     * If related to a store, the store id of the notification
     * @type {StoreId}
     * @memberof NotificationData
     */
    storeId?: StoreId;
    /**
     * The link of the notification
     * @type {string}
     * @memberof NotificationData
     */
    link?: string;
    /**
     * The creation time of the notification
     * @type {UnixTimestamp}
     * @memberof NotificationData
     */
    createdTime?: UnixTimestamp;
    /**
     * If the notification has been seen by the user
     * @type {boolean}
     * @memberof NotificationData
     */
    seen?: boolean;
}
/**
 * 
 * @export
 * @interface NotificationSettingsData
 */
export interface NotificationSettingsData {
    /**
     * The notification types
     * @type {Array<NotificationSettingsItemData>}
     * @memberof NotificationSettingsData
     */
    notifications?: Array<NotificationSettingsItemData>;
}
/**
 * 
 * @export
 * @interface NotificationSettingsItemData
 */
export interface NotificationSettingsItemData {
    /**
     * The identifier of the notification type
     * @type {string}
     * @memberof NotificationSettingsItemData
     */
    identifier?: string;
    /**
     * The description of the notification type
     * @type {string}
     * @memberof NotificationSettingsItemData
     */
    name?: string;
    /**
     * If the notification type is enabled
     * @type {boolean}
     * @memberof NotificationSettingsItemData
     */
    enabled?: boolean;
}
/**
 * 
 * @export
 * @interface OffchainBalanceData
 */
export interface OffchainBalanceData {
    /**
     * The amount of current channel openings in millisatoshi
     * @type {string}
     * @memberof OffchainBalanceData
     */
    opening?: string;
    /**
     * The amount that is available on the local end of active channels in millisatoshi
     * @type {string}
     * @memberof OffchainBalanceData
     */
    local?: string;
    /**
     * The amount that is available on the remote end of active channels in millisatoshi
     * @type {string}
     * @memberof OffchainBalanceData
     */
    remote?: string;
    /**
     * The amount of current channel closings in millisatoshi
     * @type {string}
     * @memberof OffchainBalanceData
     */
    closing?: string;
}
/**
 * 
 * @export
 * @interface OnChainAutomatedTransferSettings
 */
export interface OnChainAutomatedTransferSettings {
    /**
     * 
     * @type {PayoutMethodId}
     * @memberof OnChainAutomatedTransferSettings
     */
    payoutMethodId?: PayoutMethodId;
    /**
     * How many blocks should the fee rate calculation target to confirm in.
     * @type {number}
     * @memberof OnChainAutomatedTransferSettings
     */
    feeTargetBlock?: number;
    /**
     * How often should the processor run
     * @type {TimeSpanSeconds}
     * @memberof OnChainAutomatedTransferSettings
     */
    intervalSeconds?: TimeSpanSeconds;
    /**
     * Only process payouts when this payout sum is reached.
     * @type {string}
     * @memberof OnChainAutomatedTransferSettings
     */
    threshold?: string;
    /**
     * Skip the interval when ane eligible payout has been approved (or created with pre-approval)
     * @type {boolean}
     * @memberof OnChainAutomatedTransferSettings
     */
    processNewPayoutsInstantly?: boolean;
}
/**
 * 
 * @export
 * @interface OnChainPaymentMethodBaseData
 */
export interface OnChainPaymentMethodBaseData {
    /**
     * The derivation scheme
     * @type {string}
     * @memberof OnChainPaymentMethodBaseData
     */
    derivationScheme?: string;
    /**
     * A label that will be shown in the UI
     * @type {string}
     * @memberof OnChainPaymentMethodBaseData
     */
    label?: string;
    /**
     * The wallet fingerprint followed by the keypath to derive the account key used for signing operation or creating PSBTs
     * @type {string}
     * @memberof OnChainPaymentMethodBaseData
     */
    accountKeyPath?: string;
}
/**
 * 
 * @export
 * @interface OnChainPaymentMethodPreviewResultAddressItem
 */
export interface OnChainPaymentMethodPreviewResultAddressItem {
    /**
     * The key path relative to the account key path.
     * @type {string}
     * @memberof OnChainPaymentMethodPreviewResultAddressItem
     */
    keyPath?: string;
    /**
     * The address generated at the key path
     * @type {string}
     * @memberof OnChainPaymentMethodPreviewResultAddressItem
     */
    address?: string;
}
/**
 * 
 * @export
 * @interface OnChainPaymentMethodPreviewResultData
 */
export interface OnChainPaymentMethodPreviewResultData {
    /**
     * a list of addresses generated by the derivation scheme
     * @type {Array<OnChainPaymentMethodPreviewResultAddressItem>}
     * @memberof OnChainPaymentMethodPreviewResultData
     */
    addresses?: Array<OnChainPaymentMethodPreviewResultAddressItem>;
}
/**
 * 
 * @export
 * @interface OnChainWalletAddressData
 */
export interface OnChainWalletAddressData {
    /**
     * The bitcoin address
     * @type {string}
     * @memberof OnChainWalletAddressData
     */
    address?: string;
    /**
     * the derivation path in relation to the HD account
     * @type {string}
     * @memberof OnChainWalletAddressData
     */
    keyPath?: string;
    /**
     * a bip21 payment link
     * @type {string}
     * @memberof OnChainWalletAddressData
     */
    paymentLink?: string;
}
/**
 * 
 * @export
 * @interface OnChainWalletFeeRateData
 */
export interface OnChainWalletFeeRateData {
    /**
     * The fee rate (sats per byte) based on the wallet's configured recommended block confirmation target
     * @type {number}
     * @memberof OnChainWalletFeeRateData
     */
    feerate?: number;
}
/**
 * 
 * @export
 * @interface OnChainWalletObjectData
 */
export interface OnChainWalletObjectData extends OnChainWalletObjectId {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OnChainWalletObjectData
     */
    data?: { [key: string]: any; };
    /**
     * Links of this object
     * @type {Array<OnChainWalletObjectLink>}
     * @memberof OnChainWalletObjectData
     */
    links?: Array<OnChainWalletObjectLink>;
}
/**
 * 
 * @export
 * @interface OnChainWalletObjectId
 */
export interface OnChainWalletObjectId {
    /**
     * The type of wallet object
     * @type {string}
     * @memberof OnChainWalletObjectId
     */
    type?: string;
    /**
     * The identifier of the wallet object (unique per type, per wallet)
     * @type {string}
     * @memberof OnChainWalletObjectId
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface OnChainWalletObjectLink
 */
export interface OnChainWalletObjectLink {
    /**
     * The type of wallet object
     * @type {string}
     * @memberof OnChainWalletObjectLink
     */
    type?: string;
    /**
     * The identifier of the wallet object (unique per type, per wallet)
     * @type {string}
     * @memberof OnChainWalletObjectLink
     */
    id?: string;
    /**
     * The data of the link
     * @type {{ [key: string]: any; }}
     * @memberof OnChainWalletObjectLink
     */
    linkData?: { [key: string]: any; };
    /**
     * The data of the neighbour's node (`null` if there isn't any data or `includeNeighbourData` is `false`)
     * @type {{ [key: string]: any; }}
     * @memberof OnChainWalletObjectLink
     */
    objectData?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface OnChainWalletOverviewData
 */
export interface OnChainWalletOverviewData {
    /**
     * The total current balance of the wallet
     * @type {string}
     * @memberof OnChainWalletOverviewData
     */
    balance?: string;
    /**
     * The current unconfirmed balance of the wallet
     * @type {string}
     * @memberof OnChainWalletOverviewData
     */
    unconfirmedBalance?: string;
    /**
     * The current confirmed balance of the wallet
     * @type {string}
     * @memberof OnChainWalletOverviewData
     */
    confirmedBalance?: string;
}
/**
 * 
 * @export
 * @interface OnChainWalletTransactionData
 */
export interface OnChainWalletTransactionData {
    /**
     * The transaction id
     * @type {string}
     * @memberof OnChainWalletTransactionData
     */
    transactionHash?: string;
    /**
     * A comment linked to the transaction
     * @type {string}
     * @memberof OnChainWalletTransactionData
     */
    comment?: string;
    /**
     * The amount the wallet balance changed with this transaction
     * @type {string}
     * @memberof OnChainWalletTransactionData
     */
    amount?: string;
    /**
     * The hash of the block that confirmed this transaction. Null if still unconfirmed.
     * @type {string}
     * @memberof OnChainWalletTransactionData
     */
    blockHash?: string;
    /**
     * The height of the block that confirmed this transaction. Null if still unconfirmed.
     * @type {string}
     * @memberof OnChainWalletTransactionData
     */
    blockHeight?: string;
    /**
     * The number of confirmations for this transaction
     * @type {string}
     * @memberof OnChainWalletTransactionData
     */
    confirmations?: string;
    /**
     * The time of the transaction
     * @type {UnixTimestamp}
     * @memberof OnChainWalletTransactionData
     */
    timestamp?: UnixTimestamp;
    /**
     * The status of this transaction
     * @type {TransactionStatus}
     * @memberof OnChainWalletTransactionData
     */
    status?: TransactionStatus;
    /**
     * Labels linked to this transaction
     * @type {Array<LabelData>}
     * @memberof OnChainWalletTransactionData
     */
    labels?: Array<LabelData>;
}
/**
 * 
 * @export
 * @interface OnChainWalletUTXOData
 */
export interface OnChainWalletUTXOData {
    /**
     * A comment linked to this utxo
     * @type {string}
     * @memberof OnChainWalletUTXOData
     */
    comment?: string;
    /**
     * the value of this utxo
     * @type {string}
     * @memberof OnChainWalletUTXOData
     */
    amount?: string;
    /**
     * a link to the configured blockchain explorer to view the utxo
     * @type {string}
     * @memberof OnChainWalletUTXOData
     */
    link?: string;
    /**
     * outpoint of this utxo
     * @type {string}
     * @memberof OnChainWalletUTXOData
     */
    outpoint?: string;
    /**
     * The time of the utxo
     * @type {UnixTimestamp}
     * @memberof OnChainWalletUTXOData
     */
    timestamp?: UnixTimestamp;
    /**
     * the derivation path in relation to the HD account
     * @type {string}
     * @memberof OnChainWalletUTXOData
     */
    keyPath?: string;
    /**
     * The wallet address of this utxo
     * @type {string}
     * @memberof OnChainWalletUTXOData
     */
    address?: string;
    /**
     * The number of confirmations of this utxo
     * @type {number}
     * @memberof OnChainWalletUTXOData
     */
    confirmations?: number;
    /**
     * Labels linked to this transaction
     * @type {Array<LabelData>}
     * @memberof OnChainWalletUTXOData
     */
    labels?: Array<LabelData>;
}
/**
 * 
 * @export
 * @interface OnchainBalanceData
 */
export interface OnchainBalanceData {
    /**
     * The confirmed amount in satoshi
     * @type {string}
     * @memberof OnchainBalanceData
     */
    confirmed?: string;
    /**
     * The unconfirmed amount in satoshi
     * @type {string}
     * @memberof OnchainBalanceData
     */
    unconfirmed?: string;
    /**
     * The reserved amount in satoshi
     * @type {string}
     * @memberof OnchainBalanceData
     */
    reserved?: string;
}
/**
 * 
 * @export
 * @interface OpenLightningChannelRequest
 */
export interface OpenLightningChannelRequest {
    /**
     * Node URI in the form `pubkey@endpoint[:port]`
     * @type {string}
     * @memberof OpenLightningChannelRequest
     */
    nodeURI?: string;
    /**
     * The amount to fund (in satoshi)
     * @type {string}
     * @memberof OpenLightningChannelRequest
     */
    channelAmount?: string;
    /**
     * The amount to fund (in satoshi per byte)
     * @type {number}
     * @memberof OpenLightningChannelRequest
     */
    feeRate?: number;
}
/**
 * 
 * @export
 * @interface PatchOnChainTransactionRequest
 */
export interface PatchOnChainTransactionRequest {
    /**
     * Transaction comment
     * @type {string}
     * @memberof PatchOnChainTransactionRequest
     */
    comment?: string;
    /**
     * Transaction labels
     * @type {Array<string>}
     * @memberof PatchOnChainTransactionRequest
     */
    labels?: Array<string>;
}
/**
 * 
 * @export
 * @interface PayLightningInvoiceRequest
 */
export interface PayLightningInvoiceRequest {
    /**
     * The BOLT11 of the invoice to pay
     * @type {string}
     * @memberof PayLightningInvoiceRequest
     */
    bOLT11?: string;
    /**
     * Optional explicit payment amount in millisatoshi (if specified, it overrides the BOLT11 amount)
     * @type {string}
     * @memberof PayLightningInvoiceRequest
     */
    amount?: string;
    /**
     * The fee limit expressed as a percentage of the payment amount
     * @type {string}
     * @memberof PayLightningInvoiceRequest
     */
    maxFeePercent?: string;
    /**
     * The fee limit expressed as a fixed amount in satoshi
     * @type {string}
     * @memberof PayLightningInvoiceRequest
     */
    maxFeeFlat?: string;
    /**
     * The number of seconds after which the payment times out
     * @type {TimeSpanSeconds}
     * @memberof PayLightningInvoiceRequest
     */
    sendTimeout?: TimeSpanSeconds;
}
/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * A unique identifier for this payment
     * @type {string}
     * @memberof Payment
     */
    id?: string;
    /**
     * The date the payment was recorded
     * @type {UnixTimestamp}
     * @memberof Payment
     */
    receivedDate?: UnixTimestamp;
    /**
     * The value of the payment
     * @type {string}
     * @memberof Payment
     */
    value?: string;
    /**
     * The fee paid for the payment
     * @type {string}
     * @memberof Payment
     */
    fee?: string;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof Payment
     */
    status?: PaymentStatus;
    /**
     * The destination the payment was made to
     * @type {string}
     * @memberof Payment
     */
    destination?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethodCriteriaData
 */
export interface PaymentMethodCriteriaData {
    /**
     * 
     * @type {PaymentMethodId}
     * @memberof PaymentMethodCriteriaData
     */
    paymentMethodId?: PaymentMethodId;
    /**
     * The currency
     * @type {string}
     * @memberof PaymentMethodCriteriaData
     */
    currencyCode?: string;
    /**
     * The amount
     * @type {string}
     * @memberof PaymentMethodCriteriaData
     */
    amount?: string;
    /**
     * If the criterion is for above or below the amount
     * @type {boolean}
     * @memberof PaymentMethodCriteriaData
     */
    above?: boolean;
}
/**
 * Payment method IDs. Available payment method IDs for Bitcoin are:   - `\"BTC-CHAIN\"`: Onchain    -`\"BTC-LN\"`: Lightning    - `\"BTC-LNURL\"`: LNURL
 * @export
 */
export type PaymentMethodId = string
/**
 * 
 * @export
 * @interface PaymentRequestBaseData
 */
export interface PaymentRequestBaseData {
    /**
     * The amount of the payment request
     * @type {string}
     * @memberof PaymentRequestBaseData
     */
    amount?: string;
    /**
     * The title of the payment request
     * @type {string}
     * @memberof PaymentRequestBaseData
     */
    title?: string;
    /**
     * The currency of the payment request. If empty, the store's default currency code will be used.
     * @type {string}
     * @memberof PaymentRequestBaseData
     */
    currency?: string;
    /**
     * The email used in invoices generated by the payment request
     * @type {string}
     * @memberof PaymentRequestBaseData
     */
    email?: string;
    /**
     * The description of the payment request
     * @type {string}
     * @memberof PaymentRequestBaseData
     */
    description?: string;
    /**
     * The expiry date of the payment request
     * @type {UnixTimestamp}
     * @memberof PaymentRequestBaseData
     */
    expiryDate?: UnixTimestamp;
    /**
     * Whether to allow users to create invoices that partially pay the payment request 
     * @type {boolean}
     * @memberof PaymentRequestBaseData
     */
    allowCustomPaymentAmounts?: boolean;
    /**
     * Form ID to request customer data
     * @type {string}
     * @memberof PaymentRequestBaseData
     */
    formId?: string;
    /**
     * Form data response
     * @type {any}
     * @memberof PaymentRequestBaseData
     */
    formResponse?: any;
}
/**
 * 
 * @export
 * @interface PaymentRequestData
 */
export interface PaymentRequestData extends PaymentRequestBaseData {
    /**
     * The id of the payment request
     * @type {string}
     * @memberof PaymentRequestData
     */
    id?: string;
    /**
     * The store identifier that the payment request belongs to
     * @type {StoreId}
     * @memberof PaymentRequestData
     */
    storeId?: StoreId;
    /**
     * Represents the status of a payment request: * `Pending`: Not enough has been paid or settled. * `Completed`: Paid and fully settled. * `Expired`: Expired before full settlement. * `Processing`: Paid enough, awaiting full settlement.
     * @type {string}
     * @memberof PaymentRequestData
     */
    status?: PaymentRequestData.StatusEnum;
    /**
     * The creation date of the payment request
     * @type {UnixTimestamp}
     * @memberof PaymentRequestData
     */
    createdTime?: UnixTimestamp;
}

/**
 * @export
 * @namespace PaymentRequestData
 */
export namespace PaymentRequestData {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Pending = <any>'Pending',
        Completed = <any>'Completed',
        Processing = <any>'Processing',
        Expired = <any>'Expired'
    }
}
/**
 * 
 * @export
 */
export type PaymentRequestDataList = Array<PaymentRequestData>
/**
 * 
 * @export
 * @interface PaymentRequestIdPayBody
 */
export interface PaymentRequestIdPayBody {
    /**
     * The amount of the invoice. If `null` or `unspecified`, it will be set to the payment request's due amount. Note that the payment's request `allowCustomPaymentAmounts` must be `true`, or a 422 error will be sent back.'
     * @type {string}
     * @memberof PaymentRequestIdPayBody
     */
    amount?: string;
    /**
     * If `true`, this endpoint will not necessarily create a new invoice, and instead attempt to give back a pending one for this payment request.
     * @type {boolean}
     * @memberof PaymentRequestIdPayBody
     */
    allowPendingInvoiceReuse?: boolean;
}
/**
 * The status of the payment
 * @export
 * @enum {string}
 */
export enum PaymentStatus {
    Invalid = <any>'Invalid',
    Processing = <any>'Processing',
    Settled = <any>'Settled'
}
/**
 * 
 * @export
 * @interface PayoutData
 */
export interface PayoutData {
    /**
     * The id of the payout
     * @type {string}
     * @memberof PayoutData
     */
    id?: string;
    /**
     * The revision number of the payout. This revision number is incremented when the payout amount or destination is modified before the approval.
     * @type {number}
     * @memberof PayoutData
     */
    revision?: number;
    /**
     * The id of the pull payment this payout belongs to
     * @type {string}
     * @memberof PayoutData
     */
    pullPaymentId?: string;
    /**
     * The creation date of the payout as a unix timestamp
     * @type {string}
     * @memberof PayoutData
     */
    date?: string;
    /**
     * The destination of the payout (can be an address or a BIP21 url)
     * @type {string}
     * @memberof PayoutData
     */
    destination?: string;
    /**
     * The currency before being converted into the payout's currency
     * @type {string}
     * @memberof PayoutData
     */
    originalCurrency?: string;
    /**
     * The amount in originalCurrency before being converted into the payout's currency
     * @type {string}
     * @memberof PayoutData
     */
    originalAmount?: string;
    /**
     * The currency of the payout after conversion.
     * @type {string}
     * @memberof PayoutData
     */
    payoutCurrency?: string;
    /**
     * The amount in payoutCurrency after conversion. (This property is set after the payout has been Approved)
     * @type {string}
     * @memberof PayoutData
     */
    payoutAmount?: string;
    /**
     * 
     * @type {PayoutMethodId}
     * @memberof PayoutData
     */
    payoutMethodId?: PayoutMethodId;
    /**
     * 
     * @type {PayoutState}
     * @memberof PayoutData
     */
    state?: PayoutState;
    /**
     * 
     * @type {PayoutPaymentProof}
     * @memberof PayoutData
     */
    paymentProof?: PayoutPaymentProof;
    /**
     * Additional information around the payout that can be supplied. The mentioned properties are all optional and you can introduce any json format you wish.
     * @type {any}
     * @memberof PayoutData
     */
    metadata?: any;
}
/**
 * 
 * @export
 */
export type PayoutDataList = Array<PayoutData>
/**
 * 
 * @export
 * @interface PayoutIdMarkBody
 */
export interface PayoutIdMarkBody {
    /**
     * 
     * @type {PayoutState}
     * @memberof PayoutIdMarkBody
     */
    state?: PayoutState;
    /**
     * 
     * @type {PayoutPaymentProof}
     * @memberof PayoutIdMarkBody
     */
    paymentProof?: PayoutPaymentProof;
}
/**
 * Payout method IDs. Available payment method IDs for Bitcoin are:   - `\"BTC-CHAIN\"`: Onchain    -`\"BTC-LN\"`: Lightning
 * @export
 */
export type PayoutMethodId = string
/**
 * Additional information around how the payout is being or has been paid out. The mentioned properties are all optional (except `proofType`) and you can introduce any json format you wish.
 * @export
 * @interface PayoutPaymentProof
 */
export interface PayoutPaymentProof {
    /**
     * The type of payment proof it is.
     * @type {string}
     * @memberof PayoutPaymentProof
     */
    proofType?: string;
}
/**
 * 
 * @export
 * @interface PayoutProcessorData
 */
export interface PayoutProcessorData {
    /**
     * unique identifier of the payout processor
     * @type {string}
     * @memberof PayoutProcessorData
     */
    name?: string;
    /**
     * Human name of the payout processor
     * @type {string}
     * @memberof PayoutProcessorData
     */
    friendlyName?: string;
    /**
     * Supported, payment methods by this processor
     * @type {Array<string>}
     * @memberof PayoutProcessorData
     */
    payoutMethods?: Array<string>;
}
/**
 * The state of the payout (`AwaitingApproval`, `AwaitingPayment`, `InProgress`, `Completed`, `Cancelled`)
 * @export
 * @enum {string}
 */
export enum PayoutState {
    AwaitingApproval = <any>'AwaitingApproval',
    AwaitingPayment = <any>'AwaitingPayment',
    Cancelled = <any>'Cancelled',
    Completed = <any>'Completed',
    InProgress = <any>'InProgress'
}
/**
 * 
 * @export
 * @interface PayoutsPayoutIdBody
 */
export interface PayoutsPayoutIdBody {
    /**
     * The revision number of the payout being modified
     * @type {number}
     * @memberof PayoutsPayoutIdBody
     */
    revision?: number;
    /**
     * The rate rule to calculate the rate of the payout. This can also be a fixed decimal. (if null or unspecified, will use the same rate setting as the store's settings)
     * @type {string}
     * @memberof PayoutsPayoutIdBody
     */
    rateRule?: string;
}
/**
 * 
 * @export
 * @interface PointOfSaleAppData
 */
export interface PointOfSaleAppData extends PointOfSaleBaseData {
    /**
     * JSON object of app items
     * @type {Array<AppItem>}
     * @memberof PointOfSaleAppData
     */
    items?: Array<AppItem>;
}

/**
 * @export
 * @namespace PointOfSaleAppData
 */
export namespace PointOfSaleAppData {
}
/**
 * 
 * @export
 * @interface PointOfSaleAppRequest
 */
export interface PointOfSaleAppRequest extends PointOfSaleBaseData {
    /**
     * JSON of item available in the app
     * @type {string}
     * @memberof PointOfSaleAppRequest
     */
    template?: string;
}

/**
 * @export
 * @namespace PointOfSaleAppRequest
 */
export namespace PointOfSaleAppRequest {
}
/**
 * 
 * @export
 * @interface PointOfSaleBaseData
 */
export interface PointOfSaleBaseData extends AppBaseData {
    /**
     * Display title of the app
     * @type {string}
     * @memberof PointOfSaleBaseData
     */
    title?: string;
    /**
     * App description
     * @type {string}
     * @memberof PointOfSaleBaseData
     */
    description?: string;
    /**
     * App view type (e.g., static, cart, etc...)
     * @type {string}
     * @memberof PointOfSaleBaseData
     */
    defaultView?: PointOfSaleBaseData.DefaultViewEnum;
    /**
     * Display item selection for keypad
     * @type {boolean}
     * @memberof PointOfSaleBaseData
     */
    showItems?: boolean;
    /**
     * Whether the option to enter a custom amount is shown
     * @type {boolean}
     * @memberof PointOfSaleBaseData
     */
    showCustomAmount?: boolean;
    /**
     * Whether the option to enter a discount is shown
     * @type {boolean}
     * @memberof PointOfSaleBaseData
     */
    showDiscount?: boolean;
    /**
     * Display the search bar
     * @type {boolean}
     * @memberof PointOfSaleBaseData
     */
    showSearch?: boolean;
    /**
     * Display the list of categories
     * @type {boolean}
     * @memberof PointOfSaleBaseData
     */
    showCategories?: boolean;
    /**
     * Whether the option to enter a tip is shown
     * @type {boolean}
     * @memberof PointOfSaleBaseData
     */
    enableTips?: boolean;
    /**
     * Currency used for the app
     * @type {string}
     * @memberof PointOfSaleBaseData
     */
    currency?: string;
    /**
     * Payment button text template for items with a set price
     * @type {string}
     * @memberof PointOfSaleBaseData
     */
    fixedAmountPayButtonText?: string;
    /**
     * Payment button text which appears for items which allow user to input a custom amount
     * @type {string}
     * @memberof PointOfSaleBaseData
     */
    customAmountPayButtonText?: string;
    /**
     * Prompt which appears next to the tip amount field if tipping is enabled
     * @type {string}
     * @memberof PointOfSaleBaseData
     */
    tipText?: string;
    /**
     * Array of predefined tip percentage amounts
     * @type {Array<number>}
     * @memberof PointOfSaleBaseData
     */
    customTipPercentages?: Array<number>;
    /**
     * Callback notification url to POST to once when invoice is paid for and once when there are enough blockchain confirmations
     * @type {string}
     * @memberof PointOfSaleBaseData
     */
    notificationUrl?: string;
    /**
     * URL user is redirected to once invoice is paid
     * @type {string}
     * @memberof PointOfSaleBaseData
     */
    redirectUrl?: string;
    /**
     * Whether user is redirected to specified redirect URL automatically after the invoice is paid
     * @type {boolean}
     * @memberof PointOfSaleBaseData
     */
    redirectAutomatically?: boolean;
    /**
     * Used for SEO, the [HTML Lang](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang) of the page
     * @type {string}
     * @memberof PointOfSaleBaseData
     */
    htmlLang?: string;
    /**
     * Used for SEO, the [Meta tags](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta) of the page
     * @type {string}
     * @memberof PointOfSaleBaseData
     */
    htmlMetaTags?: string;
    /**
     * Form ID to request customer data
     * @type {string}
     * @memberof PointOfSaleBaseData
     */
    formId?: string;
}

/**
 * @export
 * @namespace PointOfSaleBaseData
 */
export namespace PointOfSaleBaseData {
    /**
     * @export
     * @enum {string}
     */
    export enum DefaultViewEnum {
        Static = <any>'Static',
        Cart = <any>'Cart',
        Light = <any>'Light',
        Print = <any>'Print'
    }
}
/**
 * Description of an error happening during processing of the request
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    /**
     * An error code describing the error
     * @type {string}
     * @memberof ProblemDetails
     */
    code?: string;
    /**
     * User friendly error message about the error
     * @type {string}
     * @memberof ProblemDetails
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface PullPaymentData
 */
export interface PullPaymentData {
    /**
     * Id of the pull payment
     * @type {string}
     * @memberof PullPaymentData
     */
    id?: string;
    /**
     * Name given to pull payment when it was created
     * @type {string}
     * @memberof PullPaymentData
     */
    name?: string;
    /**
     * Description given to pull payment when it was created
     * @type {string}
     * @memberof PullPaymentData
     */
    description?: string;
    /**
     * The currency of the pull payment's amount
     * @type {string}
     * @memberof PullPaymentData
     */
    currency?: string;
    /**
     * The amount in the currency of this pull payment as a decimal string
     * @type {string}
     * @memberof PullPaymentData
     */
    amount?: string;
    /**
     * If lightning is activated, do not accept BOLT11 invoices with expiration less than … days
     * @type {string}
     * @memberof PullPaymentData
     */
    bOLT11Expiration?: string;
    /**
     * Any payouts created for this pull payment will skip the approval phase upon creation
     * @type {boolean}
     * @memberof PullPaymentData
     */
    autoApproveClaims?: boolean;
    /**
     * Whether this pull payment is archived
     * @type {boolean}
     * @memberof PullPaymentData
     */
    archived?: boolean;
    /**
     * The link to a page to claim payouts to this pull payment
     * @type {string}
     * @memberof PullPaymentData
     */
    viewLink?: string;
}
/**
 * 
 * @export
 */
export type PullPaymentDataList = Array<PullPaymentData>
/**
 * 
 * @export
 * @interface PullPaymentIdBoltcardsBody
 */
export interface PullPaymentIdBoltcardsBody {
    /**
     * The `UID` of the NTag424
     * @type {string}
     * @memberof PullPaymentIdBoltcardsBody
     */
    UID: string;
    /**
     * What to do if the boltcard is already linked.  * `KeepVersion` will return the keys (K0-K4) that are already registered.  * `UpdateVersion` will increment the version of the key, and thus return different keys (K0-K4). (See [Deterministic Boltcard Key Generation](https://github.com/boltcard/boltcard/blob/main/docs/DETERMINISTIC.md))
     * @type {string}
     * @memberof PullPaymentIdBoltcardsBody
     */
    onExisting?: PullPaymentIdBoltcardsBody.OnExistingEnum;
}

/**
 * @export
 * @namespace PullPaymentIdBoltcardsBody
 */
export namespace PullPaymentIdBoltcardsBody {
    /**
     * @export
     * @enum {string}
     */
    export enum OnExistingEnum {
        KeepVersion = <any>'KeepVersion',
        UpdateVersion = <any>'UpdateVersion'
    }
}
/**
 * 
 * @export
 * @interface ReceiptOptions
 */
export interface ReceiptOptions {
    /**
     * A public page will be accessible once the invoice is settled. If null or unspecified, it will fallback to the store's settings. (The default store settings is true)
     * @type {boolean}
     * @memberof ReceiptOptions
     */
    enabled?: boolean;
    /**
     * Show the QR code of the receipt in the public receipt page. If null or unspecified, it will fallback to the store's settings. (The default store setting is true)
     * @type {boolean}
     * @memberof ReceiptOptions
     */
    showQR?: boolean;
    /**
     * Show the payment list in the public receipt page. If null or unspecified, it will fallback to the store's settings. (The default store setting is true)
     * @type {boolean}
     * @memberof ReceiptOptions
     */
    showPayments?: boolean;
}
/**
 * 
 * @export
 * @interface RoleData
 */
export interface RoleData {
    /**
     * The role's Id (Same as role if the role is created at server level, if the role is created at the store level the format is `STOREID::ROLE`)
     * @type {string}
     * @memberof RoleData
     */
    id?: string;
    /**
     * The role's name
     * @type {string}
     * @memberof RoleData
     */
    role?: string;
    /**
     * The permissions attached to this role
     * @type {Array<string>}
     * @memberof RoleData
     */
    permissions?: Array<string>;
    /**
     * Whether this role is at the scope of the store or scope of the server
     * @type {boolean}
     * @memberof RoleData
     */
    isServerRole?: boolean;
}
/**
 * This is a risk mitigation parameter for the merchant to configure how they want to fulfill orders depending on the number of block confirmations for the transaction made by the consumer on the selected cryptocurrency. `\"HighSpeed\"`: 0 confirmations (1 confirmation if RBF enabled in transaction)    `\"MediumSpeed\"`: 1 confirmation    `\"LowMediumSpeed\"`: 2 confirmations    `\"LowSpeed\"`: 6 confirmations 
 * @export
 * @enum {string}
 */
export enum SpeedPolicy {
    HighSpeed = <any>'HighSpeed',
    LowMediumSpeed = <any>'LowMediumSpeed',
    LowSpeed = <any>'LowSpeed',
    MediumSpeed = <any>'MediumSpeed'
}
/**
 * 
 * @export
 * @interface StoreBaseData
 */
export interface StoreBaseData {
    /**
     * The name of the store
     * @type {string}
     * @memberof StoreBaseData
     */
    name?: string;
    /**
     * The absolute url of the store
     * @type {string}
     * @memberof StoreBaseData
     */
    website?: string;
    /**
     * The support URI of the store, can contain the placeholders `{OrderId}` and `{InvoiceId}`. Can be any valid URI, such as a website, email, and nostr.
     * @type {string}
     * @memberof StoreBaseData
     */
    supportUrl?: string;
    /**
     * Absolute URL to a logo file or a reference to an uploaded file id with `fileid:ID`
     * @type {string}
     * @memberof StoreBaseData
     */
    logoUrl?: string;
    /**
     * Absolute URL to CSS file to customize the public/customer-facing pages of the store. (Invoice, Payment Request, Pull Payment, etc.) or a reference to an uploaded file id with `fileid:ID`
     * @type {string}
     * @memberof StoreBaseData
     */
    cssUrl?: string;
    /**
     * Absolute URL to a sound file or a reference to an uploaded file id with `fileid:ID`
     * @type {string}
     * @memberof StoreBaseData
     */
    paymentSoundUrl?: string;
    /**
     * The brand color of the store in HEX format
     * @type {string}
     * @memberof StoreBaseData
     */
    brandColor?: string;
    /**
     * Apply the brand color to the store's backend as well
     * @type {boolean}
     * @memberof StoreBaseData
     */
    applyBrandColorToBackend?: boolean;
    /**
     * The default currency of the store
     * @type {string}
     * @memberof StoreBaseData
     */
    defaultCurrency?: string;
    /**
     * The time after which an invoice is considered expired if not paid. The value will be rounded down to a minute.
     * @type {TimeSpanSeconds}
     * @memberof StoreBaseData
     */
    invoiceExpiration?: TimeSpanSeconds;
    /**
     * The minimum expiry of BOLT11 invoices accepted for refunds by default. (in days)
     * @type {TimeSpanDays}
     * @memberof StoreBaseData
     */
    refundBOLT11Expiration?: TimeSpanDays;
    /**
     * The time left that will trigger the countdown timer on the checkout page to be shown. The value will be rounded down to a minute.
     * @type {TimeSpanSeconds}
     * @memberof StoreBaseData
     */
    displayExpirationTimer?: TimeSpanSeconds;
    /**
     * The time after which an invoice which has been paid but not confirmed will be considered invalid. The value will be rounded down to a minute.
     * @type {TimeSpanSeconds}
     * @memberof StoreBaseData
     */
    monitoringExpiration?: TimeSpanSeconds;
    /**
     * 
     * @type {SpeedPolicy}
     * @memberof StoreBaseData
     */
    speedPolicy?: SpeedPolicy;
    /**
     * The BOLT11 description of the lightning invoice in the checkout. You can use placeholders '{StoreName}', '{ItemDescription}' and '{OrderId}'.
     * @type {string}
     * @memberof StoreBaseData
     */
    lightningDescriptionTemplate?: string;
    /**
     * Consider an invoice fully paid, even if the payment is missing 'x' % of the full amount.
     * @type {number}
     * @memberof StoreBaseData
     */
    paymentTolerance?: number;
    /**
     * If true, the store does not appear in the stores list by default.
     * @type {boolean}
     * @memberof StoreBaseData
     */
    archived?: boolean;
    /**
     * If true, then no authentication is needed to create invoices on this store.
     * @type {boolean}
     * @memberof StoreBaseData
     */
    anyoneCanCreateInvoice?: boolean;
    /**
     * Additional settings to customize the public receipt
     * @type {ReceiptOptions}
     * @memberof StoreBaseData
     */
    receipt?: ReceiptOptions;
    /**
     * If true, lightning payment methods show amount in satoshi in the checkout page.
     * @type {boolean}
     * @memberof StoreBaseData
     */
    lightningAmountInSatoshi?: boolean;
    /**
     * Should private route hints be included in the lightning payment of the checkout page.
     * @type {boolean}
     * @memberof StoreBaseData
     */
    lightningPrivateRouteHints?: boolean;
    /**
     * Unify on-chain and lightning payment URL.
     * @type {boolean}
     * @memberof StoreBaseData
     */
    onChainWithLnInvoiceFallback?: boolean;
    /**
     * After successfull payment, should the checkout page redirect the user automatically to the redirect URL of the invoice?
     * @type {boolean}
     * @memberof StoreBaseData
     */
    redirectAutomatically?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StoreBaseData
     */
    showRecommendedFee?: boolean;
    /**
     * The fee rate recommendation in the checkout page for the on-chain payment to be confirmed after 'x' blocks.
     * @type {number}
     * @memberof StoreBaseData
     */
    recommendedFeeBlockTarget?: number;
    /**
     * The default language to use in the checkout page. (The different translations available are listed [here](https://github.com/btcpayserver/btcpayserver/tree/master/BTCPayServer/wwwroot/locales)
     * @type {string}
     * @memberof StoreBaseData
     */
    defaultLang?: string;
    /**
     * The HTML title of the checkout page (when you over the tab in your browser)
     * @type {string}
     * @memberof StoreBaseData
     */
    htmlTitle?: string;
    /**
     * 
     * @type {NetworkFeeMode}
     * @memberof StoreBaseData
     */
    networkFeeMode?: NetworkFeeMode;
    /**
     * If true, payjoin will be proposed in the checkout page if possible. ([More information](https://docs.btcpayserver.org/Payjoin/))
     * @type {boolean}
     * @memberof StoreBaseData
     */
    payJoinEnabled?: boolean;
    /**
     * If true, the language on the checkout page will adapt to the language defined by the user's browser settings
     * @type {boolean}
     * @memberof StoreBaseData
     */
    autoDetectLanguage?: boolean;
    /**
     * If true, the \"Pay in wallet\" button will be shown on the checkout page (Checkout V2)
     * @type {boolean}
     * @memberof StoreBaseData
     */
    showPayInWalletButton?: boolean;
    /**
     * If true, the store header will be shown on the checkout page (Checkout V2)
     * @type {boolean}
     * @memberof StoreBaseData
     */
    showStoreHeader?: boolean;
    /**
     * If true, payments on the checkout page will be celebrated with confetti (Checkout V2)
     * @type {boolean}
     * @memberof StoreBaseData
     */
    celebratePayment?: boolean;
    /**
     * If true, sounds on the checkout page will be enabled (Checkout V2)
     * @type {boolean}
     * @memberof StoreBaseData
     */
    playSoundOnPayment?: boolean;
    /**
     * If true, payment methods are enabled individually upon user interaction in the invoice
     * @type {boolean}
     * @memberof StoreBaseData
     */
    lazyPaymentMethods?: boolean;
    /**
     * 
     * @type {PaymentMethodId}
     * @memberof StoreBaseData
     */
    defaultPaymentMethod?: PaymentMethodId;
    /**
     * The criteria required to activate specific payment methods.
     * @type {Array<PaymentMethodCriteriaData>}
     * @memberof StoreBaseData
     */
    paymentMethodCriteria?: Array<PaymentMethodCriteriaData>;
}
/**
 * 
 * @export
 * @interface StoreData
 */
export interface StoreData extends StoreBaseData {
    /**
     * The id of the store
     * @type {string}
     * @memberof StoreData
     */
    id?: string;
}
/**
 * 
 * @export
 */
export type StoreDataList = Array<StoreData>
/**
 * Store ID of the item
 * @export
 */
export type StoreId = string
/**
 * 
 * @export
 * @interface StoreIdLogoBody
 */
export interface StoreIdLogoBody {
    /**
     * The logo
     * @type {Blob}
     * @memberof StoreIdLogoBody
     */
    file?: Blob;
}
/**
 * 
 * @export
 * @interface StoreIdPullpaymentsBody
 */
export interface StoreIdPullpaymentsBody {
    /**
     * The name of the pull payment
     * @type {string}
     * @memberof StoreIdPullpaymentsBody
     */
    name?: string;
    /**
     * The description of the pull payment
     * @type {string}
     * @memberof StoreIdPullpaymentsBody
     */
    description?: string;
    /**
     * The amount in `currency` of this pull payment as a decimal string
     * @type {string}
     * @memberof StoreIdPullpaymentsBody
     */
    amount?: string;
    /**
     * The currency of the amount.
     * @type {string}
     * @memberof StoreIdPullpaymentsBody
     */
    currency?: string;
    /**
     * If lightning is activated, do not accept BOLT11 invoices with expiration less than … days
     * @type {string}
     * @memberof StoreIdPullpaymentsBody
     */
    bOLT11Expiration?: string;
    /**
     * Any payouts created for this pull payment will skip the approval phase upon creation
     * @type {boolean}
     * @memberof StoreIdPullpaymentsBody
     */
    autoApproveClaims?: boolean;
    /**
     * When this pull payment is effective. Already started if null or unspecified.
     * @type {number}
     * @memberof StoreIdPullpaymentsBody
     */
    startsAt?: number;
    /**
     * When this pull payment expires. Never expires if null or unspecified.
     * @type {number}
     * @memberof StoreIdPullpaymentsBody
     */
    expiresAt?: number;
    /**
     * The list of supported payout methods supported by this pull payment. Available options can be queried from the `StorePaymentMethods_GetStorePaymentMethods` endpoint. If `null`, all available payout methods will be supported.
     * @type {Array<string>}
     * @memberof StoreIdPullpaymentsBody
     */
    payoutMethods?: Array<string>;
}
/**
 * 
 * @export
 * @interface StoreRateConfiguration
 */
export interface StoreRateConfiguration {
    /**
     * A spread applies to the rate fetched in `%`. Must be `>= 0` or `<= 100`
     * @type {string}
     * @memberof StoreRateConfiguration
     */
    spread?: string;
    /**
     * If `isCustomerScript` is `false` affect use this source in the default's `effectiveScript`, if `isCustomerScript` is `false`, this setting is set to `null`. (See /misc/rate-sources for the available sources)
     * @type {string}
     * @memberof StoreRateConfiguration
     */
    preferredSource?: string;
    /**
     * Whether to use `preferredSource` with default script or a custom `effectiveScript`.
     * @type {boolean}
     * @memberof StoreRateConfiguration
     */
    isCustomScript?: boolean;
    /**
     * When `isCustomScript` is `true`, this represent the custom script used to calculate a currency pair's exchange rate. Else, it represent the script generated by the default rules and `preferredSource`.
     * @type {string}
     * @memberof StoreRateConfiguration
     */
    effectiveScript?: string;
}
/**
 * 
 * @export
 * @interface StoreRateResult
 */
export interface StoreRateResult {
    /**
     * Currency pair in the format of `BTC_USD`
     * @type {string}
     * @memberof StoreRateResult
     */
    currencyPair?: string;
    /**
     * Errors relating to this currency pair fetching based on your config
     * @type {Array<string>}
     * @memberof StoreRateResult
     */
    errors?: Array<string>;
    /**
     * the rate fetched based on the currency pair
     * @type {string}
     * @memberof StoreRateResult
     */
    rate?: string;
}
/**
 * 
 * @export
 * @interface StoreUserData
 */
export interface StoreUserData extends ApplicationUserData {
    /**
     * The id of the user (Deprecated, use `id` instead)
     * @type {string}
     * @memberof StoreUserData
     */
    userId?: string;
    /**
     * The role of the user. Default roles are `Owner`, `Manager`, `Employee` and `Guest` (Deprecated, use `storeRole` instead)
     * @type {string}
     * @memberof StoreUserData
     */
    role?: string;
    /**
     * The role of the user. Default roles are `Owner`, `Manager`, `Employee` and `Guest`
     * @type {string}
     * @memberof StoreUserData
     */
    storeRole?: string;
}
/**
 * 
 * @export
 */
export type StoreUserDataList = Array<StoreUserData>
/**
 * 
 * @export
 */
export type TimeSpan = number
/**
 * A span of times in days
 * @export
 * @interface TimeSpanDays
 */
export type TimeSpanDays = TimeSpan

/**
 * A span of times in minutes
 * @export
 * @interface TimeSpanMinutes
 */
export type TimeSpanMinutes = TimeSpan

/**
 * A span of times in seconds
 * @export
 * @interface TimeSpanSeconds
 */
export type TimeSpanSeconds = TimeSpan

/**
 * 
 * @export
 * @enum {string}
 */
export enum TransactionStatus {
    Confirmed = <any>'Confirmed',
    Unconfirmed = <any>'Unconfirmed'
}
/**
 * A unix timestamp in seconds
 * @export
 */
export type UnixTimestamp = number
/**
 * 
 * @export
 * @interface UpdateEmailSettings
 */
export interface UpdateEmailSettings extends EmailSettingsBase {
    /**
     * SMTP password. Keep null or empty to not update it.
     * @type {string}
     * @memberof UpdateEmailSettings
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface UpdateInvoiceRequest
 */
export interface UpdateInvoiceRequest {
    /**
     * 
     * @type {InvoiceMetadata}
     * @memberof UpdateInvoiceRequest
     */
    metadata?: InvoiceMetadata;
}
/**
 * 
 * @export
 * @interface UpdateLightningAutomatedTransferSettings
 */
export interface UpdateLightningAutomatedTransferSettings {
    /**
     * How often should the processor run
     * @type {TimeSpanSeconds}
     * @memberof UpdateLightningAutomatedTransferSettings
     */
    intervalSeconds?: TimeSpanSeconds;
    /**
     * How many failures should the processor tolerate before cancelling the payout
     * @type {number}
     * @memberof UpdateLightningAutomatedTransferSettings
     */
    cancelPayoutAfterFailures?: number;
    /**
     * Skip the interval when ane eligible payout has been approved (or created with pre-approval)
     * @type {boolean}
     * @memberof UpdateLightningAutomatedTransferSettings
     */
    processNewPayoutsInstantly?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateNotification
 */
export interface UpdateNotification {
    /**
     * Sets the notification as seen/unseen. If left null, sets it to the opposite value
     * @type {boolean}
     * @memberof UpdateNotification
     */
    seen?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateNotificationSettingsRequest
 */
export interface UpdateNotificationSettingsRequest {
    /**
     * List of the notification type identifiers, which should be disabled. Can also be a single item 'all'.
     * @type {Array<string>}
     * @memberof UpdateNotificationSettingsRequest
     */
    disabled?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateOnChainAutomatedTransferSettings
 */
export interface UpdateOnChainAutomatedTransferSettings {
    /**
     * How many blocks should the fee rate calculation target to confirm in. Set to 1 if not provided
     * @type {number}
     * @memberof UpdateOnChainAutomatedTransferSettings
     */
    feeTargetBlock?: number;
    /**
     * How often should the processor run
     * @type {TimeSpanSeconds}
     * @memberof UpdateOnChainAutomatedTransferSettings
     */
    intervalSeconds?: TimeSpanSeconds;
    /**
     * Only process payouts when this payout sum is reached.
     * @type {string}
     * @memberof UpdateOnChainAutomatedTransferSettings
     */
    threshold?: string;
    /**
     * Skip the interval when ane eligible payout has been approved (or created with pre-approval)
     * @type {boolean}
     * @memberof UpdateOnChainAutomatedTransferSettings
     */
    processNewPayoutsInstantly?: boolean;
}
/**
 * 
 * @export
 * @interface UpdatePaymentMethodConfig
 */
export interface UpdatePaymentMethodConfig {
    /**
     * Whether the payment method is enabled, leave null or unspecified to not change current setting
     * @type {boolean}
     * @memberof UpdatePaymentMethodConfig
     */
    enabled?: boolean;
    /**
     * The new payment method config, leave null or unspecified to not change current setting
     * @type {LNURLPayPaymentMethodBaseData | LightningNetworkPaymentMethodBaseData | OnChainPaymentMethodBaseData | Map | string}
     * @memberof UpdatePaymentMethodConfig
     */
    config?: LNURLPayPaymentMethodBaseData | LightningNetworkPaymentMethodBaseData | OnChainPaymentMethodBaseData | Map<string, unknown> | string;
}
/**
 * 
 * @export
 * @interface UpdateServerEmailSettings
 */
export interface UpdateServerEmailSettings extends UpdateEmailSettings {
    /**
     * Indicates if stores can use server email settings
     * @type {boolean}
     * @memberof UpdateServerEmailSettings
     */
    enableStoresToUseServerEmailSettings?: boolean;
}
/**
 * 
 * @export
 * @interface UsersMeBody
 */
export interface UsersMeBody {
    /**
     * The email of the user
     * @type {string}
     * @memberof UsersMeBody
     */
    email?: string;
    /**
     * The name of the user
     * @type {string}
     * @memberof UsersMeBody
     */
    name?: string;
    /**
     * The profile picture URL of the user
     * @type {string}
     * @memberof UsersMeBody
     */
    imageUrl?: string;
    /**
     * The current password of the user
     * @type {string}
     * @memberof UsersMeBody
     */
    currentPassword?: string;
    /**
     * The new password of the user
     * @type {string}
     * @memberof UsersMeBody
     */
    newPassword?: string;
}
/**
 * 
 * @export
 * @interface V1ApikeysBody
 */
export interface V1ApikeysBody {
    /**
     * The label of the new API Key
     * @type {string}
     * @memberof V1ApikeysBody
     */
    label?: string;
    /**
     * The permissions granted to this API Key (See API Key Authentication)
     * @type {Array<string>}
     * @memberof V1ApikeysBody
     */
    permissions?: Array<string>;
}
/**
 * 
 * @export
 * @interface V1FilesBody
 */
export interface V1FilesBody {
    /**
     * The profile picture
     * @type {Blob}
     * @memberof V1FilesBody
     */
    file?: Blob;
}
/**
 * 
 * @export
 * @interface V1UsersBody
 */
export interface V1UsersBody {
    /**
     * The email of the new user
     * @type {string}
     * @memberof V1UsersBody
     */
    email?: string;
    /**
     * The name of the new user
     * @type {string}
     * @memberof V1UsersBody
     */
    name?: string;
    /**
     * The profile picture URL of the new user
     * @type {string}
     * @memberof V1UsersBody
     */
    imageUrl?: string;
    /**
     * The password of the new user (if no password is set, an email will be sent to the user requiring him to set the password)
     * @type {string}
     * @memberof V1UsersBody
     */
    password?: string;
    /**
     * Make this user administrator (only if you have the `unrestricted` permission of a server administrator)
     * @type {boolean}
     * @memberof V1UsersBody
     */
    isAdministrator?: boolean;
}
/**
 * An array of validation errors of the request
 * @export
 */
export type ValidationProblemDetails = Array<ValidationProblemDetailsInner>
/**
 * A specific validation error on a json property
 * @export
 * @interface ValidationProblemDetailsInner
 */
export interface ValidationProblemDetailsInner {
    /**
     * The json path of the property which failed validation
     * @type {string}
     * @memberof ValidationProblemDetailsInner
     */
    path?: string;
    /**
     * User friendly error message about the validation
     * @type {string}
     * @memberof ValidationProblemDetailsInner
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface WalletPreviewBody
 */
export interface WalletPreviewBody {
    /**
     * The derivation scheme
     * @type {string}
     * @memberof WalletPreviewBody
     */
    derivationScheme?: string;
}
/**
 * 
 * @export
 * @interface WebhookData
 */
export interface WebhookData extends WebhookDataBase {
    /**
     * The id of the webhook
     * @type {string}
     * @memberof WebhookData
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface WebhookDataBase
 */
export interface WebhookDataBase {
    /**
     * Whether this webhook is enabled or not
     * @type {boolean}
     * @memberof WebhookDataBase
     */
    enabled?: boolean;
    /**
     * If true, BTCPay Server will retry to redeliver any failed delivery after 10 seconds, 1 minutes and up to 6 times after 10 minutes.
     * @type {boolean}
     * @memberof WebhookDataBase
     */
    automaticRedelivery?: boolean;
    /**
     * The endpoint where BTCPay Server will make the POST request with the webhook body
     * @type {string}
     * @memberof WebhookDataBase
     */
    url?: string;
    /**
     * 
     * @type {WebhookDataBaseAuthorizedEvents}
     * @memberof WebhookDataBase
     */
    authorizedEvents?: WebhookDataBaseAuthorizedEvents;
}
/**
 * Which event should be received by this endpoint
 * @export
 * @interface WebhookDataBaseAuthorizedEvents
 */
export interface WebhookDataBaseAuthorizedEvents {
    /**
     * If true, the endpoint will receive all events related to the store.
     * @type {boolean}
     * @memberof WebhookDataBaseAuthorizedEvents
     */
    everything?: boolean;
    /**
     * If `everything` is false, the specific events that the endpoint is interested in. Current events are: `InvoiceCreated`, `InvoiceReceivedPayment`, `InvoiceProcessing`, `InvoiceExpired`, `InvoiceSettled`, `InvoiceInvalid`.
     * @type {Array<string>}
     * @memberof WebhookDataBaseAuthorizedEvents
     */
    specificEvents?: Array<string>;
}
/**
 * 
 * @export
 * @interface WebhookDataCreate
 */
export interface WebhookDataCreate extends WebhookDataBase {
    /**
     * Must be used by the callback receiver to ensure the delivery comes from BTCPay Server. BTCPay Server includes the `BTCPay-Sig` HTTP header, whose format is `sha256=HMAC256(UTF8(webhook's secret), body)`. The pattern to authenticate the webhook is similar to [how to secure webhooks in Github](https://docs.github.com/webhooks/securing/). If left out, null, or empty, the secret will be auto-generated.
     * @type {string}
     * @memberof WebhookDataCreate
     */
    secret?: string;
}
/**
 * 
 * @export
 * @interface WebhookDataCreateResult
 */
export interface WebhookDataCreateResult extends WebhookData {
    /**
     * Must be used by the callback receiver to ensure the delivery comes from BTCPay Server. BTCPay Server includes the `BTCPay-Sig` HTTP header, whose format is `sha256=HMAC256(UTF8(webhook's secret), body)`. The pattern to authenticate the webhook is similar to [how to secure webhooks in Github](https://docs.github.com/webhooks/securing/). Value of the auto-generated or custom secret.
     * @type {string}
     * @memberof WebhookDataCreateResult
     */
    secret?: string;
}
/**
 * 
 * @export
 */
export type WebhookDataList = Array<WebhookData>
/**
 * 
 * @export
 * @interface WebhookDataUpdate
 */
export interface WebhookDataUpdate extends WebhookDataBase {
    /**
     * Must be used by the callback receiver to ensure the delivery comes from BTCPay Server. BTCPay Server includes the `BTCPay-Sig` HTTP header, whose format is `sha256=HMAC256(UTF8(webhook's secret), body)`. The pattern to authenticate the webhook is similar to [how to secure webhooks in Github](https://docs.github.com/webhooks/securing/). If left out, null, or empty, the secret will not be changed.
     * @type {string}
     * @memberof WebhookDataUpdate
     */
    secret?: string;
}
/**
 * 
 * @export
 * @interface WebhookDeliveryData
 */
export interface WebhookDeliveryData {
    /**
     * The id of the delivery
     * @type {string}
     * @memberof WebhookDeliveryData
     */
    id?: string;
    /**
     * Timestamp of when the delivery got broadcasted
     * @type {UnixTimestamp}
     * @memberof WebhookDeliveryData
     */
    timestamp?: UnixTimestamp;
    /**
     * HTTP code received by the remote service, if any.
     * @type {number}
     * @memberof WebhookDeliveryData
     */
    httpCode?: number;
    /**
     * User friendly error message, if any.
     * @type {string}
     * @memberof WebhookDeliveryData
     */
    errorMessage?: string;
    /**
     * Whether the delivery failed or not (possible values are: `Failed`, `HttpError`, `HttpSuccess`)
     * @type {string}
     * @memberof WebhookDeliveryData
     */
    status?: string;
}
/**
 * 
 * @export
 */
export type WebhookDeliveryList = Array<WebhookDeliveryData>
/**
 * 
 * @export
 * @interface WebhookEvent
 */
export interface WebhookEvent {
    /**
     * The delivery id of the webhook
     * @type {string}
     * @memberof WebhookEvent
     */
    deliveryId?: string;
    /**
     * The id of the webhook
     * @type {string}
     * @memberof WebhookEvent
     */
    webhookId?: string;
    /**
     * If this delivery is a redelivery, the is the delivery id of the original delivery.
     * @type {string}
     * @memberof WebhookEvent
     */
    originalDeliveryId?: string;
    /**
     * True if this delivery is a redelivery
     * @type {boolean}
     * @memberof WebhookEvent
     */
    isRedelivery?: boolean;
    /**
     * The type of this event, current available are `InvoiceCreated`, `InvoiceReceivedPayment`, `InvoiceProcessing`, `InvoiceExpired`, `InvoiceSettled`, `InvoiceInvalid`, and `InvoicePaymentSettled`.
     * @type {string}
     * @memberof WebhookEvent
     */
    type?: string;
    /**
     * The timestamp when this delivery has been created
     * @type {UnixTimestamp}
     * @memberof WebhookEvent
     */
    timestamp?: UnixTimestamp;
}
/**
 * 
 * @export
 * @interface WebhookInvoiceEvent
 */
export interface WebhookInvoiceEvent extends WebhookEvent {
    /**
     * The store id of the invoice's event
     * @type {StoreId}
     * @memberof WebhookInvoiceEvent
     */
    storeId?: StoreId;
    /**
     * The invoice id of the invoice's event
     * @type {string}
     * @memberof WebhookInvoiceEvent
     */
    invoiceId?: string;
    /**
     * User-supplied metadata added to the invoice at the time of its creation
     * @type {any}
     * @memberof WebhookInvoiceEvent
     */
    metadata?: any;
}
/**
 * Callback sent if the `type` is `InvoiceExpired`
 * @export
 * @interface WebhookInvoiceExpiredEvent
 */
export interface WebhookInvoiceExpiredEvent extends WebhookInvoiceEvent {
    /**
     * Whether the invoice received some payments before being expired.
     * @type {boolean}
     * @memberof WebhookInvoiceExpiredEvent
     */
    partiallyPaid?: boolean;
}
/**
 * Callback sent if the `type` is `InvoiceInvalid`
 * @export
 * @interface WebhookInvoiceInvalidEvent
 */
export interface WebhookInvoiceInvalidEvent extends WebhookInvoiceEvent {
    /**
     * Whether the invoice have been manually marked as confirmed. If false, this invoice has received payments which could not confirm in time.
     * @type {boolean}
     * @memberof WebhookInvoiceInvalidEvent
     */
    manuallyMarked?: boolean;
}
/**
 * Callback sent if the `type` is `InvoicePaymentSettled`
 * @export
 * @interface WebhookInvoicePaymentSettledEvent
 */
export interface WebhookInvoicePaymentSettledEvent extends WebhookInvoiceReceivedPaymentEvent {
}
/**
 * Callback sent if the `type` is `InvoiceProcessing`
 * @export
 * @interface WebhookInvoiceProcessingEvent
 */
export interface WebhookInvoiceProcessingEvent extends WebhookInvoiceEvent {
    /**
     * Whether this invoice has received more money than expected
     * @type {boolean}
     * @memberof WebhookInvoiceProcessingEvent
     */
    overPaid?: boolean;
}
/**
 * Callback sent if the `type` is `InvoiceReceivedPayment`
 * @export
 * @interface WebhookInvoiceReceivedPaymentEvent
 */
export interface WebhookInvoiceReceivedPaymentEvent extends WebhookInvoiceEvent {
    /**
     * Whether this payment has been sent after expiration of the invoice
     * @type {boolean}
     * @memberof WebhookInvoiceReceivedPaymentEvent
     */
    afterExpiration?: boolean;
    /**
     * What payment method was used for this payment
     * @type {PaymentMethodId}
     * @memberof WebhookInvoiceReceivedPaymentEvent
     */
    paymentMethodId?: PaymentMethodId;
    /**
     * Details about the payment
     * @type {Payment}
     * @memberof WebhookInvoiceReceivedPaymentEvent
     */
    payment?: Payment;
}
/**
 * Callback sent if the `type` is `InvoiceSettled`
 * @export
 * @interface WebhookInvoiceSettledEvent
 */
export interface WebhookInvoiceSettledEvent extends WebhookInvoiceEvent {
    /**
     * Whether the invoice have been manually marked as confirmed
     * @type {boolean}
     * @memberof WebhookInvoiceSettledEvent
     */
    manuallyMarked?: boolean;
    /**
     * Whether this invoice has received more money than expected
     * @type {boolean}
     * @memberof WebhookInvoiceSettledEvent
     */
    overPaid?: boolean;
}
/**
 * APIKeysApi - fetch parameter creator
 * @export
 */
export const APIKeysApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new API Key
         * @summary Create a new API Key
         * @param {V1ApikeysBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysCreateApiKey(body?: V1ApikeysBody, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/api-keys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ApikeysBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new API Key for a user
         * @summary Create a new API Key for a user
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {IdOrEmailApikeysBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysCreateUserApiKey(idOrEmail: string, body?: IdOrEmailApikeysBody, options: any = {}): FetchArgs {
            // verify required parameter 'idOrEmail' is not null or undefined
            if (idOrEmail === null || idOrEmail === undefined) {
                throw new RequiredError('idOrEmail', 'Required parameter idOrEmail was null or undefined when calling apiKeysCreateUserApiKey.');
            }
            const localVarPath = `/api/v1/users/{idOrEmail}/api-keys`
                .replace(`{${"idOrEmail"}}`, encodeURIComponent(idOrEmail));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IdOrEmailApikeysBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke the current API key so that it cannot be used anymore
         * @summary Revoke an API Key
         * @param {string} apikey The API Key to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysDeleteApiKey(apikey: string, options: any = {}): FetchArgs {
            // verify required parameter 'apikey' is not null or undefined
            if (apikey === null || apikey === undefined) {
                throw new RequiredError('apikey', 'Required parameter apikey was null or undefined when calling apiKeysDeleteApiKey.');
            }
            const localVarPath = `/api/v1/api-keys/{apikey}`
                .replace(`{${"apikey"}}`, encodeURIComponent(apikey));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke the current API key so that it cannot be used anymore
         * @summary Revoke the current API Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysDeleteCurrentApiKey(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/api-keys/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke the API key of a target user so that it cannot be used anymore
         * @summary Revoke an API Key of target user
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {string} apikey The API Key to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysDeleteUserApiKey(idOrEmail: string, apikey: string, options: any = {}): FetchArgs {
            // verify required parameter 'idOrEmail' is not null or undefined
            if (idOrEmail === null || idOrEmail === undefined) {
                throw new RequiredError('idOrEmail', 'Required parameter idOrEmail was null or undefined when calling apiKeysDeleteUserApiKey.');
            }
            // verify required parameter 'apikey' is not null or undefined
            if (apikey === null || apikey === undefined) {
                throw new RequiredError('apikey', 'Required parameter apikey was null or undefined when calling apiKeysDeleteUserApiKey.');
            }
            const localVarPath = `/api/v1/users/{idOrEmail}/api-keys/{apikey}`
                .replace(`{${"idOrEmail"}}`, encodeURIComponent((idOrEmail)))
                .replace(`{${"apikey"}}`, encodeURIComponent((apikey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the current API key
         * @summary Get the current API Key information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysGetCurrentApiKey(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/api-keys/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeysApi - functional programming interface
 * @export
 */
export const APIKeysApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Create a new API Key
         * @summary Create a new API Key
         * @param {V1ApikeysBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysCreateApiKey(body?: V1ApikeysBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiKeyData> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).apiKeysCreateApiKey(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new API Key for a user
         * @summary Create a new API Key for a user
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {IdOrEmailApikeysBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysCreateUserApiKey(idOrEmail: string, body?: IdOrEmailApikeysBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiKeyData> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).apiKeysCreateUserApiKey(idOrEmail, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Revoke the current API key so that it cannot be used anymore
         * @summary Revoke an API Key
         * @param {string} apikey The API Key to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysDeleteApiKey(apikey: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).apiKeysDeleteApiKey(apikey, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Revoke the current API key so that it cannot be used anymore
         * @summary Revoke the current API Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysDeleteCurrentApiKey(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiKeyData> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).apiKeysDeleteCurrentApiKey(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Revoke the API key of a target user so that it cannot be used anymore
         * @summary Revoke an API Key of target user
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {string} apikey The API Key to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysDeleteUserApiKey(idOrEmail: string, apikey: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).apiKeysDeleteUserApiKey(idOrEmail, apikey, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the current API key
         * @summary Get the current API Key information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysGetCurrentApiKey(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiKeyData> {
            const localVarFetchArgs = APIKeysApiFetchParamCreator(configuration).apiKeysGetCurrentApiKey(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * APIKeysApi - factory interface
 * @export
 */
export const APIKeysApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new API Key
         * @summary Create a new API Key
         * @param {V1ApikeysBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysCreateApiKey(body?: V1ApikeysBody, options?: any) {
            return APIKeysApiFp(configuration).apiKeysCreateApiKey(body, options)(fetch, basePath);
        },
        /**
         * Create a new API Key for a user
         * @summary Create a new API Key for a user
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {IdOrEmailApikeysBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysCreateUserApiKey(idOrEmail: string, body?: IdOrEmailApikeysBody, options?: any) {
            return APIKeysApiFp(configuration).apiKeysCreateUserApiKey(idOrEmail, body, options)(fetch, basePath);
        },
        /**
         * Revoke the current API key so that it cannot be used anymore
         * @summary Revoke an API Key
         * @param {string} apikey The API Key to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysDeleteApiKey(apikey: string, options?: any) {
            return APIKeysApiFp(configuration).apiKeysDeleteApiKey(apikey, options)(fetch, basePath);
        },
        /**
         * Revoke the current API key so that it cannot be used anymore
         * @summary Revoke the current API Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysDeleteCurrentApiKey(options?: any) {
            return APIKeysApiFp(configuration).apiKeysDeleteCurrentApiKey(options)(fetch, basePath);
        },
        /**
         * Revoke the API key of a target user so that it cannot be used anymore
         * @summary Revoke an API Key of target user
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {string} apikey The API Key to revoke
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysDeleteUserApiKey(idOrEmail: string, apikey: string, options?: any) {
            return APIKeysApiFp(configuration).apiKeysDeleteUserApiKey(idOrEmail, apikey, options)(fetch, basePath);
        },
        /**
         * View information about the current API key
         * @summary Get the current API Key information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysGetCurrentApiKey(options?: any) {
            return APIKeysApiFp(configuration).apiKeysGetCurrentApiKey(options)(fetch, basePath);
        },
    };
};

/**
 * APIKeysApi - object-oriented interface
 * @export
 * @class APIKeysApi
 * @extends {BaseAPI}
 */
export class APIKeysApi extends BaseAPI {
    /**
     * Create a new API Key
     * @summary Create a new API Key
     * @param {V1ApikeysBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysCreateApiKey(body?: V1ApikeysBody, options?: any) {
        return APIKeysApiFp(this.configuration).apiKeysCreateApiKey(body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new API Key for a user
     * @summary Create a new API Key for a user
     * @param {string} idOrEmail The user&#x27;s id or email
     * @param {IdOrEmailApikeysBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysCreateUserApiKey(idOrEmail: string, body?: IdOrEmailApikeysBody, options?: any) {
        return APIKeysApiFp(this.configuration).apiKeysCreateUserApiKey(idOrEmail, body, options)(this.fetch, this.basePath);
    }

    /**
     * Revoke the current API key so that it cannot be used anymore
     * @summary Revoke an API Key
     * @param {string} apikey The API Key to revoke
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysDeleteApiKey(apikey: string, options?: any) {
        return APIKeysApiFp(this.configuration).apiKeysDeleteApiKey(apikey, options)(this.fetch, this.basePath);
    }

    /**
     * Revoke the current API key so that it cannot be used anymore
     * @summary Revoke the current API Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysDeleteCurrentApiKey(options?: any) {
        return APIKeysApiFp(this.configuration).apiKeysDeleteCurrentApiKey(options)(this.fetch, this.basePath);
    }

    /**
     * Revoke the API key of a target user so that it cannot be used anymore
     * @summary Revoke an API Key of target user
     * @param {string} idOrEmail The user&#x27;s id or email
     * @param {string} apikey The API Key to revoke
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysDeleteUserApiKey(idOrEmail: string, apikey: string, options?: any) {
        return APIKeysApiFp(this.configuration).apiKeysDeleteUserApiKey(idOrEmail, apikey, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the current API key
     * @summary Get the current API Key information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysGetCurrentApiKey(options?: any) {
        return APIKeysApiFp(this.configuration).apiKeysGetCurrentApiKey(options)(this.fetch, this.basePath);
    }

}
/**
 * AppsApi - fetch parameter creator
 * @export
 */
export const AppsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the app item image
         * @summary Deletes the app item image
         * @param {string} appId App ID
         * @param {string} fileId The file ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDeleteAppItemImage(appId: string, fileId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId', 'Required parameter appId was null or undefined when calling appDeleteAppItemImage.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId', 'Required parameter fileId was null or undefined when calling appDeleteAppItemImage.');
            }
            const localVarPath = `/api/v1/apps/{appId}/image/{fileId}`
                .replace(`{${"appId"}}`, encodeURIComponent((appId)))
                .replace(`{${"fileId"}}`, encodeURIComponent((fileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Crowdfund app
         * @param {CrowdfundAppRequest} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsCreateCrowdfundApp(body: CrowdfundAppRequest, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling appsCreateCrowdfundApp.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling appsCreateCrowdfundApp.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/apps/crowdfund`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CrowdfundAppRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Point of Sale app allows accepting payments for items in a virtual store
         * @summary Create a new Point of Sale app
         * @param {PointOfSaleAppRequest} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsCreatePointOfSaleApp(body: PointOfSaleAppRequest, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling appsCreatePointOfSaleApp.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling appsCreatePointOfSaleApp.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/apps/pos`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PointOfSaleAppRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes apps with specified ID
         * @summary Delete app
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsDeleteApp(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId', 'Required parameter appId was null or undefined when calling appsDeleteApp.');
            }
            const localVarPath = `/api/v1/apps/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent((appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns basic app data for all apps for all stores
         * @summary Get basic app data for all apps for all stores for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetAllApps(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/apps`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns basic app data for all apps for a store
         * @summary Get basic app data for all apps for a store
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetAllAppsForStore(storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling appsGetAllAppsForStore.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/apps`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns basic app data shared between all types of apps
         * @summary Get basic app data
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetApp(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId', 'Required parameter appId was null or undefined when calling appsGetApp.');
            }
            const localVarPath = `/api/v1/apps/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent((appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns sales statistics for the app
         * @summary Get app sales statistics
         * @param {string} appId App ID
         * @param {number} [numberOfDays] How many of the last days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetAppSales(appId: string, numberOfDays?: number, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId', 'Required parameter appId was null or undefined when calling appsGetAppSales.');
            }
            const localVarPath = `/api/v1/apps/{appId}/sales`
                .replace(`{${"appId"}}`, encodeURIComponent((appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (numberOfDays !== undefined) {
                localVarQueryParameter['numberOfDays'] = numberOfDays;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns top items statistics for the app
         * @summary Get app top items statistics
         * @param {string} appId App ID
         * @param {number} [count] How many of the items
         * @param {number} [offset] Offset for paging
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetAppTopItems(appId: string, count?: number, offset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId', 'Required parameter appId was null or undefined when calling appsGetAppTopItems.');
            }
            const localVarPath = `/api/v1/apps/{appId}/top-items`
                .replace(`{${"appId"}}`, encodeURIComponent((appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns crowdfund app data
         * @summary Get crowdfund app data
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetCrowdfundApp(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId', 'Required parameter appId was null or undefined when calling appsGetCrowdfundApp.');
            }
            const localVarPath = `/api/v1/apps/crowdfund/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent((appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns POS app data
         * @summary Get Point of Sale app data
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetPointOfSaleApp(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId', 'Required parameter appId was null or undefined when calling appsGetPointOfSaleApp.');
            }
            const localVarPath = `/api/v1/apps/pos/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent((appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint for updating the properties of a POS app
         * @summary Update a Point of Sale app
         * @param {PointOfSaleAppRequest} body 
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsPutPointOfSaleApp(body: PointOfSaleAppRequest, appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling appsPutPointOfSaleApp.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId', 'Required parameter appId was null or undefined when calling appsPutPointOfSaleApp.');
            }
            const localVarPath = `/api/v1/apps/pos/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent((appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PointOfSaleAppRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads an image for a app item
         * @summary Uploads an image for a app item
         * @param {string} appId App ID
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsUploadAppItemImage(appId: string, file?: Blob, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId', 'Required parameter appId was null or undefined when calling appsUploadAppItemImage.');
            }
            const localVarPath = `/api/v1/apps/{appId}/image`
                .replace(`{${"appId"}}`, encodeURIComponent((appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppsApi - functional programming interface
 * @export
 */
export const AppsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the app item image
         * @summary Deletes the app item image
         * @param {string} appId App ID
         * @param {string} fileId The file ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDeleteAppItemImage(appId: string, fileId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).appDeleteAppItemImage(appId, fileId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new Crowdfund app
         * @param {CrowdfundAppRequest} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsCreateCrowdfundApp(body: CrowdfundAppRequest, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CrowdfundAppData> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).appsCreateCrowdfundApp(body, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Point of Sale app allows accepting payments for items in a virtual store
         * @summary Create a new Point of Sale app
         * @param {PointOfSaleAppRequest} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsCreatePointOfSaleApp(body: PointOfSaleAppRequest, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PointOfSaleAppData> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).appsCreatePointOfSaleApp(body, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes apps with specified ID
         * @summary Delete app
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsDeleteApp(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).appsDeleteApp(appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns basic app data for all apps for all stores
         * @summary Get basic app data for all apps for all stores for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetAllApps(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AppBaseData>> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).appsGetAllApps(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns basic app data for all apps for a store
         * @summary Get basic app data for all apps for a store
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetAllAppsForStore(storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AppBaseData>> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).appsGetAllAppsForStore(storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns basic app data shared between all types of apps
         * @summary Get basic app data
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetApp(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppBaseData> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).appsGetApp(appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns sales statistics for the app
         * @summary Get app sales statistics
         * @param {string} appId App ID
         * @param {number} [numberOfDays] How many of the last days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetAppSales(appId: string, numberOfDays?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppSalesStats> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).appsGetAppSales(appId, numberOfDays, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns top items statistics for the app
         * @summary Get app top items statistics
         * @param {string} appId App ID
         * @param {number} [count] How many of the items
         * @param {number} [offset] Offset for paging
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetAppTopItems(appId: string, count?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AppItemStats>> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).appsGetAppTopItems(appId, count, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns crowdfund app data
         * @summary Get crowdfund app data
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetCrowdfundApp(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CrowdfundAppData> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).appsGetCrowdfundApp(appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns POS app data
         * @summary Get Point of Sale app data
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetPointOfSaleApp(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PointOfSaleAppData> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).appsGetPointOfSaleApp(appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Use this endpoint for updating the properties of a POS app
         * @summary Update a Point of Sale app
         * @param {PointOfSaleAppRequest} body 
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsPutPointOfSaleApp(body: PointOfSaleAppRequest, appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PointOfSaleAppData> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).appsPutPointOfSaleApp(body, appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Uploads an image for a app item
         * @summary Uploads an image for a app item
         * @param {string} appId App ID
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsUploadAppItemImage(appId: string, file?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FileData> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).appsUploadAppItemImage(appId, file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AppsApi - factory interface
 * @export
 */
export const AppsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes the app item image
         * @summary Deletes the app item image
         * @param {string} appId App ID
         * @param {string} fileId The file ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appDeleteAppItemImage(appId: string, fileId: string, options?: any) {
            return AppsApiFp(configuration).appDeleteAppItemImage(appId, fileId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new Crowdfund app
         * @param {CrowdfundAppRequest} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsCreateCrowdfundApp(body: CrowdfundAppRequest, storeId: StoreId, options?: any) {
            return AppsApiFp(configuration).appsCreateCrowdfundApp(body, storeId, options)(fetch, basePath);
        },
        /**
         * Point of Sale app allows accepting payments for items in a virtual store
         * @summary Create a new Point of Sale app
         * @param {PointOfSaleAppRequest} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsCreatePointOfSaleApp(body: PointOfSaleAppRequest, storeId: StoreId, options?: any) {
            return AppsApiFp(configuration).appsCreatePointOfSaleApp(body, storeId, options)(fetch, basePath);
        },
        /**
         * Deletes apps with specified ID
         * @summary Delete app
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsDeleteApp(appId: string, options?: any) {
            return AppsApiFp(configuration).appsDeleteApp(appId, options)(fetch, basePath);
        },
        /**
         * Returns basic app data for all apps for all stores
         * @summary Get basic app data for all apps for all stores for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetAllApps(options?: any) {
            return AppsApiFp(configuration).appsGetAllApps(options)(fetch, basePath);
        },
        /**
         * Returns basic app data for all apps for a store
         * @summary Get basic app data for all apps for a store
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetAllAppsForStore(storeId: StoreId, options?: any) {
            return AppsApiFp(configuration).appsGetAllAppsForStore(storeId, options)(fetch, basePath);
        },
        /**
         * Returns basic app data shared between all types of apps
         * @summary Get basic app data
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetApp(appId: string, options?: any) {
            return AppsApiFp(configuration).appsGetApp(appId, options)(fetch, basePath);
        },
        /**
         * Returns sales statistics for the app
         * @summary Get app sales statistics
         * @param {string} appId App ID
         * @param {number} [numberOfDays] How many of the last days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetAppSales(appId: string, numberOfDays?: number, options?: any) {
            return AppsApiFp(configuration).appsGetAppSales(appId, numberOfDays, options)(fetch, basePath);
        },
        /**
         * Returns top items statistics for the app
         * @summary Get app top items statistics
         * @param {string} appId App ID
         * @param {number} [count] How many of the items
         * @param {number} [offset] Offset for paging
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetAppTopItems(appId: string, count?: number, offset?: number, options?: any) {
            return AppsApiFp(configuration).appsGetAppTopItems(appId, count, offset, options)(fetch, basePath);
        },
        /**
         * Returns crowdfund app data
         * @summary Get crowdfund app data
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetCrowdfundApp(appId: string, options?: any) {
            return AppsApiFp(configuration).appsGetCrowdfundApp(appId, options)(fetch, basePath);
        },
        /**
         * Returns POS app data
         * @summary Get Point of Sale app data
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetPointOfSaleApp(appId: string, options?: any) {
            return AppsApiFp(configuration).appsGetPointOfSaleApp(appId, options)(fetch, basePath);
        },
        /**
         * Use this endpoint for updating the properties of a POS app
         * @summary Update a Point of Sale app
         * @param {PointOfSaleAppRequest} body 
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsPutPointOfSaleApp(body: PointOfSaleAppRequest, appId: string, options?: any) {
            return AppsApiFp(configuration).appsPutPointOfSaleApp(body, appId, options)(fetch, basePath);
        },
        /**
         * Uploads an image for a app item
         * @summary Uploads an image for a app item
         * @param {string} appId App ID
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsUploadAppItemImage(appId: string, file?: Blob, options?: any) {
            return AppsApiFp(configuration).appsUploadAppItemImage(appId, file, options)(fetch, basePath);
        },
    };
};

/**
 * AppsApi - object-oriented interface
 * @export
 * @class AppsApi
 * @extends {BaseAPI}
 */
export class AppsApi extends BaseAPI {
    /**
     * Deletes the app item image
     * @summary Deletes the app item image
     * @param {string} appId App ID
     * @param {string} fileId The file ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appDeleteAppItemImage(appId: string, fileId: string, options?: any) {
        return AppsApiFp(this.configuration).appDeleteAppItemImage(appId, fileId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new Crowdfund app
     * @param {CrowdfundAppRequest} body 
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsCreateCrowdfundApp(body: CrowdfundAppRequest, storeId: StoreId, options?: any) {
        return AppsApiFp(this.configuration).appsCreateCrowdfundApp(body, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Point of Sale app allows accepting payments for items in a virtual store
     * @summary Create a new Point of Sale app
     * @param {PointOfSaleAppRequest} body 
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsCreatePointOfSaleApp(body: PointOfSaleAppRequest, storeId: StoreId, options?: any) {
        return AppsApiFp(this.configuration).appsCreatePointOfSaleApp(body, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes apps with specified ID
     * @summary Delete app
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsDeleteApp(appId: string, options?: any) {
        return AppsApiFp(this.configuration).appsDeleteApp(appId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns basic app data for all apps for all stores
     * @summary Get basic app data for all apps for all stores for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsGetAllApps(options?: any) {
        return AppsApiFp(this.configuration).appsGetAllApps(options)(this.fetch, this.basePath);
    }

    /**
     * Returns basic app data for all apps for a store
     * @summary Get basic app data for all apps for a store
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsGetAllAppsForStore(storeId: StoreId, options?: any) {
        return AppsApiFp(this.configuration).appsGetAllAppsForStore(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns basic app data shared between all types of apps
     * @summary Get basic app data
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsGetApp(appId: string, options?: any) {
        return AppsApiFp(this.configuration).appsGetApp(appId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns sales statistics for the app
     * @summary Get app sales statistics
     * @param {string} appId App ID
     * @param {number} [numberOfDays] How many of the last days
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsGetAppSales(appId: string, numberOfDays?: number, options?: any) {
        return AppsApiFp(this.configuration).appsGetAppSales(appId, numberOfDays, options)(this.fetch, this.basePath);
    }

    /**
     * Returns top items statistics for the app
     * @summary Get app top items statistics
     * @param {string} appId App ID
     * @param {number} [count] How many of the items
     * @param {number} [offset] Offset for paging
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsGetAppTopItems(appId: string, count?: number, offset?: number, options?: any) {
        return AppsApiFp(this.configuration).appsGetAppTopItems(appId, count, offset, options)(this.fetch, this.basePath);
    }

    /**
     * Returns crowdfund app data
     * @summary Get crowdfund app data
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsGetCrowdfundApp(appId: string, options?: any) {
        return AppsApiFp(this.configuration).appsGetCrowdfundApp(appId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns POS app data
     * @summary Get Point of Sale app data
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsGetPointOfSaleApp(appId: string, options?: any) {
        return AppsApiFp(this.configuration).appsGetPointOfSaleApp(appId, options)(this.fetch, this.basePath);
    }

    /**
     * Use this endpoint for updating the properties of a POS app
     * @summary Update a Point of Sale app
     * @param {PointOfSaleAppRequest} body 
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsPutPointOfSaleApp(body: PointOfSaleAppRequest, appId: string, options?: any) {
        return AppsApiFp(this.configuration).appsPutPointOfSaleApp(body, appId, options)(this.fetch, this.basePath);
    }

    /**
     * Uploads an image for a app item
     * @summary Uploads an image for a app item
     * @param {string} appId App ID
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsUploadAppItemImage(appId: string, file?: Blob, options?: any) {
        return AppsApiFp(this.configuration).appsUploadAppItemImage(appId, file, options)(this.fetch, this.basePath);
    }

}
/**
 * AuthorizationApi - fetch parameter creator
 * @export
 */
export const AuthorizationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Redirect the browser to this endpoint to request the user to generate an api-key with specific permissions
         * @summary Authorize User
         * @param {Array<string>} [permissions] The permissions to request. (See API Key authentication)
         * @param {boolean} [strict] If permissions are specified, and strict is set to false, it will allow the user to reject some of permissions the application is requesting.
         * @param {string} [applicationIdentifier] If specified, BTCPay Server will check if there is an existing API key associated with the user that also has this application identifier, redirect host AND the permissions required match(takes selectiveStores and strict into account). &#x60;applicationIdentifier&#x60; is ignored if redirect is not specified.
         * @param {boolean} [selectiveStores] If the application is requesting the CanModifyStoreSettings permission and selectiveStores is set to true, this allows the user to only grant permissions to selected stores under the user&#x27;s control.
         * @param {string} [applicationName] The name of your application
         * @param {string} [redirect] The url to redirect to after the user consents, with the query parameters appended to it: permissions, user-id, api-key. If not specified, user is redirected to their API Key list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysAuthorize(permissions?: Array<string>, strict?: boolean, applicationIdentifier?: string, selectiveStores?: boolean, applicationName?: string, redirect?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api-keys/authorize`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (permissions) {
                localVarQueryParameter['permissions'] = permissions;
            }

            if (strict !== undefined) {
                localVarQueryParameter['strict'] = strict;
            }

            if (applicationIdentifier !== undefined) {
                localVarQueryParameter['applicationIdentifier'] = applicationIdentifier;
            }

            if (selectiveStores !== undefined) {
                localVarQueryParameter['selectiveStores'] = selectiveStores;
            }

            if (applicationName !== undefined) {
                localVarQueryParameter['applicationName'] = applicationName;
            }

            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizationApi - functional programming interface
 * @export
 */
export const AuthorizationApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Redirect the browser to this endpoint to request the user to generate an api-key with specific permissions
         * @summary Authorize User
         * @param {Array<string>} [permissions] The permissions to request. (See API Key authentication)
         * @param {boolean} [strict] If permissions are specified, and strict is set to false, it will allow the user to reject some of permissions the application is requesting.
         * @param {string} [applicationIdentifier] If specified, BTCPay Server will check if there is an existing API key associated with the user that also has this application identifier, redirect host AND the permissions required match(takes selectiveStores and strict into account). &#x60;applicationIdentifier&#x60; is ignored if redirect is not specified.
         * @param {boolean} [selectiveStores] If the application is requesting the CanModifyStoreSettings permission and selectiveStores is set to true, this allows the user to only grant permissions to selected stores under the user&#x27;s control.
         * @param {string} [applicationName] The name of your application
         * @param {string} [redirect] The url to redirect to after the user consents, with the query parameters appended to it: permissions, user-id, api-key. If not specified, user is redirected to their API Key list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysAuthorize(permissions?: Array<string>, strict?: boolean, applicationIdentifier?: string, selectiveStores?: boolean, applicationName?: string, redirect?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthorizationApiFetchParamCreator(configuration).apiKeysAuthorize(permissions, strict, applicationIdentifier, selectiveStores, applicationName, redirect, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthorizationApi - factory interface
 * @export
 */
export const AuthorizationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Redirect the browser to this endpoint to request the user to generate an api-key with specific permissions
         * @summary Authorize User
         * @param {Array<string>} [permissions] The permissions to request. (See API Key authentication)
         * @param {boolean} [strict] If permissions are specified, and strict is set to false, it will allow the user to reject some of permissions the application is requesting.
         * @param {string} [applicationIdentifier] If specified, BTCPay Server will check if there is an existing API key associated with the user that also has this application identifier, redirect host AND the permissions required match(takes selectiveStores and strict into account). &#x60;applicationIdentifier&#x60; is ignored if redirect is not specified.
         * @param {boolean} [selectiveStores] If the application is requesting the CanModifyStoreSettings permission and selectiveStores is set to true, this allows the user to only grant permissions to selected stores under the user&#x27;s control.
         * @param {string} [applicationName] The name of your application
         * @param {string} [redirect] The url to redirect to after the user consents, with the query parameters appended to it: permissions, user-id, api-key. If not specified, user is redirected to their API Key list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysAuthorize(permissions?: Array<string>, strict?: boolean, applicationIdentifier?: string, selectiveStores?: boolean, applicationName?: string, redirect?: string, options?: any) {
            return AuthorizationApiFp(configuration).apiKeysAuthorize(permissions, strict, applicationIdentifier, selectiveStores, applicationName, redirect, options)(fetch, basePath);
        },
    };
};

/**
 * AuthorizationApi - object-oriented interface
 * @export
 * @class AuthorizationApi
 * @extends {BaseAPI}
 */
export class AuthorizationApi extends BaseAPI {
    /**
     * Redirect the browser to this endpoint to request the user to generate an api-key with specific permissions
     * @summary Authorize User
     * @param {Array<string>} [permissions] The permissions to request. (See API Key authentication)
     * @param {boolean} [strict] If permissions are specified, and strict is set to false, it will allow the user to reject some of permissions the application is requesting.
     * @param {string} [applicationIdentifier] If specified, BTCPay Server will check if there is an existing API key associated with the user that also has this application identifier, redirect host AND the permissions required match(takes selectiveStores and strict into account). &#x60;applicationIdentifier&#x60; is ignored if redirect is not specified.
     * @param {boolean} [selectiveStores] If the application is requesting the CanModifyStoreSettings permission and selectiveStores is set to true, this allows the user to only grant permissions to selected stores under the user&#x27;s control.
     * @param {string} [applicationName] The name of your application
     * @param {string} [redirect] The url to redirect to after the user consents, with the query parameters appended to it: permissions, user-id, api-key. If not specified, user is redirected to their API Key list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public apiKeysAuthorize(permissions?: Array<string>, strict?: boolean, applicationIdentifier?: string, selectiveStores?: boolean, applicationName?: string, redirect?: string, options?: any) {
        return AuthorizationApiFp(this.configuration).apiKeysAuthorize(permissions, strict, applicationIdentifier, selectiveStores, applicationName, redirect, options)(this.fetch, this.basePath);
    }

}
/**
 * CrowdfundApi - fetch parameter creator
 * @export
 */
export const CrowdfundApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Crowdfund app
         * @param {CrowdfundAppRequest} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsCreateCrowdfundApp(body: CrowdfundAppRequest, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling appsCreateCrowdfundApp.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling appsCreateCrowdfundApp.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/apps/crowdfund`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CrowdfundAppRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns crowdfund app data
         * @summary Get crowdfund app data
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetCrowdfundApp(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId', 'Required parameter appId was null or undefined when calling appsGetCrowdfundApp.');
            }
            const localVarPath = `/api/v1/apps/crowdfund/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent((appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CrowdfundApi - functional programming interface
 * @export
 */
export const CrowdfundApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Crowdfund app
         * @param {CrowdfundAppRequest} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsCreateCrowdfundApp(body: CrowdfundAppRequest, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CrowdfundAppData> {
            const localVarFetchArgs = CrowdfundApiFetchParamCreator(configuration).appsCreateCrowdfundApp(body, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns crowdfund app data
         * @summary Get crowdfund app data
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetCrowdfundApp(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CrowdfundAppData> {
            const localVarFetchArgs = CrowdfundApiFetchParamCreator(configuration).appsGetCrowdfundApp(appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CrowdfundApi - factory interface
 * @export
 */
export const CrowdfundApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a new Crowdfund app
         * @param {CrowdfundAppRequest} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsCreateCrowdfundApp(body: CrowdfundAppRequest, storeId: StoreId, options?: any) {
            return CrowdfundApiFp(configuration).appsCreateCrowdfundApp(body, storeId, options)(fetch, basePath);
        },
        /**
         * Returns crowdfund app data
         * @summary Get crowdfund app data
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetCrowdfundApp(appId: string, options?: any) {
            return CrowdfundApiFp(configuration).appsGetCrowdfundApp(appId, options)(fetch, basePath);
        },
    };
};

/**
 * CrowdfundApi - object-oriented interface
 * @export
 * @class CrowdfundApi
 * @extends {BaseAPI}
 */
export class CrowdfundApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Crowdfund app
     * @param {CrowdfundAppRequest} body 
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrowdfundApi
     */
    public appsCreateCrowdfundApp(body: CrowdfundAppRequest, storeId: StoreId, options?: any) {
        return CrowdfundApiFp(this.configuration).appsCreateCrowdfundApp(body, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns crowdfund app data
     * @summary Get crowdfund app data
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrowdfundApi
     */
    public appsGetCrowdfundApp(appId: string, options?: any) {
        return CrowdfundApiFp(this.configuration).appsGetCrowdfundApp(appId, options)(this.fetch, this.basePath);
    }

}
/**
 * FilesApi - fetch parameter creator
 * @export
 */
export const FilesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the file
         * @summary Delete file
         * @param {string} fileId The file to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesDeleteFile(fileId: string, options: any = {}): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId', 'Required parameter fileId was null or undefined when calling filesDeleteFile.');
            }
            const localVarPath = `/api/v1/files/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent((fileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the specified file
         * @summary Get file
         * @param {string} fileId The file information to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesGetFile(fileId: string, options: any = {}): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId', 'Required parameter fileId was null or undefined when calling filesGetFile.');
            }
            const localVarPath = `/api/v1/files/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent((fileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Load all files that exist.
         * @summary Get all files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesGetFiles(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/files`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a file
         * @summary Uploads a file
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesUploadFile(file?: Blob, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/files`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the file
         * @summary Delete file
         * @param {string} fileId The file to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesDeleteFile(fileId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).filesDeleteFile(fileId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the specified file
         * @summary Get file
         * @param {string} fileId The file information to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesGetFile(fileId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FileData> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).filesGetFile(fileId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Load all files that exist.
         * @summary Get all files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesGetFiles(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FileData>> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).filesGetFiles(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Uploads a file
         * @summary Uploads a file
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesUploadFile(file?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FileData> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).filesUploadFile(file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes the file
         * @summary Delete file
         * @param {string} fileId The file to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesDeleteFile(fileId: string, options?: any) {
            return FilesApiFp(configuration).filesDeleteFile(fileId, options)(fetch, basePath);
        },
        /**
         * View information about the specified file
         * @summary Get file
         * @param {string} fileId The file information to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesGetFile(fileId: string, options?: any) {
            return FilesApiFp(configuration).filesGetFile(fileId, options)(fetch, basePath);
        },
        /**
         * Load all files that exist.
         * @summary Get all files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesGetFiles(options?: any) {
            return FilesApiFp(configuration).filesGetFiles(options)(fetch, basePath);
        },
        /**
         * Uploads a file
         * @summary Uploads a file
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesUploadFile(file?: Blob, options?: any) {
            return FilesApiFp(configuration).filesUploadFile(file, options)(fetch, basePath);
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * Deletes the file
     * @summary Delete file
     * @param {string} fileId The file to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesDeleteFile(fileId: string, options?: any) {
        return FilesApiFp(this.configuration).filesDeleteFile(fileId, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the specified file
     * @summary Get file
     * @param {string} fileId The file information to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesGetFile(fileId: string, options?: any) {
        return FilesApiFp(this.configuration).filesGetFile(fileId, options)(this.fetch, this.basePath);
    }

    /**
     * Load all files that exist.
     * @summary Get all files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesGetFiles(options?: any) {
        return FilesApiFp(this.configuration).filesGetFiles(options)(this.fetch, this.basePath);
    }

    /**
     * Uploads a file
     * @summary Uploads a file
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesUploadFile(file?: Blob, options?: any) {
        return FilesApiFp(this.configuration).filesUploadFile(file, options)(this.fetch, this.basePath);
    }

}
/**
 * HealthApi - fetch parameter creator
 * @export
 */
export const HealthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check the instance health status
         * @summary Get health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGetHealth(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Check the instance health status
         * @summary Get health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGetHealth(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationHealthData> {
            const localVarFetchArgs = HealthApiFetchParamCreator(configuration).healthGetHealth(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Check the instance health status
         * @summary Get health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGetHealth(options?: any) {
            return HealthApiFp(configuration).healthGetHealth(options)(fetch, basePath);
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * Check the instance health status
     * @summary Get health status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthGetHealth(options?: any) {
        return HealthApiFp(this.configuration).healthGetHealth(options)(this.fetch, this.basePath);
    }

}
/**
 * InvoicesApi - fetch parameter creator
 * @export
 */
export const InvoicesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate an invoice payment method (if lazy payments mode is enabled)
         * @summary Activate Payment Method
         * @param {string} invoiceId The invoice ID
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesActivatePaymentMethod(invoiceId: string, paymentMethodId: PaymentMethodId, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId', 'Required parameter invoiceId was null or undefined when calling invoicesActivatePaymentMethod.');
            }
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling invoicesActivatePaymentMethod.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling invoicesActivatePaymentMethod.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/invoices/{invoiceId}/payment-methods/{paymentMethodId}/activate`
                .replace(`{${"invoiceId"}}`, encodeURIComponent((invoiceId)))
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archives the specified invoice.
         * @summary Archive invoice
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesArchiveInvoice(invoiceId: string, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId', 'Required parameter invoiceId was null or undefined when calling invoicesArchiveInvoice.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling invoicesArchiveInvoice.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent((invoiceId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new invoice
         * @summary Create a new invoice
         * @param {CreateInvoiceRequest} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesCreateInvoice(body: CreateInvoiceRequest, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling invoicesCreateInvoice.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling invoicesCreateInvoice.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/invoices`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateInvoiceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the specified invoice
         * @summary Get invoice
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesGetInvoice(invoiceId: string, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId', 'Required parameter invoiceId was null or undefined when calling invoicesGetInvoice.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling invoicesGetInvoice.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent((invoiceId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the specified invoice's payment methods
         * @summary Get invoice payment methods
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {boolean} [includeSensitive] If &#x60;true&#x60;, &#x60;additionalData&#x60; might include sensitive data (such as xpub). Requires the permission &#x60;btcpay.store.canmodifystoresettings&#x60;.
         * @param {boolean} [onlyAccountedPayments] If default or true, only returns payments which are accounted (in Bitcoin, this mean not returning RBF&#x27;d or double spent payments)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesGetInvoicePaymentMethods(invoiceId: string, storeId: StoreId, includeSensitive?: boolean, onlyAccountedPayments?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId', 'Required parameter invoiceId was null or undefined when calling invoicesGetInvoicePaymentMethods.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling invoicesGetInvoicePaymentMethods.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/invoices/{invoiceId}/payment-methods`
                .replace(`{${"invoiceId"}}`, encodeURIComponent((invoiceId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (includeSensitive !== undefined) {
                localVarQueryParameter['includeSensitive'] = includeSensitive;
            }

            if (onlyAccountedPayments !== undefined) {
                localVarQueryParameter['onlyAccountedPayments'] = onlyAccountedPayments;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the existing invoices
         * @summary Get invoices
         * @param {StoreId} storeId The store ID
         * @param {Array<string>} [orderId] Array of OrderIds to fetch the invoices for
         * @param {string} [textSearch] A term that can help locating specific invoices.
         * @param {InvoiceStatus} [status] Array of statuses of invoices to be fetched
         * @param {UnixTimestamp} [endDate] End date of the period to retrieve invoices
         * @param {number} [take] Number of records returned in response
         * @param {number} [skip] Number of records to skip
         * @param {UnixTimestamp} [startDate] Start date of the period to retrieve invoices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesGetInvoices(storeId: StoreId, orderId?: Array<string>, textSearch?: string, status?: InvoiceStatus, endDate?: UnixTimestamp, take?: number, skip?: number, startDate?: UnixTimestamp, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling invoicesGetInvoices.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/invoices`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (orderId) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (textSearch !== undefined) {
                localVarQueryParameter['textSearch'] = textSearch;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark an invoice as invalid or settled.
         * @summary Mark invoice status
         * @param {MarkInvoiceStatusRequest} body 
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesMarkInvoiceStatus(body: MarkInvoiceStatusRequest, invoiceId: string, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling invoicesMarkInvoiceStatus.');
            }
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId', 'Required parameter invoiceId was null or undefined when calling invoicesMarkInvoiceStatus.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling invoicesMarkInvoiceStatus.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/invoices/{invoiceId}/status`
                .replace(`{${"invoiceId"}}`, encodeURIComponent((invoiceId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MarkInvoiceStatusRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refund invoice
         * @summary Refund invoice
         * @param {InvoiceIdRefundBody} body 
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesRefund(body: InvoiceIdRefundBody, invoiceId: string, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling invoicesRefund.');
            }
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId', 'Required parameter invoiceId was null or undefined when calling invoicesRefund.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling invoicesRefund.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/invoices/{invoiceId}/refund`
                .replace(`{${"invoiceId"}}`, encodeURIComponent((invoiceId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InvoiceIdRefundBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unarchive an invoice
         * @summary Unarchive invoice
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesUnarchiveInvoice(invoiceId: string, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId', 'Required parameter invoiceId was null or undefined when calling invoicesUnarchiveInvoice.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling invoicesUnarchiveInvoice.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/invoices/{invoiceId}/unarchive`
                .replace(`{${"invoiceId"}}`, encodeURIComponent((invoiceId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified invoice.
         * @summary Update invoice
         * @param {UpdateInvoiceRequest} body 
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesUpdateInvoice(body: UpdateInvoiceRequest, invoiceId: string, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling invoicesUpdateInvoice.');
            }
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId', 'Required parameter invoiceId was null or undefined when calling invoicesUpdateInvoice.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling invoicesUpdateInvoice.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent((invoiceId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateInvoiceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Activate an invoice payment method (if lazy payments mode is enabled)
         * @summary Activate Payment Method
         * @param {string} invoiceId The invoice ID
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesActivatePaymentMethod(invoiceId: string, paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoicesApiFetchParamCreator(configuration).invoicesActivatePaymentMethod(invoiceId, paymentMethodId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Archives the specified invoice.
         * @summary Archive invoice
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesArchiveInvoice(invoiceId: string, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoicesApiFetchParamCreator(configuration).invoicesArchiveInvoice(invoiceId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new invoice
         * @summary Create a new invoice
         * @param {CreateInvoiceRequest} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesCreateInvoice(body: CreateInvoiceRequest, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvoiceData> {
            const localVarFetchArgs = InvoicesApiFetchParamCreator(configuration).invoicesCreateInvoice(body, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the specified invoice
         * @summary Get invoice
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesGetInvoice(invoiceId: string, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvoiceData> {
            const localVarFetchArgs = InvoicesApiFetchParamCreator(configuration).invoicesGetInvoice(invoiceId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the specified invoice's payment methods
         * @summary Get invoice payment methods
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {boolean} [includeSensitive] If &#x60;true&#x60;, &#x60;additionalData&#x60; might include sensitive data (such as xpub). Requires the permission &#x60;btcpay.store.canmodifystoresettings&#x60;.
         * @param {boolean} [onlyAccountedPayments] If default or true, only returns payments which are accounted (in Bitcoin, this mean not returning RBF&#x27;d or double spent payments)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesGetInvoicePaymentMethods(invoiceId: string, storeId: StoreId, includeSensitive?: boolean, onlyAccountedPayments?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvoicePaymentMethodDataModel>> {
            const localVarFetchArgs = InvoicesApiFetchParamCreator(configuration).invoicesGetInvoicePaymentMethods(invoiceId, storeId, includeSensitive, onlyAccountedPayments, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the existing invoices
         * @summary Get invoices
         * @param {StoreId} storeId The store ID
         * @param {Array<string>} [orderId] Array of OrderIds to fetch the invoices for
         * @param {string} [textSearch] A term that can help locating specific invoices.
         * @param {InvoiceStatus} [status] Array of statuses of invoices to be fetched
         * @param {UnixTimestamp} [endDate] End date of the period to retrieve invoices
         * @param {number} [take] Number of records returned in response
         * @param {number} [skip] Number of records to skip
         * @param {UnixTimestamp} [startDate] Start date of the period to retrieve invoices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesGetInvoices(storeId: StoreId, orderId?: Array<string>, textSearch?: string, status?: InvoiceStatus, endDate?: UnixTimestamp, take?: number, skip?: number, startDate?: UnixTimestamp, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvoiceDataList> {
            const localVarFetchArgs = InvoicesApiFetchParamCreator(configuration).invoicesGetInvoices(storeId, orderId, textSearch, status, endDate, take, skip, startDate, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Mark an invoice as invalid or settled.
         * @summary Mark invoice status
         * @param {MarkInvoiceStatusRequest} body 
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesMarkInvoiceStatus(body: MarkInvoiceStatusRequest, invoiceId: string, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvoiceData> {
            const localVarFetchArgs = InvoicesApiFetchParamCreator(configuration).invoicesMarkInvoiceStatus(body, invoiceId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Refund invoice
         * @summary Refund invoice
         * @param {InvoiceIdRefundBody} body 
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesRefund(body: InvoiceIdRefundBody, invoiceId: string, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PullPaymentData> {
            const localVarFetchArgs = InvoicesApiFetchParamCreator(configuration).invoicesRefund(body, invoiceId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Unarchive an invoice
         * @summary Unarchive invoice
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesUnarchiveInvoice(invoiceId: string, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvoiceData> {
            const localVarFetchArgs = InvoicesApiFetchParamCreator(configuration).invoicesUnarchiveInvoice(invoiceId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the specified invoice.
         * @summary Update invoice
         * @param {UpdateInvoiceRequest} body 
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesUpdateInvoice(body: UpdateInvoiceRequest, invoiceId: string, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvoiceData> {
            const localVarFetchArgs = InvoicesApiFetchParamCreator(configuration).invoicesUpdateInvoice(body, invoiceId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Activate an invoice payment method (if lazy payments mode is enabled)
         * @summary Activate Payment Method
         * @param {string} invoiceId The invoice ID
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesActivatePaymentMethod(invoiceId: string, paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
            return InvoicesApiFp(configuration).invoicesActivatePaymentMethod(invoiceId, paymentMethodId, storeId, options)(fetch, basePath);
        },
        /**
         * Archives the specified invoice.
         * @summary Archive invoice
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesArchiveInvoice(invoiceId: string, storeId: StoreId, options?: any) {
            return InvoicesApiFp(configuration).invoicesArchiveInvoice(invoiceId, storeId, options)(fetch, basePath);
        },
        /**
         * Create a new invoice
         * @summary Create a new invoice
         * @param {CreateInvoiceRequest} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesCreateInvoice(body: CreateInvoiceRequest, storeId: StoreId, options?: any) {
            return InvoicesApiFp(configuration).invoicesCreateInvoice(body, storeId, options)(fetch, basePath);
        },
        /**
         * View information about the specified invoice
         * @summary Get invoice
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesGetInvoice(invoiceId: string, storeId: StoreId, options?: any) {
            return InvoicesApiFp(configuration).invoicesGetInvoice(invoiceId, storeId, options)(fetch, basePath);
        },
        /**
         * View information about the specified invoice's payment methods
         * @summary Get invoice payment methods
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {boolean} [includeSensitive] If &#x60;true&#x60;, &#x60;additionalData&#x60; might include sensitive data (such as xpub). Requires the permission &#x60;btcpay.store.canmodifystoresettings&#x60;.
         * @param {boolean} [onlyAccountedPayments] If default or true, only returns payments which are accounted (in Bitcoin, this mean not returning RBF&#x27;d or double spent payments)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesGetInvoicePaymentMethods(invoiceId: string, storeId: StoreId, includeSensitive?: boolean, onlyAccountedPayments?: boolean, options?: any) {
            return InvoicesApiFp(configuration).invoicesGetInvoicePaymentMethods(invoiceId, storeId, includeSensitive, onlyAccountedPayments, options)(fetch, basePath);
        },
        /**
         * View information about the existing invoices
         * @summary Get invoices
         * @param {StoreId} storeId The store ID
         * @param {Array<string>} [orderId] Array of OrderIds to fetch the invoices for
         * @param {string} [textSearch] A term that can help locating specific invoices.
         * @param {InvoiceStatus} [status] Array of statuses of invoices to be fetched
         * @param {UnixTimestamp} [endDate] End date of the period to retrieve invoices
         * @param {number} [take] Number of records returned in response
         * @param {number} [skip] Number of records to skip
         * @param {UnixTimestamp} [startDate] Start date of the period to retrieve invoices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesGetInvoices(storeId: StoreId, orderId?: Array<string>, textSearch?: string, status?: InvoiceStatus, endDate?: UnixTimestamp, take?: number, skip?: number, startDate?: UnixTimestamp, options?: any) {
            return InvoicesApiFp(configuration).invoicesGetInvoices(storeId, orderId, textSearch, status, endDate, take, skip, startDate, options)(fetch, basePath);
        },
        /**
         * Mark an invoice as invalid or settled.
         * @summary Mark invoice status
         * @param {MarkInvoiceStatusRequest} body 
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesMarkInvoiceStatus(body: MarkInvoiceStatusRequest, invoiceId: string, storeId: StoreId, options?: any) {
            return InvoicesApiFp(configuration).invoicesMarkInvoiceStatus(body, invoiceId, storeId, options)(fetch, basePath);
        },
        /**
         * Refund invoice
         * @summary Refund invoice
         * @param {InvoiceIdRefundBody} body 
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesRefund(body: InvoiceIdRefundBody, invoiceId: string, storeId: StoreId, options?: any) {
            return InvoicesApiFp(configuration).invoicesRefund(body, invoiceId, storeId, options)(fetch, basePath);
        },
        /**
         * Unarchive an invoice
         * @summary Unarchive invoice
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesUnarchiveInvoice(invoiceId: string, storeId: StoreId, options?: any) {
            return InvoicesApiFp(configuration).invoicesUnarchiveInvoice(invoiceId, storeId, options)(fetch, basePath);
        },
        /**
         * Updates the specified invoice.
         * @summary Update invoice
         * @param {UpdateInvoiceRequest} body 
         * @param {string} invoiceId The invoice ID
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoicesUpdateInvoice(body: UpdateInvoiceRequest, invoiceId: string, storeId: StoreId, options?: any) {
            return InvoicesApiFp(configuration).invoicesUpdateInvoice(body, invoiceId, storeId, options)(fetch, basePath);
        },
    };
};

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
    /**
     * Activate an invoice payment method (if lazy payments mode is enabled)
     * @summary Activate Payment Method
     * @param {string} invoiceId The invoice ID
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public invoicesActivatePaymentMethod(invoiceId: string, paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
        return InvoicesApiFp(this.configuration).invoicesActivatePaymentMethod(invoiceId, paymentMethodId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Archives the specified invoice.
     * @summary Archive invoice
     * @param {string} invoiceId The invoice ID
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public invoicesArchiveInvoice(invoiceId: string, storeId: StoreId, options?: any) {
        return InvoicesApiFp(this.configuration).invoicesArchiveInvoice(invoiceId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new invoice
     * @summary Create a new invoice
     * @param {CreateInvoiceRequest} body 
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public invoicesCreateInvoice(body: CreateInvoiceRequest, storeId: StoreId, options?: any) {
        return InvoicesApiFp(this.configuration).invoicesCreateInvoice(body, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the specified invoice
     * @summary Get invoice
     * @param {string} invoiceId The invoice ID
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public invoicesGetInvoice(invoiceId: string, storeId: StoreId, options?: any) {
        return InvoicesApiFp(this.configuration).invoicesGetInvoice(invoiceId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the specified invoice's payment methods
     * @summary Get invoice payment methods
     * @param {string} invoiceId The invoice ID
     * @param {StoreId} storeId The store ID
     * @param {boolean} [includeSensitive] If &#x60;true&#x60;, &#x60;additionalData&#x60; might include sensitive data (such as xpub). Requires the permission &#x60;btcpay.store.canmodifystoresettings&#x60;.
     * @param {boolean} [onlyAccountedPayments] If default or true, only returns payments which are accounted (in Bitcoin, this mean not returning RBF&#x27;d or double spent payments)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public invoicesGetInvoicePaymentMethods(invoiceId: string, storeId: StoreId, includeSensitive?: boolean, onlyAccountedPayments?: boolean, options?: any) {
        return InvoicesApiFp(this.configuration).invoicesGetInvoicePaymentMethods(invoiceId, storeId, includeSensitive, onlyAccountedPayments, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the existing invoices
     * @summary Get invoices
     * @param {StoreId} storeId The store ID
     * @param {Array<string>} [orderId] Array of OrderIds to fetch the invoices for
     * @param {string} [textSearch] A term that can help locating specific invoices.
     * @param {InvoiceStatus} [status] Array of statuses of invoices to be fetched
     * @param {UnixTimestamp} [endDate] End date of the period to retrieve invoices
     * @param {number} [take] Number of records returned in response
     * @param {number} [skip] Number of records to skip
     * @param {UnixTimestamp} [startDate] Start date of the period to retrieve invoices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public invoicesGetInvoices(storeId: StoreId, orderId?: Array<string>, textSearch?: string, status?: InvoiceStatus, endDate?: UnixTimestamp, take?: number, skip?: number, startDate?: UnixTimestamp, options?: any) {
        return InvoicesApiFp(this.configuration).invoicesGetInvoices(storeId, orderId, textSearch, status, endDate, take, skip, startDate, options)(this.fetch, this.basePath);
    }

    /**
     * Mark an invoice as invalid or settled.
     * @summary Mark invoice status
     * @param {MarkInvoiceStatusRequest} body 
     * @param {string} invoiceId The invoice ID
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public invoicesMarkInvoiceStatus(body: MarkInvoiceStatusRequest, invoiceId: string, storeId: StoreId, options?: any) {
        return InvoicesApiFp(this.configuration).invoicesMarkInvoiceStatus(body, invoiceId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Refund invoice
     * @summary Refund invoice
     * @param {InvoiceIdRefundBody} body 
     * @param {string} invoiceId The invoice ID
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public invoicesRefund(body: InvoiceIdRefundBody, invoiceId: string, storeId: StoreId, options?: any) {
        return InvoicesApiFp(this.configuration).invoicesRefund(body, invoiceId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Unarchive an invoice
     * @summary Unarchive invoice
     * @param {string} invoiceId The invoice ID
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public invoicesUnarchiveInvoice(invoiceId: string, storeId: StoreId, options?: any) {
        return InvoicesApiFp(this.configuration).invoicesUnarchiveInvoice(invoiceId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the specified invoice.
     * @summary Update invoice
     * @param {UpdateInvoiceRequest} body 
     * @param {string} invoiceId The invoice ID
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public invoicesUpdateInvoice(body: UpdateInvoiceRequest, invoiceId: string, storeId: StoreId, options?: any) {
        return InvoicesApiFp(this.configuration).invoicesUpdateInvoice(body, invoiceId, storeId, options)(this.fetch, this.basePath);
    }

}
/**
 * LightningAddressApi - fetch parameter creator
 * @export
 */
export const LightningAddressApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add or update store configured lightning address
         * @summary Add or update store configured lightning address
         * @param {LightningAddressData} body 
         * @param {StoreId} storeId The store ID
         * @param {string} username the lightning address username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningAddressesAddOrUpdateStoreLightningAddress(body: LightningAddressData, storeId: StoreId, username: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storeLightningAddressesAddOrUpdateStoreLightningAddress.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningAddressesAddOrUpdateStoreLightningAddress.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username', 'Required parameter username was null or undefined when calling storeLightningAddressesAddOrUpdateStoreLightningAddress.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning-addresses/{username}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"username"}}`, encodeURIComponent((username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LightningAddressData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get store configured lightning address
         * @summary Get store configured lightning address
         * @param {StoreId} storeId The store ID
         * @param {string} username The lightning address username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningAddressesGetStoreLightningAddress(storeId: StoreId, username: string, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningAddressesGetStoreLightningAddress.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username', 'Required parameter username was null or undefined when calling storeLightningAddressesGetStoreLightningAddress.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning-addresses/{username}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"username"}}`, encodeURIComponent((username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get store configured lightning addresses
         * @summary Get store configured lightning addresses
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningAddressesGetStoreLightningAddresses(storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningAddressesGetStoreLightningAddresses.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning-addresses`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove store configured lightning address
         * @summary Remove configured lightning address
         * @param {StoreId} storeId The store ID
         * @param {string} username The lightning address username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningAddressesRemoveStoreLightningAddress(storeId: StoreId, username: string, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningAddressesRemoveStoreLightningAddress.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username', 'Required parameter username was null or undefined when calling storeLightningAddressesRemoveStoreLightningAddress.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning-addresses/{username}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"username"}}`, encodeURIComponent((username)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LightningAddressApi - functional programming interface
 * @export
 */
export const LightningAddressApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Add or update store configured lightning address
         * @summary Add or update store configured lightning address
         * @param {LightningAddressData} body 
         * @param {StoreId} storeId The store ID
         * @param {string} username the lightning address username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningAddressesAddOrUpdateStoreLightningAddress(body: LightningAddressData, storeId: StoreId, username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightningAddressData> {
            const localVarFetchArgs = LightningAddressApiFetchParamCreator(configuration).storeLightningAddressesAddOrUpdateStoreLightningAddress(body, storeId, username, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get store configured lightning address
         * @summary Get store configured lightning address
         * @param {StoreId} storeId The store ID
         * @param {string} username The lightning address username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningAddressesGetStoreLightningAddress(storeId: StoreId, username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightningAddressData> {
            const localVarFetchArgs = LightningAddressApiFetchParamCreator(configuration).storeLightningAddressesGetStoreLightningAddress(storeId, username, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get store configured lightning addresses
         * @summary Get store configured lightning addresses
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningAddressesGetStoreLightningAddresses(storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LightningAddressData>> {
            const localVarFetchArgs = LightningAddressApiFetchParamCreator(configuration).storeLightningAddressesGetStoreLightningAddresses(storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove store configured lightning address
         * @summary Remove configured lightning address
         * @param {StoreId} storeId The store ID
         * @param {string} username The lightning address username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningAddressesRemoveStoreLightningAddress(storeId: StoreId, username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LightningAddressApiFetchParamCreator(configuration).storeLightningAddressesRemoveStoreLightningAddress(storeId, username, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LightningAddressApi - factory interface
 * @export
 */
export const LightningAddressApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add or update store configured lightning address
         * @summary Add or update store configured lightning address
         * @param {LightningAddressData} body 
         * @param {StoreId} storeId The store ID
         * @param {string} username the lightning address username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningAddressesAddOrUpdateStoreLightningAddress(body: LightningAddressData, storeId: StoreId, username: string, options?: any) {
            return LightningAddressApiFp(configuration).storeLightningAddressesAddOrUpdateStoreLightningAddress(body, storeId, username, options)(fetch, basePath);
        },
        /**
         * Get store configured lightning address
         * @summary Get store configured lightning address
         * @param {StoreId} storeId The store ID
         * @param {string} username The lightning address username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningAddressesGetStoreLightningAddress(storeId: StoreId, username: string, options?: any) {
            return LightningAddressApiFp(configuration).storeLightningAddressesGetStoreLightningAddress(storeId, username, options)(fetch, basePath);
        },
        /**
         * Get store configured lightning addresses
         * @summary Get store configured lightning addresses
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningAddressesGetStoreLightningAddresses(storeId: StoreId, options?: any) {
            return LightningAddressApiFp(configuration).storeLightningAddressesGetStoreLightningAddresses(storeId, options)(fetch, basePath);
        },
        /**
         * Remove store configured lightning address
         * @summary Remove configured lightning address
         * @param {StoreId} storeId The store ID
         * @param {string} username The lightning address username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningAddressesRemoveStoreLightningAddress(storeId: StoreId, username: string, options?: any) {
            return LightningAddressApiFp(configuration).storeLightningAddressesRemoveStoreLightningAddress(storeId, username, options)(fetch, basePath);
        },
    };
};

/**
 * LightningAddressApi - object-oriented interface
 * @export
 * @class LightningAddressApi
 * @extends {BaseAPI}
 */
export class LightningAddressApi extends BaseAPI {
    /**
     * Add or update store configured lightning address
     * @summary Add or update store configured lightning address
     * @param {LightningAddressData} body 
     * @param {StoreId} storeId The store ID
     * @param {string} username the lightning address username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningAddressApi
     */
    public storeLightningAddressesAddOrUpdateStoreLightningAddress(body: LightningAddressData, storeId: StoreId, username: string, options?: any) {
        return LightningAddressApiFp(this.configuration).storeLightningAddressesAddOrUpdateStoreLightningAddress(body, storeId, username, options)(this.fetch, this.basePath);
    }

    /**
     * Get store configured lightning address
     * @summary Get store configured lightning address
     * @param {StoreId} storeId The store ID
     * @param {string} username The lightning address username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningAddressApi
     */
    public storeLightningAddressesGetStoreLightningAddress(storeId: StoreId, username: string, options?: any) {
        return LightningAddressApiFp(this.configuration).storeLightningAddressesGetStoreLightningAddress(storeId, username, options)(this.fetch, this.basePath);
    }

    /**
     * Get store configured lightning addresses
     * @summary Get store configured lightning addresses
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningAddressApi
     */
    public storeLightningAddressesGetStoreLightningAddresses(storeId: StoreId, options?: any) {
        return LightningAddressApiFp(this.configuration).storeLightningAddressesGetStoreLightningAddresses(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Remove store configured lightning address
     * @summary Remove configured lightning address
     * @param {StoreId} storeId The store ID
     * @param {string} username The lightning address username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningAddressApi
     */
    public storeLightningAddressesRemoveStoreLightningAddress(storeId: StoreId, username: string, options?: any) {
        return LightningAddressApiFp(this.configuration).storeLightningAddressesRemoveStoreLightningAddress(storeId, username, options)(this.fetch, this.basePath);
    }

}
/**
 * LightningInternalNodeApi - fetch parameter creator
 * @export
 */
export const LightningInternalNodeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Connect to another lightning node.
         * @summary Connect to lightning node
         * @param {ConnectToNodeRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiConnectToNode(body: ConnectToNodeRequest, cryptoCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling internalLightningNodeApiConnectToNode.');
            }
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling internalLightningNodeApiConnectToNode.');
            }
            const localVarPath = `/api/v1/server/lightning/{cryptoCode}/connect`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ConnectToNodeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a lightning invoice.
         * @summary Create lightning invoice
         * @param {CreateLightningInvoiceRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiCreateInvoice(body: CreateLightningInvoiceRequest, cryptoCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling internalLightningNodeApiCreateInvoice.');
            }
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling internalLightningNodeApiCreateInvoice.');
            }
            const localVarPath = `/api/v1/server/lightning/{cryptoCode}/invoices`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateLightningInvoiceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View balance of the lightning node
         * @summary Get node balance
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetBalance(cryptoCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling internalLightningNodeApiGetBalance.');
            }
            const localVarPath = `/api/v1/server/lightning/{cryptoCode}/balance`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the current channels of the lightning node
         * @summary Get channels
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetChannels(cryptoCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling internalLightningNodeApiGetChannels.');
            }
            const localVarPath = `/api/v1/server/lightning/{cryptoCode}/channels`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an on-chain deposit address for the lightning node 
         * @summary Get deposit address
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetDepositAddress(cryptoCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling internalLightningNodeApiGetDepositAddress.');
            }
            const localVarPath = `/api/v1/server/lightning/{cryptoCode}/address`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View balance histogram of the lightning node
         * @summary Get node balance histogram
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetHistogram(cryptoCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling internalLightningNodeApiGetHistogram.');
            }
            const localVarPath = `/api/v1/server/lightning/{cryptoCode}/histogram`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the lightning node
         * @summary Get node information
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetInfo(cryptoCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling internalLightningNodeApiGetInfo.');
            }
            const localVarPath = `/api/v1/server/lightning/{cryptoCode}/info`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the requested lightning invoice
         * @summary Get invoice
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {string} id The id of the lightning invoice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetInvoice(cryptoCode: string, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling internalLightningNodeApiGetInvoice.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling internalLightningNodeApiGetInvoice.');
            }
            const localVarPath = `/api/v1/server/lightning/{cryptoCode}/invoices/{id}`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)))
                .replace(`{${"id"}}`, encodeURIComponent((id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the lightning invoices
         * @summary Get invoices
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {boolean} [pendingOnly] Limit to pending invoices only
         * @param {number} [offsetIndex] The index of an invoice that will be used as the start of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetInvoices(cryptoCode: string, pendingOnly?: boolean, offsetIndex?: number, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling internalLightningNodeApiGetInvoices.');
            }
            const localVarPath = `/api/v1/server/lightning/{cryptoCode}/invoices`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (pendingOnly !== undefined) {
                localVarQueryParameter['pendingOnly'] = pendingOnly;
            }

            if (offsetIndex !== undefined) {
                localVarQueryParameter['offsetIndex'] = offsetIndex;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the requested lightning payment
         * @summary Get payment
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {string} paymentHash The payment hash of the lightning payment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetPayment(cryptoCode: string, paymentHash: string, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling internalLightningNodeApiGetPayment.');
            }
            // verify required parameter 'paymentHash' is not null or undefined
            if (paymentHash === null || paymentHash === undefined) {
                throw new RequiredError('paymentHash', 'Required parameter paymentHash was null or undefined when calling internalLightningNodeApiGetPayment.');
            }
            const localVarPath = `/api/v1/server/lightning/{cryptoCode}/payments/{paymentHash}`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)))
                .replace(`{${"paymentHash"}}`, encodeURIComponent((paymentHash)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the lightning payments
         * @summary Get payments
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {boolean} [includePending] Also include pending payments
         * @param {number} [offsetIndex] The index of a payment that will be used as the start of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetPayments(cryptoCode: string, includePending?: boolean, offsetIndex?: number, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling internalLightningNodeApiGetPayments.');
            }
            const localVarPath = `/api/v1/server/lightning/{cryptoCode}/payments`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (includePending !== undefined) {
                localVarQueryParameter['includePending'] = includePending;
            }

            if (offsetIndex !== undefined) {
                localVarQueryParameter['offsetIndex'] = offsetIndex;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Open a channel with another lightning node. You should connect to that node first.
         * @summary Open channel
         * @param {OpenLightningChannelRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiOpenChannel(body: OpenLightningChannelRequest, cryptoCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling internalLightningNodeApiOpenChannel.');
            }
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling internalLightningNodeApiOpenChannel.');
            }
            const localVarPath = `/api/v1/server/lightning/{cryptoCode}/channels`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OpenLightningChannelRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pay a lightning invoice. In case the payment response times out, the status will be reported as pending and the final status can be resolved using the [Get payment](#operation/InternalLightningNodeApi_GetPayment) endpoint. The default wait time for payment responses is 30 seconds — it might take longer if multiple routes are tried or a hold invoice is getting paid.
         * @summary Pay Lightning Invoice
         * @param {PayLightningInvoiceRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiPayInvoice(body: PayLightningInvoiceRequest, cryptoCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling internalLightningNodeApiPayInvoice.');
            }
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling internalLightningNodeApiPayInvoice.');
            }
            const localVarPath = `/api/v1/server/lightning/{cryptoCode}/invoices/pay`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PayLightningInvoiceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LightningInternalNodeApi - functional programming interface
 * @export
 */
export const LightningInternalNodeApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Connect to another lightning node.
         * @summary Connect to lightning node
         * @param {ConnectToNodeRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiConnectToNode(body: ConnectToNodeRequest, cryptoCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LightningInternalNodeApiFetchParamCreator(configuration).internalLightningNodeApiConnectToNode(body, cryptoCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a lightning invoice.
         * @summary Create lightning invoice
         * @param {CreateLightningInvoiceRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiCreateInvoice(body: CreateLightningInvoiceRequest, cryptoCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightningInvoiceData> {
            const localVarFetchArgs = LightningInternalNodeApiFetchParamCreator(configuration).internalLightningNodeApiCreateInvoice(body, cryptoCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View balance of the lightning node
         * @summary Get node balance
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetBalance(cryptoCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightningNodeBalanceData> {
            const localVarFetchArgs = LightningInternalNodeApiFetchParamCreator(configuration).internalLightningNodeApiGetBalance(cryptoCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the current channels of the lightning node
         * @summary Get channels
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetChannels(cryptoCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LightningChannelData>> {
            const localVarFetchArgs = LightningInternalNodeApiFetchParamCreator(configuration).internalLightningNodeApiGetChannels(cryptoCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an on-chain deposit address for the lightning node 
         * @summary Get deposit address
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetDepositAddress(cryptoCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = LightningInternalNodeApiFetchParamCreator(configuration).internalLightningNodeApiGetDepositAddress(cryptoCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View balance histogram of the lightning node
         * @summary Get node balance histogram
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetHistogram(cryptoCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HistogramData> {
            const localVarFetchArgs = LightningInternalNodeApiFetchParamCreator(configuration).internalLightningNodeApiGetHistogram(cryptoCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the lightning node
         * @summary Get node information
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetInfo(cryptoCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightningNodeInformationData> {
            const localVarFetchArgs = LightningInternalNodeApiFetchParamCreator(configuration).internalLightningNodeApiGetInfo(cryptoCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the requested lightning invoice
         * @summary Get invoice
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {string} id The id of the lightning invoice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetInvoice(cryptoCode: string, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightningInvoiceData> {
            const localVarFetchArgs = LightningInternalNodeApiFetchParamCreator(configuration).internalLightningNodeApiGetInvoice(cryptoCode, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the lightning invoices
         * @summary Get invoices
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {boolean} [pendingOnly] Limit to pending invoices only
         * @param {number} [offsetIndex] The index of an invoice that will be used as the start of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetInvoices(cryptoCode: string, pendingOnly?: boolean, offsetIndex?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LightningInvoiceData>> {
            const localVarFetchArgs = LightningInternalNodeApiFetchParamCreator(configuration).internalLightningNodeApiGetInvoices(cryptoCode, pendingOnly, offsetIndex, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the requested lightning payment
         * @summary Get payment
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {string} paymentHash The payment hash of the lightning payment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetPayment(cryptoCode: string, paymentHash: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightningPaymentData> {
            const localVarFetchArgs = LightningInternalNodeApiFetchParamCreator(configuration).internalLightningNodeApiGetPayment(cryptoCode, paymentHash, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the lightning payments
         * @summary Get payments
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {boolean} [includePending] Also include pending payments
         * @param {number} [offsetIndex] The index of a payment that will be used as the start of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetPayments(cryptoCode: string, includePending?: boolean, offsetIndex?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LightningPaymentData>> {
            const localVarFetchArgs = LightningInternalNodeApiFetchParamCreator(configuration).internalLightningNodeApiGetPayments(cryptoCode, includePending, offsetIndex, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Open a channel with another lightning node. You should connect to that node first.
         * @summary Open channel
         * @param {OpenLightningChannelRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiOpenChannel(body: OpenLightningChannelRequest, cryptoCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LightningInternalNodeApiFetchParamCreator(configuration).internalLightningNodeApiOpenChannel(body, cryptoCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Pay a lightning invoice. In case the payment response times out, the status will be reported as pending and the final status can be resolved using the [Get payment](#operation/InternalLightningNodeApi_GetPayment) endpoint. The default wait time for payment responses is 30 seconds — it might take longer if multiple routes are tried or a hold invoice is getting paid.
         * @summary Pay Lightning Invoice
         * @param {PayLightningInvoiceRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiPayInvoice(body: PayLightningInvoiceRequest, cryptoCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightningPaymentData> {
            const localVarFetchArgs = LightningInternalNodeApiFetchParamCreator(configuration).internalLightningNodeApiPayInvoice(body, cryptoCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LightningInternalNodeApi - factory interface
 * @export
 */
export const LightningInternalNodeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Connect to another lightning node.
         * @summary Connect to lightning node
         * @param {ConnectToNodeRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiConnectToNode(body: ConnectToNodeRequest, cryptoCode: string, options?: any) {
            return LightningInternalNodeApiFp(configuration).internalLightningNodeApiConnectToNode(body, cryptoCode, options)(fetch, basePath);
        },
        /**
         * Create a lightning invoice.
         * @summary Create lightning invoice
         * @param {CreateLightningInvoiceRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiCreateInvoice(body: CreateLightningInvoiceRequest, cryptoCode: string, options?: any) {
            return LightningInternalNodeApiFp(configuration).internalLightningNodeApiCreateInvoice(body, cryptoCode, options)(fetch, basePath);
        },
        /**
         * View balance of the lightning node
         * @summary Get node balance
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetBalance(cryptoCode: string, options?: any) {
            return LightningInternalNodeApiFp(configuration).internalLightningNodeApiGetBalance(cryptoCode, options)(fetch, basePath);
        },
        /**
         * View information about the current channels of the lightning node
         * @summary Get channels
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetChannels(cryptoCode: string, options?: any) {
            return LightningInternalNodeApiFp(configuration).internalLightningNodeApiGetChannels(cryptoCode, options)(fetch, basePath);
        },
        /**
         * Get an on-chain deposit address for the lightning node 
         * @summary Get deposit address
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetDepositAddress(cryptoCode: string, options?: any) {
            return LightningInternalNodeApiFp(configuration).internalLightningNodeApiGetDepositAddress(cryptoCode, options)(fetch, basePath);
        },
        /**
         * View balance histogram of the lightning node
         * @summary Get node balance histogram
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetHistogram(cryptoCode: string, options?: any) {
            return LightningInternalNodeApiFp(configuration).internalLightningNodeApiGetHistogram(cryptoCode, options)(fetch, basePath);
        },
        /**
         * View information about the lightning node
         * @summary Get node information
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetInfo(cryptoCode: string, options?: any) {
            return LightningInternalNodeApiFp(configuration).internalLightningNodeApiGetInfo(cryptoCode, options)(fetch, basePath);
        },
        /**
         * View information about the requested lightning invoice
         * @summary Get invoice
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {string} id The id of the lightning invoice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetInvoice(cryptoCode: string, id: string, options?: any) {
            return LightningInternalNodeApiFp(configuration).internalLightningNodeApiGetInvoice(cryptoCode, id, options)(fetch, basePath);
        },
        /**
         * View information about the lightning invoices
         * @summary Get invoices
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {boolean} [pendingOnly] Limit to pending invoices only
         * @param {number} [offsetIndex] The index of an invoice that will be used as the start of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetInvoices(cryptoCode: string, pendingOnly?: boolean, offsetIndex?: number, options?: any) {
            return LightningInternalNodeApiFp(configuration).internalLightningNodeApiGetInvoices(cryptoCode, pendingOnly, offsetIndex, options)(fetch, basePath);
        },
        /**
         * View information about the requested lightning payment
         * @summary Get payment
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {string} paymentHash The payment hash of the lightning payment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetPayment(cryptoCode: string, paymentHash: string, options?: any) {
            return LightningInternalNodeApiFp(configuration).internalLightningNodeApiGetPayment(cryptoCode, paymentHash, options)(fetch, basePath);
        },
        /**
         * View information about the lightning payments
         * @summary Get payments
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {boolean} [includePending] Also include pending payments
         * @param {number} [offsetIndex] The index of a payment that will be used as the start of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiGetPayments(cryptoCode: string, includePending?: boolean, offsetIndex?: number, options?: any) {
            return LightningInternalNodeApiFp(configuration).internalLightningNodeApiGetPayments(cryptoCode, includePending, offsetIndex, options)(fetch, basePath);
        },
        /**
         * Open a channel with another lightning node. You should connect to that node first.
         * @summary Open channel
         * @param {OpenLightningChannelRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiOpenChannel(body: OpenLightningChannelRequest, cryptoCode: string, options?: any) {
            return LightningInternalNodeApiFp(configuration).internalLightningNodeApiOpenChannel(body, cryptoCode, options)(fetch, basePath);
        },
        /**
         * Pay a lightning invoice. In case the payment response times out, the status will be reported as pending and the final status can be resolved using the [Get payment](#operation/InternalLightningNodeApi_GetPayment) endpoint. The default wait time for payment responses is 30 seconds — it might take longer if multiple routes are tried or a hold invoice is getting paid.
         * @summary Pay Lightning Invoice
         * @param {PayLightningInvoiceRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalLightningNodeApiPayInvoice(body: PayLightningInvoiceRequest, cryptoCode: string, options?: any) {
            return LightningInternalNodeApiFp(configuration).internalLightningNodeApiPayInvoice(body, cryptoCode, options)(fetch, basePath);
        },
    };
};

/**
 * LightningInternalNodeApi - object-oriented interface
 * @export
 * @class LightningInternalNodeApi
 * @extends {BaseAPI}
 */
export class LightningInternalNodeApi extends BaseAPI {
    /**
     * Connect to another lightning node.
     * @summary Connect to lightning node
     * @param {ConnectToNodeRequest} body 
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningInternalNodeApi
     */
    public internalLightningNodeApiConnectToNode(body: ConnectToNodeRequest, cryptoCode: string, options?: any) {
        return LightningInternalNodeApiFp(this.configuration).internalLightningNodeApiConnectToNode(body, cryptoCode, options)(this.fetch, this.basePath);
    }

    /**
     * Create a lightning invoice.
     * @summary Create lightning invoice
     * @param {CreateLightningInvoiceRequest} body 
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningInternalNodeApi
     */
    public internalLightningNodeApiCreateInvoice(body: CreateLightningInvoiceRequest, cryptoCode: string, options?: any) {
        return LightningInternalNodeApiFp(this.configuration).internalLightningNodeApiCreateInvoice(body, cryptoCode, options)(this.fetch, this.basePath);
    }

    /**
     * View balance of the lightning node
     * @summary Get node balance
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningInternalNodeApi
     */
    public internalLightningNodeApiGetBalance(cryptoCode: string, options?: any) {
        return LightningInternalNodeApiFp(this.configuration).internalLightningNodeApiGetBalance(cryptoCode, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the current channels of the lightning node
     * @summary Get channels
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningInternalNodeApi
     */
    public internalLightningNodeApiGetChannels(cryptoCode: string, options?: any) {
        return LightningInternalNodeApiFp(this.configuration).internalLightningNodeApiGetChannels(cryptoCode, options)(this.fetch, this.basePath);
    }

    /**
     * Get an on-chain deposit address for the lightning node 
     * @summary Get deposit address
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningInternalNodeApi
     */
    public internalLightningNodeApiGetDepositAddress(cryptoCode: string, options?: any) {
        return LightningInternalNodeApiFp(this.configuration).internalLightningNodeApiGetDepositAddress(cryptoCode, options)(this.fetch, this.basePath);
    }

    /**
     * View balance histogram of the lightning node
     * @summary Get node balance histogram
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningInternalNodeApi
     */
    public internalLightningNodeApiGetHistogram(cryptoCode: string, options?: any) {
        return LightningInternalNodeApiFp(this.configuration).internalLightningNodeApiGetHistogram(cryptoCode, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the lightning node
     * @summary Get node information
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningInternalNodeApi
     */
    public internalLightningNodeApiGetInfo(cryptoCode: string, options?: any) {
        return LightningInternalNodeApiFp(this.configuration).internalLightningNodeApiGetInfo(cryptoCode, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the requested lightning invoice
     * @summary Get invoice
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {string} id The id of the lightning invoice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningInternalNodeApi
     */
    public internalLightningNodeApiGetInvoice(cryptoCode: string, id: string, options?: any) {
        return LightningInternalNodeApiFp(this.configuration).internalLightningNodeApiGetInvoice(cryptoCode, id, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the lightning invoices
     * @summary Get invoices
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {boolean} [pendingOnly] Limit to pending invoices only
     * @param {number} [offsetIndex] The index of an invoice that will be used as the start of the list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningInternalNodeApi
     */
    public internalLightningNodeApiGetInvoices(cryptoCode: string, pendingOnly?: boolean, offsetIndex?: number, options?: any) {
        return LightningInternalNodeApiFp(this.configuration).internalLightningNodeApiGetInvoices(cryptoCode, pendingOnly, offsetIndex, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the requested lightning payment
     * @summary Get payment
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {string} paymentHash The payment hash of the lightning payment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningInternalNodeApi
     */
    public internalLightningNodeApiGetPayment(cryptoCode: string, paymentHash: string, options?: any) {
        return LightningInternalNodeApiFp(this.configuration).internalLightningNodeApiGetPayment(cryptoCode, paymentHash, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the lightning payments
     * @summary Get payments
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {boolean} [includePending] Also include pending payments
     * @param {number} [offsetIndex] The index of a payment that will be used as the start of the list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningInternalNodeApi
     */
    public internalLightningNodeApiGetPayments(cryptoCode: string, includePending?: boolean, offsetIndex?: number, options?: any) {
        return LightningInternalNodeApiFp(this.configuration).internalLightningNodeApiGetPayments(cryptoCode, includePending, offsetIndex, options)(this.fetch, this.basePath);
    }

    /**
     * Open a channel with another lightning node. You should connect to that node first.
     * @summary Open channel
     * @param {OpenLightningChannelRequest} body 
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningInternalNodeApi
     */
    public internalLightningNodeApiOpenChannel(body: OpenLightningChannelRequest, cryptoCode: string, options?: any) {
        return LightningInternalNodeApiFp(this.configuration).internalLightningNodeApiOpenChannel(body, cryptoCode, options)(this.fetch, this.basePath);
    }

    /**
     * Pay a lightning invoice. In case the payment response times out, the status will be reported as pending and the final status can be resolved using the [Get payment](#operation/InternalLightningNodeApi_GetPayment) endpoint. The default wait time for payment responses is 30 seconds — it might take longer if multiple routes are tried or a hold invoice is getting paid.
     * @summary Pay Lightning Invoice
     * @param {PayLightningInvoiceRequest} body 
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningInternalNodeApi
     */
    public internalLightningNodeApiPayInvoice(body: PayLightningInvoiceRequest, cryptoCode: string, options?: any) {
        return LightningInternalNodeApiFp(this.configuration).internalLightningNodeApiPayInvoice(body, cryptoCode, options)(this.fetch, this.basePath);
    }

}
/**
 * LightningStoreApi - fetch parameter creator
 * @export
 */
export const LightningStoreApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Connect to another lightning node.
         * @summary Connect to lightning node
         * @param {ConnectToNodeRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiConnectToNode(body: ConnectToNodeRequest, cryptoCode: string, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storeLightningNodeApiConnectToNode.');
            }
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling storeLightningNodeApiConnectToNode.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningNodeApiConnectToNode.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning/{cryptoCode}/connect`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ConnectToNodeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a lightning invoice.
         * @summary Create lightning invoice
         * @param {CreateLightningInvoiceRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiCreateInvoice(body: CreateLightningInvoiceRequest, cryptoCode: string, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storeLightningNodeApiCreateInvoice.');
            }
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling storeLightningNodeApiCreateInvoice.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningNodeApiCreateInvoice.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning/{cryptoCode}/invoices`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateLightningInvoiceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View balance of the lightning node
         * @summary Get node balance
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetBalance(cryptoCode: string, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling storeLightningNodeApiGetBalance.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningNodeApiGetBalance.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning/{cryptoCode}/balance`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the current channels of the lightning node
         * @summary Get channels
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetChannels(cryptoCode: string, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling storeLightningNodeApiGetChannels.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningNodeApiGetChannels.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning/{cryptoCode}/channels`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an on-chain deposit address for the lightning node 
         * @summary Get deposit address
         * @param {StoreId} storeId The store ID
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetDepositAddress(storeId: StoreId, cryptoCode: string, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningNodeApiGetDepositAddress.');
            }
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling storeLightningNodeApiGetDepositAddress.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning/{cryptoCode}/address`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View balance histogram of the lightning node
         * @summary Get node balance histogram
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetHistogram(cryptoCode: string, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling storeLightningNodeApiGetHistogram.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningNodeApiGetHistogram.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning/{cryptoCode}/histogram`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the lightning node
         * @summary Get node information
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetInfo(cryptoCode: string, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling storeLightningNodeApiGetInfo.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningNodeApiGetInfo.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning/{cryptoCode}/info`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the requested lightning invoice
         * @summary Get invoice
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {string} id The id of the lightning invoice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetInvoice(cryptoCode: string, storeId: StoreId, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling storeLightningNodeApiGetInvoice.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningNodeApiGetInvoice.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling storeLightningNodeApiGetInvoice.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning/{cryptoCode}/invoices/{id}`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"id"}}`, encodeURIComponent((id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the lightning invoices
         * @summary Get invoices
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {boolean} [pendingOnly] Limit to pending invoices only
         * @param {number} [offsetIndex] The index of an invoice that will be used as the start of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetInvoices(cryptoCode: string, storeId: StoreId, pendingOnly?: boolean, offsetIndex?: number, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling storeLightningNodeApiGetInvoices.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningNodeApiGetInvoices.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning/{cryptoCode}/invoices`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (pendingOnly !== undefined) {
                localVarQueryParameter['pendingOnly'] = pendingOnly;
            }

            if (offsetIndex !== undefined) {
                localVarQueryParameter['offsetIndex'] = offsetIndex;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the requested lightning payment
         * @summary Get payment
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {string} paymentHash The payment hash of the lightning payment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetPayment(cryptoCode: string, storeId: StoreId, paymentHash: string, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling storeLightningNodeApiGetPayment.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningNodeApiGetPayment.');
            }
            // verify required parameter 'paymentHash' is not null or undefined
            if (paymentHash === null || paymentHash === undefined) {
                throw new RequiredError('paymentHash', 'Required parameter paymentHash was null or undefined when calling storeLightningNodeApiGetPayment.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning/{cryptoCode}/payments/{paymentHash}`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"paymentHash"}}`, encodeURIComponent((paymentHash)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the lightning payments
         * @summary Get payments
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {boolean} [includePending] Also include pending payments
         * @param {number} [offsetIndex] The index of an invoice that will be used as the start of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetPayments(cryptoCode: string, storeId: StoreId, includePending?: boolean, offsetIndex?: number, options: any = {}): FetchArgs {
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling storeLightningNodeApiGetPayments.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningNodeApiGetPayments.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning/{cryptoCode}/payments`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (includePending !== undefined) {
                localVarQueryParameter['includePending'] = includePending;
            }

            if (offsetIndex !== undefined) {
                localVarQueryParameter['offsetIndex'] = offsetIndex;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Open a channel with another lightning node. You should connect to that node first.
         * @summary Open channel
         * @param {OpenLightningChannelRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiOpenChannel(body: OpenLightningChannelRequest, cryptoCode: string, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storeLightningNodeApiOpenChannel.');
            }
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling storeLightningNodeApiOpenChannel.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningNodeApiOpenChannel.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning/{cryptoCode}/channels`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OpenLightningChannelRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pay a lightning invoice. In case the payment response times out, the status will be reported as pending and the final status can be resolved using the [Get payment](#operation/StoreLightningNodeApi_GetPayment) endpoint. The default wait time for payment responses is 30 seconds — it might take longer if multiple routes are tried or a hold invoice is getting paid.
         * @summary Pay Lightning Invoice
         * @param {PayLightningInvoiceRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiPayInvoice(body: PayLightningInvoiceRequest, cryptoCode: string, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storeLightningNodeApiPayInvoice.');
            }
            // verify required parameter 'cryptoCode' is not null or undefined
            if (cryptoCode === null || cryptoCode === undefined) {
                throw new RequiredError('cryptoCode', 'Required parameter cryptoCode was null or undefined when calling storeLightningNodeApiPayInvoice.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeLightningNodeApiPayInvoice.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/lightning/{cryptoCode}/invoices/pay`
                .replace(`{${"cryptoCode"}}`, encodeURIComponent((cryptoCode)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PayLightningInvoiceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LightningStoreApi - functional programming interface
 * @export
 */
export const LightningStoreApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Connect to another lightning node.
         * @summary Connect to lightning node
         * @param {ConnectToNodeRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiConnectToNode(body: ConnectToNodeRequest, cryptoCode: string, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LightningStoreApiFetchParamCreator(configuration).storeLightningNodeApiConnectToNode(body, cryptoCode, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a lightning invoice.
         * @summary Create lightning invoice
         * @param {CreateLightningInvoiceRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiCreateInvoice(body: CreateLightningInvoiceRequest, cryptoCode: string, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightningInvoiceData> {
            const localVarFetchArgs = LightningStoreApiFetchParamCreator(configuration).storeLightningNodeApiCreateInvoice(body, cryptoCode, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View balance of the lightning node
         * @summary Get node balance
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetBalance(cryptoCode: string, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightningNodeBalanceData> {
            const localVarFetchArgs = LightningStoreApiFetchParamCreator(configuration).storeLightningNodeApiGetBalance(cryptoCode, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the current channels of the lightning node
         * @summary Get channels
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetChannels(cryptoCode: string, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LightningChannelData>> {
            const localVarFetchArgs = LightningStoreApiFetchParamCreator(configuration).storeLightningNodeApiGetChannels(cryptoCode, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an on-chain deposit address for the lightning node 
         * @summary Get deposit address
         * @param {StoreId} storeId The store ID
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetDepositAddress(storeId: StoreId, cryptoCode: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = LightningStoreApiFetchParamCreator(configuration).storeLightningNodeApiGetDepositAddress(storeId, cryptoCode, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View balance histogram of the lightning node
         * @summary Get node balance histogram
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetHistogram(cryptoCode: string, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HistogramData> {
            const localVarFetchArgs = LightningStoreApiFetchParamCreator(configuration).storeLightningNodeApiGetHistogram(cryptoCode, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the lightning node
         * @summary Get node information
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetInfo(cryptoCode: string, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightningNodeInformationData> {
            const localVarFetchArgs = LightningStoreApiFetchParamCreator(configuration).storeLightningNodeApiGetInfo(cryptoCode, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the requested lightning invoice
         * @summary Get invoice
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {string} id The id of the lightning invoice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetInvoice(cryptoCode: string, storeId: StoreId, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightningInvoiceData> {
            const localVarFetchArgs = LightningStoreApiFetchParamCreator(configuration).storeLightningNodeApiGetInvoice(cryptoCode, storeId, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the lightning invoices
         * @summary Get invoices
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {boolean} [pendingOnly] Limit to pending invoices only
         * @param {number} [offsetIndex] The index of an invoice that will be used as the start of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetInvoices(cryptoCode: string, storeId: StoreId, pendingOnly?: boolean, offsetIndex?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LightningInvoiceData>> {
            const localVarFetchArgs = LightningStoreApiFetchParamCreator(configuration).storeLightningNodeApiGetInvoices(cryptoCode, storeId, pendingOnly, offsetIndex, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the requested lightning payment
         * @summary Get payment
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {string} paymentHash The payment hash of the lightning payment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetPayment(cryptoCode: string, storeId: StoreId, paymentHash: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightningPaymentData> {
            const localVarFetchArgs = LightningStoreApiFetchParamCreator(configuration).storeLightningNodeApiGetPayment(cryptoCode, storeId, paymentHash, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the lightning payments
         * @summary Get payments
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {boolean} [includePending] Also include pending payments
         * @param {number} [offsetIndex] The index of an invoice that will be used as the start of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetPayments(cryptoCode: string, storeId: StoreId, includePending?: boolean, offsetIndex?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LightningPaymentData>> {
            const localVarFetchArgs = LightningStoreApiFetchParamCreator(configuration).storeLightningNodeApiGetPayments(cryptoCode, storeId, includePending, offsetIndex, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Open a channel with another lightning node. You should connect to that node first.
         * @summary Open channel
         * @param {OpenLightningChannelRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiOpenChannel(body: OpenLightningChannelRequest, cryptoCode: string, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LightningStoreApiFetchParamCreator(configuration).storeLightningNodeApiOpenChannel(body, cryptoCode, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Pay a lightning invoice. In case the payment response times out, the status will be reported as pending and the final status can be resolved using the [Get payment](#operation/StoreLightningNodeApi_GetPayment) endpoint. The default wait time for payment responses is 30 seconds — it might take longer if multiple routes are tried or a hold invoice is getting paid.
         * @summary Pay Lightning Invoice
         * @param {PayLightningInvoiceRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiPayInvoice(body: PayLightningInvoiceRequest, cryptoCode: string, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightningPaymentData> {
            const localVarFetchArgs = LightningStoreApiFetchParamCreator(configuration).storeLightningNodeApiPayInvoice(body, cryptoCode, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LightningStoreApi - factory interface
 * @export
 */
export const LightningStoreApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Connect to another lightning node.
         * @summary Connect to lightning node
         * @param {ConnectToNodeRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiConnectToNode(body: ConnectToNodeRequest, cryptoCode: string, storeId: StoreId, options?: any) {
            return LightningStoreApiFp(configuration).storeLightningNodeApiConnectToNode(body, cryptoCode, storeId, options)(fetch, basePath);
        },
        /**
         * Create a lightning invoice.
         * @summary Create lightning invoice
         * @param {CreateLightningInvoiceRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiCreateInvoice(body: CreateLightningInvoiceRequest, cryptoCode: string, storeId: StoreId, options?: any) {
            return LightningStoreApiFp(configuration).storeLightningNodeApiCreateInvoice(body, cryptoCode, storeId, options)(fetch, basePath);
        },
        /**
         * View balance of the lightning node
         * @summary Get node balance
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetBalance(cryptoCode: string, storeId: StoreId, options?: any) {
            return LightningStoreApiFp(configuration).storeLightningNodeApiGetBalance(cryptoCode, storeId, options)(fetch, basePath);
        },
        /**
         * View information about the current channels of the lightning node
         * @summary Get channels
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetChannels(cryptoCode: string, storeId: StoreId, options?: any) {
            return LightningStoreApiFp(configuration).storeLightningNodeApiGetChannels(cryptoCode, storeId, options)(fetch, basePath);
        },
        /**
         * Get an on-chain deposit address for the lightning node 
         * @summary Get deposit address
         * @param {StoreId} storeId The store ID
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetDepositAddress(storeId: StoreId, cryptoCode: string, options?: any) {
            return LightningStoreApiFp(configuration).storeLightningNodeApiGetDepositAddress(storeId, cryptoCode, options)(fetch, basePath);
        },
        /**
         * View balance histogram of the lightning node
         * @summary Get node balance histogram
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetHistogram(cryptoCode: string, storeId: StoreId, options?: any) {
            return LightningStoreApiFp(configuration).storeLightningNodeApiGetHistogram(cryptoCode, storeId, options)(fetch, basePath);
        },
        /**
         * View information about the lightning node
         * @summary Get node information
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetInfo(cryptoCode: string, storeId: StoreId, options?: any) {
            return LightningStoreApiFp(configuration).storeLightningNodeApiGetInfo(cryptoCode, storeId, options)(fetch, basePath);
        },
        /**
         * View information about the requested lightning invoice
         * @summary Get invoice
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {string} id The id of the lightning invoice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetInvoice(cryptoCode: string, storeId: StoreId, id: string, options?: any) {
            return LightningStoreApiFp(configuration).storeLightningNodeApiGetInvoice(cryptoCode, storeId, id, options)(fetch, basePath);
        },
        /**
         * View information about the lightning invoices
         * @summary Get invoices
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {boolean} [pendingOnly] Limit to pending invoices only
         * @param {number} [offsetIndex] The index of an invoice that will be used as the start of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetInvoices(cryptoCode: string, storeId: StoreId, pendingOnly?: boolean, offsetIndex?: number, options?: any) {
            return LightningStoreApiFp(configuration).storeLightningNodeApiGetInvoices(cryptoCode, storeId, pendingOnly, offsetIndex, options)(fetch, basePath);
        },
        /**
         * View information about the requested lightning payment
         * @summary Get payment
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {string} paymentHash The payment hash of the lightning payment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetPayment(cryptoCode: string, storeId: StoreId, paymentHash: string, options?: any) {
            return LightningStoreApiFp(configuration).storeLightningNodeApiGetPayment(cryptoCode, storeId, paymentHash, options)(fetch, basePath);
        },
        /**
         * View information about the lightning payments
         * @summary Get payments
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {boolean} [includePending] Also include pending payments
         * @param {number} [offsetIndex] The index of an invoice that will be used as the start of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiGetPayments(cryptoCode: string, storeId: StoreId, includePending?: boolean, offsetIndex?: number, options?: any) {
            return LightningStoreApiFp(configuration).storeLightningNodeApiGetPayments(cryptoCode, storeId, includePending, offsetIndex, options)(fetch, basePath);
        },
        /**
         * Open a channel with another lightning node. You should connect to that node first.
         * @summary Open channel
         * @param {OpenLightningChannelRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiOpenChannel(body: OpenLightningChannelRequest, cryptoCode: string, storeId: StoreId, options?: any) {
            return LightningStoreApiFp(configuration).storeLightningNodeApiOpenChannel(body, cryptoCode, storeId, options)(fetch, basePath);
        },
        /**
         * Pay a lightning invoice. In case the payment response times out, the status will be reported as pending and the final status can be resolved using the [Get payment](#operation/StoreLightningNodeApi_GetPayment) endpoint. The default wait time for payment responses is 30 seconds — it might take longer if multiple routes are tried or a hold invoice is getting paid.
         * @summary Pay Lightning Invoice
         * @param {PayLightningInvoiceRequest} body 
         * @param {string} cryptoCode The cryptoCode of the lightning-node to query
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeLightningNodeApiPayInvoice(body: PayLightningInvoiceRequest, cryptoCode: string, storeId: StoreId, options?: any) {
            return LightningStoreApiFp(configuration).storeLightningNodeApiPayInvoice(body, cryptoCode, storeId, options)(fetch, basePath);
        },
    };
};

/**
 * LightningStoreApi - object-oriented interface
 * @export
 * @class LightningStoreApi
 * @extends {BaseAPI}
 */
export class LightningStoreApi extends BaseAPI {
    /**
     * Connect to another lightning node.
     * @summary Connect to lightning node
     * @param {ConnectToNodeRequest} body 
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningStoreApi
     */
    public storeLightningNodeApiConnectToNode(body: ConnectToNodeRequest, cryptoCode: string, storeId: StoreId, options?: any) {
        return LightningStoreApiFp(this.configuration).storeLightningNodeApiConnectToNode(body, cryptoCode, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Create a lightning invoice.
     * @summary Create lightning invoice
     * @param {CreateLightningInvoiceRequest} body 
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningStoreApi
     */
    public storeLightningNodeApiCreateInvoice(body: CreateLightningInvoiceRequest, cryptoCode: string, storeId: StoreId, options?: any) {
        return LightningStoreApiFp(this.configuration).storeLightningNodeApiCreateInvoice(body, cryptoCode, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * View balance of the lightning node
     * @summary Get node balance
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningStoreApi
     */
    public storeLightningNodeApiGetBalance(cryptoCode: string, storeId: StoreId, options?: any) {
        return LightningStoreApiFp(this.configuration).storeLightningNodeApiGetBalance(cryptoCode, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the current channels of the lightning node
     * @summary Get channels
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningStoreApi
     */
    public storeLightningNodeApiGetChannels(cryptoCode: string, storeId: StoreId, options?: any) {
        return LightningStoreApiFp(this.configuration).storeLightningNodeApiGetChannels(cryptoCode, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Get an on-chain deposit address for the lightning node 
     * @summary Get deposit address
     * @param {StoreId} storeId The store ID
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningStoreApi
     */
    public storeLightningNodeApiGetDepositAddress(storeId: StoreId, cryptoCode: string, options?: any) {
        return LightningStoreApiFp(this.configuration).storeLightningNodeApiGetDepositAddress(storeId, cryptoCode, options)(this.fetch, this.basePath);
    }

    /**
     * View balance histogram of the lightning node
     * @summary Get node balance histogram
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningStoreApi
     */
    public storeLightningNodeApiGetHistogram(cryptoCode: string, storeId: StoreId, options?: any) {
        return LightningStoreApiFp(this.configuration).storeLightningNodeApiGetHistogram(cryptoCode, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the lightning node
     * @summary Get node information
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningStoreApi
     */
    public storeLightningNodeApiGetInfo(cryptoCode: string, storeId: StoreId, options?: any) {
        return LightningStoreApiFp(this.configuration).storeLightningNodeApiGetInfo(cryptoCode, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the requested lightning invoice
     * @summary Get invoice
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {StoreId} storeId The store ID
     * @param {string} id The id of the lightning invoice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningStoreApi
     */
    public storeLightningNodeApiGetInvoice(cryptoCode: string, storeId: StoreId, id: string, options?: any) {
        return LightningStoreApiFp(this.configuration).storeLightningNodeApiGetInvoice(cryptoCode, storeId, id, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the lightning invoices
     * @summary Get invoices
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {StoreId} storeId The store ID
     * @param {boolean} [pendingOnly] Limit to pending invoices only
     * @param {number} [offsetIndex] The index of an invoice that will be used as the start of the list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningStoreApi
     */
    public storeLightningNodeApiGetInvoices(cryptoCode: string, storeId: StoreId, pendingOnly?: boolean, offsetIndex?: number, options?: any) {
        return LightningStoreApiFp(this.configuration).storeLightningNodeApiGetInvoices(cryptoCode, storeId, pendingOnly, offsetIndex, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the requested lightning payment
     * @summary Get payment
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {StoreId} storeId The store ID
     * @param {string} paymentHash The payment hash of the lightning payment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningStoreApi
     */
    public storeLightningNodeApiGetPayment(cryptoCode: string, storeId: StoreId, paymentHash: string, options?: any) {
        return LightningStoreApiFp(this.configuration).storeLightningNodeApiGetPayment(cryptoCode, storeId, paymentHash, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the lightning payments
     * @summary Get payments
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {StoreId} storeId The store ID
     * @param {boolean} [includePending] Also include pending payments
     * @param {number} [offsetIndex] The index of an invoice that will be used as the start of the list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningStoreApi
     */
    public storeLightningNodeApiGetPayments(cryptoCode: string, storeId: StoreId, includePending?: boolean, offsetIndex?: number, options?: any) {
        return LightningStoreApiFp(this.configuration).storeLightningNodeApiGetPayments(cryptoCode, storeId, includePending, offsetIndex, options)(this.fetch, this.basePath);
    }

    /**
     * Open a channel with another lightning node. You should connect to that node first.
     * @summary Open channel
     * @param {OpenLightningChannelRequest} body 
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningStoreApi
     */
    public storeLightningNodeApiOpenChannel(body: OpenLightningChannelRequest, cryptoCode: string, storeId: StoreId, options?: any) {
        return LightningStoreApiFp(this.configuration).storeLightningNodeApiOpenChannel(body, cryptoCode, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Pay a lightning invoice. In case the payment response times out, the status will be reported as pending and the final status can be resolved using the [Get payment](#operation/StoreLightningNodeApi_GetPayment) endpoint. The default wait time for payment responses is 30 seconds — it might take longer if multiple routes are tried or a hold invoice is getting paid.
     * @summary Pay Lightning Invoice
     * @param {PayLightningInvoiceRequest} body 
     * @param {string} cryptoCode The cryptoCode of the lightning-node to query
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LightningStoreApi
     */
    public storeLightningNodeApiPayInvoice(body: PayLightningInvoiceRequest, cryptoCode: string, storeId: StoreId, options?: any) {
        return LightningStoreApiFp(this.configuration).storeLightningNodeApiPayInvoice(body, cryptoCode, storeId, options)(this.fetch, this.basePath);
    }

}
/**
 * MiscelleneousApi - fetch parameter creator
 * @export
 */
export const MiscelleneousApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * View available rate providers that you can use in stores
         * @summary Get available rate sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateSources(options: any = {}): FetchArgs {
            const localVarPath = `/misc/rate-sources`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View the checkout page of an invoice
         * @summary Invoice checkout
         * @param {string} invoiceId The invoice ID
         * @param {string} [lang] The preferred language of the checkout page. You can use \&quot;auto\&quot; to use the language of the customer&#x27;s browser or see the list of language codes with [this operation](#operation/langCodes).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceCheckout(invoiceId: string, lang?: string, options: any = {}): FetchArgs {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId', 'Required parameter invoiceId was null or undefined when calling invoiceCheckout.');
            }
            const localVarPath = `/i/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent((invoiceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The supported language codes
         * @summary Language codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        langCodes(options: any = {}): FetchArgs {
            const localVarPath = `/misc/lang`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The metadata of available permissions
         * @summary Permissions metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsMetadata(options: any = {}): FetchArgs {
            const localVarPath = `/misc/permissions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscelleneousApi - functional programming interface
 * @export
 */
export const MiscelleneousApiFp = function (configuration?: Configuration) {
    return {
        /**
         * View available rate providers that you can use in stores
         * @summary Get available rate sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateSources(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse200>> {
            const localVarFetchArgs = MiscelleneousApiFetchParamCreator(configuration).getRateSources(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View the checkout page of an invoice
         * @summary Invoice checkout
         * @param {string} invoiceId The invoice ID
         * @param {string} [lang] The preferred language of the checkout page. You can use \&quot;auto\&quot; to use the language of the customer&#x27;s browser or see the list of language codes with [this operation](#operation/langCodes).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceCheckout(invoiceId: string, lang?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MiscelleneousApiFetchParamCreator(configuration).invoiceCheckout(invoiceId, lang, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The supported language codes
         * @summary Language codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        langCodes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2002>> {
            const localVarFetchArgs = MiscelleneousApiFetchParamCreator(configuration).langCodes(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The metadata of available permissions
         * @summary Permissions metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsMetadata(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2001>> {
            const localVarFetchArgs = MiscelleneousApiFetchParamCreator(configuration).permissionsMetadata(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MiscelleneousApi - factory interface
 * @export
 */
export const MiscelleneousApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * View available rate providers that you can use in stores
         * @summary Get available rate sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateSources(options?: any) {
            return MiscelleneousApiFp(configuration).getRateSources(options)(fetch, basePath);
        },
        /**
         * View the checkout page of an invoice
         * @summary Invoice checkout
         * @param {string} invoiceId The invoice ID
         * @param {string} [lang] The preferred language of the checkout page. You can use \&quot;auto\&quot; to use the language of the customer&#x27;s browser or see the list of language codes with [this operation](#operation/langCodes).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceCheckout(invoiceId: string, lang?: string, options?: any) {
            return MiscelleneousApiFp(configuration).invoiceCheckout(invoiceId, lang, options)(fetch, basePath);
        },
        /**
         * The supported language codes
         * @summary Language codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        langCodes(options?: any) {
            return MiscelleneousApiFp(configuration).langCodes(options)(fetch, basePath);
        },
        /**
         * The metadata of available permissions
         * @summary Permissions metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permissionsMetadata(options?: any) {
            return MiscelleneousApiFp(configuration).permissionsMetadata(options)(fetch, basePath);
        },
    };
};

/**
 * MiscelleneousApi - object-oriented interface
 * @export
 * @class MiscelleneousApi
 * @extends {BaseAPI}
 */
export class MiscelleneousApi extends BaseAPI {
    /**
     * View available rate providers that you can use in stores
     * @summary Get available rate sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscelleneousApi
     */
    public getRateSources(options?: any) {
        return MiscelleneousApiFp(this.configuration).getRateSources(options)(this.fetch, this.basePath);
    }

    /**
     * View the checkout page of an invoice
     * @summary Invoice checkout
     * @param {string} invoiceId The invoice ID
     * @param {string} [lang] The preferred language of the checkout page. You can use \&quot;auto\&quot; to use the language of the customer&#x27;s browser or see the list of language codes with [this operation](#operation/langCodes).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscelleneousApi
     */
    public invoiceCheckout(invoiceId: string, lang?: string, options?: any) {
        return MiscelleneousApiFp(this.configuration).invoiceCheckout(invoiceId, lang, options)(this.fetch, this.basePath);
    }

    /**
     * The supported language codes
     * @summary Language codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscelleneousApi
     */
    public langCodes(options?: any) {
        return MiscelleneousApiFp(this.configuration).langCodes(options)(this.fetch, this.basePath);
    }

    /**
     * The metadata of available permissions
     * @summary Permissions metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscelleneousApi
     */
    public permissionsMetadata(options?: any) {
        return MiscelleneousApiFp(this.configuration).permissionsMetadata(options)(this.fetch, this.basePath);
    }

}
/**
 * NotificationsCurrentUserApi - fetch parameter creator
 * @export
 */
export const NotificationsCurrentUserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes the specified notification.
         * @summary Remove Notification
         * @param {string} id The notification to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsDeleteNotification(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling notificationsDeleteNotification.');
            }
            const localVarPath = `/api/v1/users/me/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent((id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the specified notification
         * @summary Get notification
         * @param {string} id The notification to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetNotification(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling notificationsGetNotification.');
            }
            const localVarPath = `/api/v1/users/me/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent((id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about your notification settings
         * @summary Get notification settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetNotificationSettings(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users/me/notification-settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View current user's notifications
         * @summary Get notifications
         * @param {Array<string>} [storeId] Array of store ids to fetch the notifications for
         * @param {number} [take] Number of records returned in response
         * @param {number} [skip] Number of records to skip
         * @param {string} [seen] filter by seen notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetNotifications(storeId?: Array<string>, take?: number, skip?: number, seen?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users/me/notifications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (storeId) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (seen !== undefined) {
                localVarQueryParameter['seen'] = seen;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the notification
         * @summary Update notification
         * @param {UpdateNotification} body 
         * @param {string} id The notification to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsUpdateNotification(body: UpdateNotification, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling notificationsUpdateNotification.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling notificationsUpdateNotification.');
            }
            const localVarPath = `/api/v1/users/me/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent((id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateNotification" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the current user's notification settings
         * @summary Update notification settings
         * @param {UpdateNotificationSettingsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsUpdateNotificationSettings(body: UpdateNotificationSettingsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling notificationsUpdateNotificationSettings.');
            }
            const localVarPath = `/api/v1/users/me/notification-settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateNotificationSettingsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsCurrentUserApi - functional programming interface
 * @export
 */
export const NotificationsCurrentUserApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Removes the specified notification.
         * @summary Remove Notification
         * @param {string} id The notification to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsDeleteNotification(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NotificationsCurrentUserApiFetchParamCreator(configuration).notificationsDeleteNotification(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the specified notification
         * @summary Get notification
         * @param {string} id The notification to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetNotification(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NotificationData> {
            const localVarFetchArgs = NotificationsCurrentUserApiFetchParamCreator(configuration).notificationsGetNotification(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about your notification settings
         * @summary Get notification settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetNotificationSettings(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NotificationSettingsData> {
            const localVarFetchArgs = NotificationsCurrentUserApiFetchParamCreator(configuration).notificationsGetNotificationSettings(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View current user's notifications
         * @summary Get notifications
         * @param {Array<string>} [storeId] Array of store ids to fetch the notifications for
         * @param {number} [take] Number of records returned in response
         * @param {number} [skip] Number of records to skip
         * @param {string} [seen] filter by seen notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetNotifications(storeId?: Array<string>, take?: number, skip?: number, seen?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NotificationData> {
            const localVarFetchArgs = NotificationsCurrentUserApiFetchParamCreator(configuration).notificationsGetNotifications(storeId, take, skip, seen, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the notification
         * @summary Update notification
         * @param {UpdateNotification} body 
         * @param {string} id The notification to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsUpdateNotification(body: UpdateNotification, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NotificationData> {
            const localVarFetchArgs = NotificationsCurrentUserApiFetchParamCreator(configuration).notificationsUpdateNotification(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the current user's notification settings
         * @summary Update notification settings
         * @param {UpdateNotificationSettingsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsUpdateNotificationSettings(body: UpdateNotificationSettingsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NotificationSettingsData> {
            const localVarFetchArgs = NotificationsCurrentUserApiFetchParamCreator(configuration).notificationsUpdateNotificationSettings(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotificationsCurrentUserApi - factory interface
 * @export
 */
export const NotificationsCurrentUserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Removes the specified notification.
         * @summary Remove Notification
         * @param {string} id The notification to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsDeleteNotification(id: string, options?: any) {
            return NotificationsCurrentUserApiFp(configuration).notificationsDeleteNotification(id, options)(fetch, basePath);
        },
        /**
         * View information about the specified notification
         * @summary Get notification
         * @param {string} id The notification to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetNotification(id: string, options?: any) {
            return NotificationsCurrentUserApiFp(configuration).notificationsGetNotification(id, options)(fetch, basePath);
        },
        /**
         * View information about your notification settings
         * @summary Get notification settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetNotificationSettings(options?: any) {
            return NotificationsCurrentUserApiFp(configuration).notificationsGetNotificationSettings(options)(fetch, basePath);
        },
        /**
         * View current user's notifications
         * @summary Get notifications
         * @param {Array<string>} [storeId] Array of store ids to fetch the notifications for
         * @param {number} [take] Number of records returned in response
         * @param {number} [skip] Number of records to skip
         * @param {string} [seen] filter by seen notifications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsGetNotifications(storeId?: Array<string>, take?: number, skip?: number, seen?: string, options?: any) {
            return NotificationsCurrentUserApiFp(configuration).notificationsGetNotifications(storeId, take, skip, seen, options)(fetch, basePath);
        },
        /**
         * Updates the notification
         * @summary Update notification
         * @param {UpdateNotification} body 
         * @param {string} id The notification to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsUpdateNotification(body: UpdateNotification, id: string, options?: any) {
            return NotificationsCurrentUserApiFp(configuration).notificationsUpdateNotification(body, id, options)(fetch, basePath);
        },
        /**
         * Updates the current user's notification settings
         * @summary Update notification settings
         * @param {UpdateNotificationSettingsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsUpdateNotificationSettings(body: UpdateNotificationSettingsRequest, options?: any) {
            return NotificationsCurrentUserApiFp(configuration).notificationsUpdateNotificationSettings(body, options)(fetch, basePath);
        },
    };
};

/**
 * NotificationsCurrentUserApi - object-oriented interface
 * @export
 * @class NotificationsCurrentUserApi
 * @extends {BaseAPI}
 */
export class NotificationsCurrentUserApi extends BaseAPI {
    /**
     * Removes the specified notification.
     * @summary Remove Notification
     * @param {string} id The notification to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsCurrentUserApi
     */
    public notificationsDeleteNotification(id: string, options?: any) {
        return NotificationsCurrentUserApiFp(this.configuration).notificationsDeleteNotification(id, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the specified notification
     * @summary Get notification
     * @param {string} id The notification to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsCurrentUserApi
     */
    public notificationsGetNotification(id: string, options?: any) {
        return NotificationsCurrentUserApiFp(this.configuration).notificationsGetNotification(id, options)(this.fetch, this.basePath);
    }

    /**
     * View information about your notification settings
     * @summary Get notification settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsCurrentUserApi
     */
    public notificationsGetNotificationSettings(options?: any) {
        return NotificationsCurrentUserApiFp(this.configuration).notificationsGetNotificationSettings(options)(this.fetch, this.basePath);
    }

    /**
     * View current user's notifications
     * @summary Get notifications
     * @param {Array<string>} [storeId] Array of store ids to fetch the notifications for
     * @param {number} [take] Number of records returned in response
     * @param {number} [skip] Number of records to skip
     * @param {string} [seen] filter by seen notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsCurrentUserApi
     */
    public notificationsGetNotifications(storeId?: Array<string>, take?: number, skip?: number, seen?: string, options?: any) {
        return NotificationsCurrentUserApiFp(this.configuration).notificationsGetNotifications(storeId, take, skip, seen, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the notification
     * @summary Update notification
     * @param {UpdateNotification} body 
     * @param {string} id The notification to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsCurrentUserApi
     */
    public notificationsUpdateNotification(body: UpdateNotification, id: string, options?: any) {
        return NotificationsCurrentUserApiFp(this.configuration).notificationsUpdateNotification(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the current user's notification settings
     * @summary Update notification settings
     * @param {UpdateNotificationSettingsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsCurrentUserApi
     */
    public notificationsUpdateNotificationSettings(body: UpdateNotificationSettingsRequest, options?: any) {
        return NotificationsCurrentUserApiFp(this.configuration).notificationsUpdateNotificationSettings(body, options)(this.fetch, this.basePath);
    }

}
/**
 * PaymentRequestsApi - fetch parameter creator
 * @export
 */
export const PaymentRequestsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archives the specified payment request.
         * @summary Archive payment request
         * @param {StoreId} storeId The store ID
         * @param {string} paymentRequestId The payment request to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsArchivePaymentRequest(storeId: StoreId, paymentRequestId: string, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling paymentRequestsArchivePaymentRequest.');
            }
            // verify required parameter 'paymentRequestId' is not null or undefined
            if (paymentRequestId === null || paymentRequestId === undefined) {
                throw new RequiredError('paymentRequestId', 'Required parameter paymentRequestId was null or undefined when calling paymentRequestsArchivePaymentRequest.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-requests/{paymentRequestId}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"paymentRequestId"}}`, encodeURIComponent((paymentRequestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new payment request
         * @summary Create a new payment request
         * @param {PaymentRequestBaseData} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsCreatePaymentRequest(body: PaymentRequestBaseData, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling paymentRequestsCreatePaymentRequest.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling paymentRequestsCreatePaymentRequest.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-requests`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentRequestBaseData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the specified payment request
         * @summary Get payment request
         * @param {StoreId} storeId The store ID
         * @param {string} paymentRequestId The payment request to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsGetPaymentRequest(storeId: StoreId, paymentRequestId: string, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling paymentRequestsGetPaymentRequest.');
            }
            // verify required parameter 'paymentRequestId' is not null or undefined
            if (paymentRequestId === null || paymentRequestId === undefined) {
                throw new RequiredError('paymentRequestId', 'Required parameter paymentRequestId was null or undefined when calling paymentRequestsGetPaymentRequest.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-requests/{paymentRequestId}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"paymentRequestId"}}`, encodeURIComponent((paymentRequestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the existing payment requests
         * @summary Get payment requests
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsGetPaymentRequests(storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling paymentRequestsGetPaymentRequests.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-requests`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new invoice for the payment request, or reuse an existing one
         * @summary Create a new invoice for the payment request
         * @param {StoreId} storeId The store ID
         * @param {string} paymentRequestId The payment request to create
         * @param {PaymentRequestIdPayBody} [body] Invoice creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsPay(storeId: StoreId, paymentRequestId: string, body?: PaymentRequestIdPayBody, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling paymentRequestsPay.');
            }
            // verify required parameter 'paymentRequestId' is not null or undefined
            if (paymentRequestId === null || paymentRequestId === undefined) {
                throw new RequiredError('paymentRequestId', 'Required parameter paymentRequestId was null or undefined when calling paymentRequestsPay.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-requests/{paymentRequestId}/pay`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"paymentRequestId"}}`, encodeURIComponent((paymentRequestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentRequestIdPayBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a payment request
         * @summary Update payment request
         * @param {PaymentRequestBaseData} body 
         * @param {StoreId} storeId The store ID
         * @param {string} paymentRequestId The payment request to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsUpdatePaymentRequest(body: PaymentRequestBaseData, storeId: StoreId, paymentRequestId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling paymentRequestsUpdatePaymentRequest.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling paymentRequestsUpdatePaymentRequest.');
            }
            // verify required parameter 'paymentRequestId' is not null or undefined
            if (paymentRequestId === null || paymentRequestId === undefined) {
                throw new RequiredError('paymentRequestId', 'Required parameter paymentRequestId was null or undefined when calling paymentRequestsUpdatePaymentRequest.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-requests/{paymentRequestId}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"paymentRequestId"}}`, encodeURIComponent((paymentRequestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentRequestBaseData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentRequestsApi - functional programming interface
 * @export
 */
export const PaymentRequestsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Archives the specified payment request.
         * @summary Archive payment request
         * @param {StoreId} storeId The store ID
         * @param {string} paymentRequestId The payment request to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsArchivePaymentRequest(storeId: StoreId, paymentRequestId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PaymentRequestsApiFetchParamCreator(configuration).paymentRequestsArchivePaymentRequest(storeId, paymentRequestId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new payment request
         * @summary Create a new payment request
         * @param {PaymentRequestBaseData} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsCreatePaymentRequest(body: PaymentRequestBaseData, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentRequestData> {
            const localVarFetchArgs = PaymentRequestsApiFetchParamCreator(configuration).paymentRequestsCreatePaymentRequest(body, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the specified payment request
         * @summary Get payment request
         * @param {StoreId} storeId The store ID
         * @param {string} paymentRequestId The payment request to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsGetPaymentRequest(storeId: StoreId, paymentRequestId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentRequestData> {
            const localVarFetchArgs = PaymentRequestsApiFetchParamCreator(configuration).paymentRequestsGetPaymentRequest(storeId, paymentRequestId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the existing payment requests
         * @summary Get payment requests
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsGetPaymentRequests(storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentRequestDataList> {
            const localVarFetchArgs = PaymentRequestsApiFetchParamCreator(configuration).paymentRequestsGetPaymentRequests(storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new invoice for the payment request, or reuse an existing one
         * @summary Create a new invoice for the payment request
         * @param {StoreId} storeId The store ID
         * @param {string} paymentRequestId The payment request to create
         * @param {PaymentRequestIdPayBody} [body] Invoice creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsPay(storeId: StoreId, paymentRequestId: string, body?: PaymentRequestIdPayBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvoiceData> {
            const localVarFetchArgs = PaymentRequestsApiFetchParamCreator(configuration).paymentRequestsPay(storeId, paymentRequestId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a payment request
         * @summary Update payment request
         * @param {PaymentRequestBaseData} body 
         * @param {StoreId} storeId The store ID
         * @param {string} paymentRequestId The payment request to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsUpdatePaymentRequest(body: PaymentRequestBaseData, storeId: StoreId, paymentRequestId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentRequestData> {
            const localVarFetchArgs = PaymentRequestsApiFetchParamCreator(configuration).paymentRequestsUpdatePaymentRequest(body, storeId, paymentRequestId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PaymentRequestsApi - factory interface
 * @export
 */
export const PaymentRequestsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Archives the specified payment request.
         * @summary Archive payment request
         * @param {StoreId} storeId The store ID
         * @param {string} paymentRequestId The payment request to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsArchivePaymentRequest(storeId: StoreId, paymentRequestId: string, options?: any) {
            return PaymentRequestsApiFp(configuration).paymentRequestsArchivePaymentRequest(storeId, paymentRequestId, options)(fetch, basePath);
        },
        /**
         * Create a new payment request
         * @summary Create a new payment request
         * @param {PaymentRequestBaseData} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsCreatePaymentRequest(body: PaymentRequestBaseData, storeId: StoreId, options?: any) {
            return PaymentRequestsApiFp(configuration).paymentRequestsCreatePaymentRequest(body, storeId, options)(fetch, basePath);
        },
        /**
         * View information about the specified payment request
         * @summary Get payment request
         * @param {StoreId} storeId The store ID
         * @param {string} paymentRequestId The payment request to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsGetPaymentRequest(storeId: StoreId, paymentRequestId: string, options?: any) {
            return PaymentRequestsApiFp(configuration).paymentRequestsGetPaymentRequest(storeId, paymentRequestId, options)(fetch, basePath);
        },
        /**
         * View information about the existing payment requests
         * @summary Get payment requests
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsGetPaymentRequests(storeId: StoreId, options?: any) {
            return PaymentRequestsApiFp(configuration).paymentRequestsGetPaymentRequests(storeId, options)(fetch, basePath);
        },
        /**
         * Create a new invoice for the payment request, or reuse an existing one
         * @summary Create a new invoice for the payment request
         * @param {StoreId} storeId The store ID
         * @param {string} paymentRequestId The payment request to create
         * @param {PaymentRequestIdPayBody} [body] Invoice creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsPay(storeId: StoreId, paymentRequestId: string, body?: PaymentRequestIdPayBody, options?: any) {
            return PaymentRequestsApiFp(configuration).paymentRequestsPay(storeId, paymentRequestId, body, options)(fetch, basePath);
        },
        /**
         * Update a payment request
         * @summary Update payment request
         * @param {PaymentRequestBaseData} body 
         * @param {StoreId} storeId The store ID
         * @param {string} paymentRequestId The payment request to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentRequestsUpdatePaymentRequest(body: PaymentRequestBaseData, storeId: StoreId, paymentRequestId: string, options?: any) {
            return PaymentRequestsApiFp(configuration).paymentRequestsUpdatePaymentRequest(body, storeId, paymentRequestId, options)(fetch, basePath);
        },
    };
};

/**
 * PaymentRequestsApi - object-oriented interface
 * @export
 * @class PaymentRequestsApi
 * @extends {BaseAPI}
 */
export class PaymentRequestsApi extends BaseAPI {
    /**
     * Archives the specified payment request.
     * @summary Archive payment request
     * @param {StoreId} storeId The store ID
     * @param {string} paymentRequestId The payment request to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentRequestsApi
     */
    public paymentRequestsArchivePaymentRequest(storeId: StoreId, paymentRequestId: string, options?: any) {
        return PaymentRequestsApiFp(this.configuration).paymentRequestsArchivePaymentRequest(storeId, paymentRequestId, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new payment request
     * @summary Create a new payment request
     * @param {PaymentRequestBaseData} body 
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentRequestsApi
     */
    public paymentRequestsCreatePaymentRequest(body: PaymentRequestBaseData, storeId: StoreId, options?: any) {
        return PaymentRequestsApiFp(this.configuration).paymentRequestsCreatePaymentRequest(body, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the specified payment request
     * @summary Get payment request
     * @param {StoreId} storeId The store ID
     * @param {string} paymentRequestId The payment request to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentRequestsApi
     */
    public paymentRequestsGetPaymentRequest(storeId: StoreId, paymentRequestId: string, options?: any) {
        return PaymentRequestsApiFp(this.configuration).paymentRequestsGetPaymentRequest(storeId, paymentRequestId, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the existing payment requests
     * @summary Get payment requests
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentRequestsApi
     */
    public paymentRequestsGetPaymentRequests(storeId: StoreId, options?: any) {
        return PaymentRequestsApiFp(this.configuration).paymentRequestsGetPaymentRequests(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new invoice for the payment request, or reuse an existing one
     * @summary Create a new invoice for the payment request
     * @param {StoreId} storeId The store ID
     * @param {string} paymentRequestId The payment request to create
     * @param {PaymentRequestIdPayBody} [body] Invoice creation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentRequestsApi
     */
    public paymentRequestsPay(storeId: StoreId, paymentRequestId: string, body?: PaymentRequestIdPayBody, options?: any) {
        return PaymentRequestsApiFp(this.configuration).paymentRequestsPay(storeId, paymentRequestId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update a payment request
     * @summary Update payment request
     * @param {PaymentRequestBaseData} body 
     * @param {StoreId} storeId The store ID
     * @param {string} paymentRequestId The payment request to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentRequestsApi
     */
    public paymentRequestsUpdatePaymentRequest(body: PaymentRequestBaseData, storeId: StoreId, paymentRequestId: string, options?: any) {
        return PaymentRequestsApiFp(this.configuration).paymentRequestsUpdatePaymentRequest(body, storeId, paymentRequestId, options)(this.fetch, this.basePath);
    }

}
/**
 * PayoutProcessorsApi - fetch parameter creator
 * @export
 */
export const PayoutProcessorsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get payout processors available in this instance
         * @summary Get payout processors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutProcessorsGetPayoutProcessors(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/payout-processors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayoutProcessorsApi - functional programming interface
 * @export
 */
export const PayoutProcessorsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Get payout processors available in this instance
         * @summary Get payout processors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutProcessorsGetPayoutProcessors(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PayoutProcessorData>> {
            const localVarFetchArgs = PayoutProcessorsApiFetchParamCreator(configuration).payoutProcessorsGetPayoutProcessors(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PayoutProcessorsApi - factory interface
 * @export
 */
export const PayoutProcessorsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get payout processors available in this instance
         * @summary Get payout processors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutProcessorsGetPayoutProcessors(options?: any) {
            return PayoutProcessorsApiFp(configuration).payoutProcessorsGetPayoutProcessors(options)(fetch, basePath);
        },
    };
};

/**
 * PayoutProcessorsApi - object-oriented interface
 * @export
 * @class PayoutProcessorsApi
 * @extends {BaseAPI}
 */
export class PayoutProcessorsApi extends BaseAPI {
    /**
     * Get payout processors available in this instance
     * @summary Get payout processors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PayoutProcessorsApi
     */
    public payoutProcessorsGetPayoutProcessors(options?: any) {
        return PayoutProcessorsApiFp(this.configuration).payoutProcessorsGetPayoutProcessors(options)(this.fetch, this.basePath);
    }

}
/**
 * PointOfSaleApi - fetch parameter creator
 * @export
 */
export const PointOfSaleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns POS app data
         * @summary Get Point of Sale app data
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetPointOfSaleApp(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId', 'Required parameter appId was null or undefined when calling appsGetPointOfSaleApp.');
            }
            const localVarPath = `/api/v1/apps/pos/{appId}`
                .replace(`{${"appId"}}`, encodeURIComponent((appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PointOfSaleApi - functional programming interface
 * @export
 */
export const PointOfSaleApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Returns POS app data
         * @summary Get Point of Sale app data
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetPointOfSaleApp(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PointOfSaleAppData> {
            const localVarFetchArgs = PointOfSaleApiFetchParamCreator(configuration).appsGetPointOfSaleApp(appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PointOfSaleApi - factory interface
 * @export
 */
export const PointOfSaleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns POS app data
         * @summary Get Point of Sale app data
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGetPointOfSaleApp(appId: string, options?: any) {
            return PointOfSaleApiFp(configuration).appsGetPointOfSaleApp(appId, options)(fetch, basePath);
        },
    };
};

/**
 * PointOfSaleApi - object-oriented interface
 * @export
 * @class PointOfSaleApi
 * @extends {BaseAPI}
 */
export class PointOfSaleApi extends BaseAPI {
    /**
     * Returns POS app data
     * @summary Get Point of Sale app data
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointOfSaleApi
     */
    public appsGetPointOfSaleApp(appId: string, options?: any) {
        return PointOfSaleApiFp(this.configuration).appsGetPointOfSaleApp(appId, options)(this.fetch, this.basePath);
    }

}
/**
 * PullPaymentsManagementApi - fetch parameter creator
 * @export
 */
export const PullPaymentsManagementApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archive this pull payment (Will cancel all payouts awaiting for payment)
         * @summary Archive a pull payment
         * @param {StoreId} storeId The store ID
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsArchivePullPayment(storeId: StoreId, pullPaymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling pullPaymentsArchivePullPayment.');
            }
            // verify required parameter 'pullPaymentId' is not null or undefined
            if (pullPaymentId === null || pullPaymentId === undefined) {
                throw new RequiredError('pullPaymentId', 'Required parameter pullPaymentId was null or undefined when calling pullPaymentsArchivePullPayment.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/pull-payments/{pullPaymentId}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"pullPaymentId"}}`, encodeURIComponent((pullPaymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A pull payment allows its receiver to ask for payouts up to `amount` of `currency` every `period`.
         * @summary Create a new pull payment
         * @param {StoreId} storeId The store ID
         * @param {StoreIdPullpaymentsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsCreatePullPayment(storeId: StoreId, body?: StoreIdPullpaymentsBody, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling pullPaymentsCreatePullPayment.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/pull-payments`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StoreIdPullpaymentsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the pull payments of a store
         * @summary Get store's pull payments
         * @param {StoreId} storeId The store ID
         * @param {boolean} [includeArchived] Whether this should list archived pull payments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPullPayments(storeId: StoreId, includeArchived?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling pullPaymentsGetPullPayments.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/pull-payments`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (includeArchived !== undefined) {
                localVarQueryParameter['includeArchived'] = includeArchived;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PullPaymentsManagementApi - functional programming interface
 * @export
 */
export const PullPaymentsManagementApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Archive this pull payment (Will cancel all payouts awaiting for payment)
         * @summary Archive a pull payment
         * @param {StoreId} storeId The store ID
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsArchivePullPayment(storeId: StoreId, pullPaymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PullPaymentsManagementApiFetchParamCreator(configuration).pullPaymentsArchivePullPayment(storeId, pullPaymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A pull payment allows its receiver to ask for payouts up to `amount` of `currency` every `period`.
         * @summary Create a new pull payment
         * @param {StoreId} storeId The store ID
         * @param {StoreIdPullpaymentsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsCreatePullPayment(storeId: StoreId, body?: StoreIdPullpaymentsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PullPaymentData> {
            const localVarFetchArgs = PullPaymentsManagementApiFetchParamCreator(configuration).pullPaymentsCreatePullPayment(storeId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the pull payments of a store
         * @summary Get store's pull payments
         * @param {StoreId} storeId The store ID
         * @param {boolean} [includeArchived] Whether this should list archived pull payments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPullPayments(storeId: StoreId, includeArchived?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PullPaymentDataList> {
            const localVarFetchArgs = PullPaymentsManagementApiFetchParamCreator(configuration).pullPaymentsGetPullPayments(storeId, includeArchived, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PullPaymentsManagementApi - factory interface
 * @export
 */
export const PullPaymentsManagementApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Archive this pull payment (Will cancel all payouts awaiting for payment)
         * @summary Archive a pull payment
         * @param {StoreId} storeId The store ID
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsArchivePullPayment(storeId: StoreId, pullPaymentId: string, options?: any) {
            return PullPaymentsManagementApiFp(configuration).pullPaymentsArchivePullPayment(storeId, pullPaymentId, options)(fetch, basePath);
        },
        /**
         * A pull payment allows its receiver to ask for payouts up to `amount` of `currency` every `period`.
         * @summary Create a new pull payment
         * @param {StoreId} storeId The store ID
         * @param {StoreIdPullpaymentsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsCreatePullPayment(storeId: StoreId, body?: StoreIdPullpaymentsBody, options?: any) {
            return PullPaymentsManagementApiFp(configuration).pullPaymentsCreatePullPayment(storeId, body, options)(fetch, basePath);
        },
        /**
         * Get the pull payments of a store
         * @summary Get store's pull payments
         * @param {StoreId} storeId The store ID
         * @param {boolean} [includeArchived] Whether this should list archived pull payments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPullPayments(storeId: StoreId, includeArchived?: boolean, options?: any) {
            return PullPaymentsManagementApiFp(configuration).pullPaymentsGetPullPayments(storeId, includeArchived, options)(fetch, basePath);
        },
    };
};

/**
 * PullPaymentsManagementApi - object-oriented interface
 * @export
 * @class PullPaymentsManagementApi
 * @extends {BaseAPI}
 */
export class PullPaymentsManagementApi extends BaseAPI {
    /**
     * Archive this pull payment (Will cancel all payouts awaiting for payment)
     * @summary Archive a pull payment
     * @param {StoreId} storeId The store ID
     * @param {string} pullPaymentId The ID of the pull payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullPaymentsManagementApi
     */
    public pullPaymentsArchivePullPayment(storeId: StoreId, pullPaymentId: string, options?: any) {
        return PullPaymentsManagementApiFp(this.configuration).pullPaymentsArchivePullPayment(storeId, pullPaymentId, options)(this.fetch, this.basePath);
    }

    /**
     * A pull payment allows its receiver to ask for payouts up to `amount` of `currency` every `period`.
     * @summary Create a new pull payment
     * @param {StoreId} storeId The store ID
     * @param {StoreIdPullpaymentsBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullPaymentsManagementApi
     */
    public pullPaymentsCreatePullPayment(storeId: StoreId, body?: StoreIdPullpaymentsBody, options?: any) {
        return PullPaymentsManagementApiFp(this.configuration).pullPaymentsCreatePullPayment(storeId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Get the pull payments of a store
     * @summary Get store's pull payments
     * @param {StoreId} storeId The store ID
     * @param {boolean} [includeArchived] Whether this should list archived pull payments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullPaymentsManagementApi
     */
    public pullPaymentsGetPullPayments(storeId: StoreId, includeArchived?: boolean, options?: any) {
        return PullPaymentsManagementApiFp(this.configuration).pullPaymentsGetPullPayments(storeId, includeArchived, options)(this.fetch, this.basePath);
    }

}
/**
 * PullPaymentsPayoutPublicApi - fetch parameter creator
 * @export
 */
export const PullPaymentsPayoutPublicApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get payout
         * @summary Get Payout
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {string} payoutId The ID of the pull payment payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPayout(pullPaymentId: string, payoutId: string, options: any = {}): FetchArgs {
            // verify required parameter 'pullPaymentId' is not null or undefined
            if (pullPaymentId === null || pullPaymentId === undefined) {
                throw new RequiredError('pullPaymentId', 'Required parameter pullPaymentId was null or undefined when calling pullPaymentsGetPayout.');
            }
            // verify required parameter 'payoutId' is not null or undefined
            if (payoutId === null || payoutId === undefined) {
                throw new RequiredError('payoutId', 'Required parameter payoutId was null or undefined when calling pullPaymentsGetPayout.');
            }
            const localVarPath = `/api/v1/pull-payments/{pullPaymentId}/payouts/{payoutId}`
                .replace(`{${"pullPaymentId"}}`, encodeURIComponent((pullPaymentId)))
                .replace(`{${"payoutId"}}`, encodeURIComponent((payoutId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PullPaymentsPayoutPublicApi - functional programming interface
 * @export
 */
export const PullPaymentsPayoutPublicApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Get payout
         * @summary Get Payout
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {string} payoutId The ID of the pull payment payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPayout(pullPaymentId: string, payoutId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayoutData> {
            const localVarFetchArgs = PullPaymentsPayoutPublicApiFetchParamCreator(configuration).pullPaymentsGetPayout(pullPaymentId, payoutId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PullPaymentsPayoutPublicApi - factory interface
 * @export
 */
export const PullPaymentsPayoutPublicApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get payout
         * @summary Get Payout
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {string} payoutId The ID of the pull payment payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPayout(pullPaymentId: string, payoutId: string, options?: any) {
            return PullPaymentsPayoutPublicApiFp(configuration).pullPaymentsGetPayout(pullPaymentId, payoutId, options)(fetch, basePath);
        },
    };
};

/**
 * PullPaymentsPayoutPublicApi - object-oriented interface
 * @export
 * @class PullPaymentsPayoutPublicApi
 * @extends {BaseAPI}
 */
export class PullPaymentsPayoutPublicApi extends BaseAPI {
    /**
     * Get payout
     * @summary Get Payout
     * @param {string} pullPaymentId The ID of the pull payment
     * @param {string} payoutId The ID of the pull payment payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullPaymentsPayoutPublicApi
     */
    public pullPaymentsGetPayout(pullPaymentId: string, payoutId: string, options?: any) {
        return PullPaymentsPayoutPublicApiFp(this.configuration).pullPaymentsGetPayout(pullPaymentId, payoutId, options)(this.fetch, this.basePath);
    }

}
/**
 * PullPaymentsPublicApi - fetch parameter creator
 * @export
 */
export const PullPaymentsPublicApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new payout
         * @summary Create Payout
         * @param {CreatePayoutRequest} body 
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsCreatePayout(body: CreatePayoutRequest, pullPaymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling pullPaymentsCreatePayout.');
            }
            // verify required parameter 'pullPaymentId' is not null or undefined
            if (pullPaymentId === null || pullPaymentId === undefined) {
                throw new RequiredError('pullPaymentId', 'Required parameter pullPaymentId was null or undefined when calling pullPaymentsCreatePayout.');
            }
            const localVarPath = `/api/v1/pull-payments/{pullPaymentId}/payouts`
                .replace(`{${"pullPaymentId"}}`, encodeURIComponent((pullPaymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreatePayoutRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payout
         * @summary Get Payout
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {string} payoutId The ID of the pull payment payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPayout(pullPaymentId: string, payoutId: string, options: any = {}): FetchArgs {
            // verify required parameter 'pullPaymentId' is not null or undefined
            if (pullPaymentId === null || pullPaymentId === undefined) {
                throw new RequiredError('pullPaymentId', 'Required parameter pullPaymentId was null or undefined when calling pullPaymentsGetPayout.');
            }
            // verify required parameter 'payoutId' is not null or undefined
            if (payoutId === null || payoutId === undefined) {
                throw new RequiredError('payoutId', 'Required parameter payoutId was null or undefined when calling pullPaymentsGetPayout.');
            }
            const localVarPath = `/api/v1/pull-payments/{pullPaymentId}/payouts/{payoutId}`
                .replace(`{${"pullPaymentId"}}`, encodeURIComponent((pullPaymentId)))
                .replace(`{${"payoutId"}}`, encodeURIComponent((payoutId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payouts
         * @summary Get Payouts
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {boolean} [includeCancelled] Whether this should list cancelled payouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPayouts(pullPaymentId: string, includeCancelled?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'pullPaymentId' is not null or undefined
            if (pullPaymentId === null || pullPaymentId === undefined) {
                throw new RequiredError('pullPaymentId', 'Required parameter pullPaymentId was null or undefined when calling pullPaymentsGetPayouts.');
            }
            const localVarPath = `/api/v1/pull-payments/{pullPaymentId}/payouts`
                .replace(`{${"pullPaymentId"}}`, encodeURIComponent((pullPaymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeCancelled !== undefined) {
                localVarQueryParameter['includeCancelled'] = includeCancelled;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a pull payment
         * @summary Get Pull Payment
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPullPayment(pullPaymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'pullPaymentId' is not null or undefined
            if (pullPaymentId === null || pullPaymentId === undefined) {
                throw new RequiredError('pullPaymentId', 'Required parameter pullPaymentId was null or undefined when calling pullPaymentsGetPullPayment.');
            }
            const localVarPath = `/api/v1/pull-payments/{pullPaymentId}`
                .replace(`{${"pullPaymentId"}}`, encodeURIComponent((pullPaymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Pull Payment LNURL details
         * @summary Get Pull Payment LNURL details
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPullPaymentLNURL(pullPaymentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'pullPaymentId' is not null or undefined
            if (pullPaymentId === null || pullPaymentId === undefined) {
                throw new RequiredError('pullPaymentId', 'Required parameter pullPaymentId was null or undefined when calling pullPaymentsGetPullPaymentLNURL.');
            }
            const localVarPath = `/api/v1/pull-payments/{pullPaymentId}/lnurl`
                .replace(`{${"pullPaymentId"}}`, encodeURIComponent((pullPaymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Linking a boltcard to a pull payment will allow you to pay via NFC with it, the money will be sent from the pull payment. The boltcard keys are generated using [Deterministic Boltcard Key Generation](https://github.com/boltcard/boltcard/blob/main/docs/DETERMINISTIC.md).
         * @summary Link a boltcard to a pull payment
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {PullPaymentIdBoltcardsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsLinkBoltcard(pullPaymentId: string, body?: PullPaymentIdBoltcardsBody, options: any = {}): FetchArgs {
            // verify required parameter 'pullPaymentId' is not null or undefined
            if (pullPaymentId === null || pullPaymentId === undefined) {
                throw new RequiredError('pullPaymentId', 'Required parameter pullPaymentId was null or undefined when calling pullPaymentsLinkBoltcard.');
            }
            const localVarPath = `/api/v1/pull-payments/{pullPaymentId}/boltcards`
                .replace(`{${"pullPaymentId"}}`, encodeURIComponent((pullPaymentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PullPaymentIdBoltcardsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PullPaymentsPublicApi - functional programming interface
 * @export
 */
export const PullPaymentsPublicApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Create a new payout
         * @summary Create Payout
         * @param {CreatePayoutRequest} body 
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsCreatePayout(body: CreatePayoutRequest, pullPaymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayoutData> {
            const localVarFetchArgs = PullPaymentsPublicApiFetchParamCreator(configuration).pullPaymentsCreatePayout(body, pullPaymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get payout
         * @summary Get Payout
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {string} payoutId The ID of the pull payment payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPayout(pullPaymentId: string, payoutId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayoutData> {
            const localVarFetchArgs = PullPaymentsPublicApiFetchParamCreator(configuration).pullPaymentsGetPayout(pullPaymentId, payoutId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get payouts
         * @summary Get Payouts
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {boolean} [includeCancelled] Whether this should list cancelled payouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPayouts(pullPaymentId: string, includeCancelled?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayoutDataList> {
            const localVarFetchArgs = PullPaymentsPublicApiFetchParamCreator(configuration).pullPaymentsGetPayouts(pullPaymentId, includeCancelled, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a pull payment
         * @summary Get Pull Payment
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPullPayment(pullPaymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PullPaymentData> {
            const localVarFetchArgs = PullPaymentsPublicApiFetchParamCreator(configuration).pullPaymentsGetPullPayment(pullPaymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Pull Payment LNURL details
         * @summary Get Pull Payment LNURL details
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPullPaymentLNURL(pullPaymentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LNURLData> {
            const localVarFetchArgs = PullPaymentsPublicApiFetchParamCreator(configuration).pullPaymentsGetPullPaymentLNURL(pullPaymentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Linking a boltcard to a pull payment will allow you to pay via NFC with it, the money will be sent from the pull payment. The boltcard keys are generated using [Deterministic Boltcard Key Generation](https://github.com/boltcard/boltcard/blob/main/docs/DETERMINISTIC.md).
         * @summary Link a boltcard to a pull payment
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {PullPaymentIdBoltcardsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsLinkBoltcard(pullPaymentId: string, body?: PullPaymentIdBoltcardsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = PullPaymentsPublicApiFetchParamCreator(configuration).pullPaymentsLinkBoltcard(pullPaymentId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PullPaymentsPublicApi - factory interface
 * @export
 */
export const PullPaymentsPublicApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new payout
         * @summary Create Payout
         * @param {CreatePayoutRequest} body 
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsCreatePayout(body: CreatePayoutRequest, pullPaymentId: string, options?: any) {
            return PullPaymentsPublicApiFp(configuration).pullPaymentsCreatePayout(body, pullPaymentId, options)(fetch, basePath);
        },
        /**
         * Get payout
         * @summary Get Payout
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {string} payoutId The ID of the pull payment payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPayout(pullPaymentId: string, payoutId: string, options?: any) {
            return PullPaymentsPublicApiFp(configuration).pullPaymentsGetPayout(pullPaymentId, payoutId, options)(fetch, basePath);
        },
        /**
         * Get payouts
         * @summary Get Payouts
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {boolean} [includeCancelled] Whether this should list cancelled payouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPayouts(pullPaymentId: string, includeCancelled?: boolean, options?: any) {
            return PullPaymentsPublicApiFp(configuration).pullPaymentsGetPayouts(pullPaymentId, includeCancelled, options)(fetch, basePath);
        },
        /**
         * Get a pull payment
         * @summary Get Pull Payment
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPullPayment(pullPaymentId: string, options?: any) {
            return PullPaymentsPublicApiFp(configuration).pullPaymentsGetPullPayment(pullPaymentId, options)(fetch, basePath);
        },
        /**
         * Get Pull Payment LNURL details
         * @summary Get Pull Payment LNURL details
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetPullPaymentLNURL(pullPaymentId: string, options?: any) {
            return PullPaymentsPublicApiFp(configuration).pullPaymentsGetPullPaymentLNURL(pullPaymentId, options)(fetch, basePath);
        },
        /**
         * Linking a boltcard to a pull payment will allow you to pay via NFC with it, the money will be sent from the pull payment. The boltcard keys are generated using [Deterministic Boltcard Key Generation](https://github.com/boltcard/boltcard/blob/main/docs/DETERMINISTIC.md).
         * @summary Link a boltcard to a pull payment
         * @param {string} pullPaymentId The ID of the pull payment
         * @param {PullPaymentIdBoltcardsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsLinkBoltcard(pullPaymentId: string, body?: PullPaymentIdBoltcardsBody, options?: any) {
            return PullPaymentsPublicApiFp(configuration).pullPaymentsLinkBoltcard(pullPaymentId, body, options)(fetch, basePath);
        },
    };
};

/**
 * PullPaymentsPublicApi - object-oriented interface
 * @export
 * @class PullPaymentsPublicApi
 * @extends {BaseAPI}
 */
export class PullPaymentsPublicApi extends BaseAPI {
    /**
     * Create a new payout
     * @summary Create Payout
     * @param {CreatePayoutRequest} body 
     * @param {string} pullPaymentId The ID of the pull payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullPaymentsPublicApi
     */
    public pullPaymentsCreatePayout(body: CreatePayoutRequest, pullPaymentId: string, options?: any) {
        return PullPaymentsPublicApiFp(this.configuration).pullPaymentsCreatePayout(body, pullPaymentId, options)(this.fetch, this.basePath);
    }

    /**
     * Get payout
     * @summary Get Payout
     * @param {string} pullPaymentId The ID of the pull payment
     * @param {string} payoutId The ID of the pull payment payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullPaymentsPublicApi
     */
    public pullPaymentsGetPayout(pullPaymentId: string, payoutId: string, options?: any) {
        return PullPaymentsPublicApiFp(this.configuration).pullPaymentsGetPayout(pullPaymentId, payoutId, options)(this.fetch, this.basePath);
    }

    /**
     * Get payouts
     * @summary Get Payouts
     * @param {string} pullPaymentId The ID of the pull payment
     * @param {boolean} [includeCancelled] Whether this should list cancelled payouts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullPaymentsPublicApi
     */
    public pullPaymentsGetPayouts(pullPaymentId: string, includeCancelled?: boolean, options?: any) {
        return PullPaymentsPublicApiFp(this.configuration).pullPaymentsGetPayouts(pullPaymentId, includeCancelled, options)(this.fetch, this.basePath);
    }

    /**
     * Get a pull payment
     * @summary Get Pull Payment
     * @param {string} pullPaymentId The ID of the pull payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullPaymentsPublicApi
     */
    public pullPaymentsGetPullPayment(pullPaymentId: string, options?: any) {
        return PullPaymentsPublicApiFp(this.configuration).pullPaymentsGetPullPayment(pullPaymentId, options)(this.fetch, this.basePath);
    }

    /**
     * Get Pull Payment LNURL details
     * @summary Get Pull Payment LNURL details
     * @param {string} pullPaymentId The ID of the pull payment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullPaymentsPublicApi
     */
    public pullPaymentsGetPullPaymentLNURL(pullPaymentId: string, options?: any) {
        return PullPaymentsPublicApiFp(this.configuration).pullPaymentsGetPullPaymentLNURL(pullPaymentId, options)(this.fetch, this.basePath);
    }

    /**
     * Linking a boltcard to a pull payment will allow you to pay via NFC with it, the money will be sent from the pull payment. The boltcard keys are generated using [Deterministic Boltcard Key Generation](https://github.com/boltcard/boltcard/blob/main/docs/DETERMINISTIC.md).
     * @summary Link a boltcard to a pull payment
     * @param {string} pullPaymentId The ID of the pull payment
     * @param {PullPaymentIdBoltcardsBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullPaymentsPublicApi
     */
    public pullPaymentsLinkBoltcard(pullPaymentId: string, body?: PullPaymentIdBoltcardsBody, options?: any) {
        return PullPaymentsPublicApiFp(this.configuration).pullPaymentsLinkBoltcard(pullPaymentId, body, options)(this.fetch, this.basePath);
    }

}
/**
 * ServerEmailApi - fetch parameter creator
 * @export
 */
export const ServerEmailApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the email settings configured for the server. The password field will be masked if present.
         * @summary Get server email settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverEmailGetSettings(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/server/email`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update server's email settings.
         * @summary Update server email settings
         * @param {UpdateServerEmailSettings} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverEmailUpdateSettings(body: UpdateServerEmailSettings, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling serverEmailUpdateSettings.');
            }
            const localVarPath = `/api/v1/server/email`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateServerEmailSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerEmailApi - functional programming interface
 * @export
 */
export const ServerEmailApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the email settings configured for the server. The password field will be masked if present.
         * @summary Get server email settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverEmailGetSettings(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetServerEmailSettings> {
            const localVarFetchArgs = ServerEmailApiFetchParamCreator(configuration).serverEmailGetSettings(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update server's email settings.
         * @summary Update server email settings
         * @param {UpdateServerEmailSettings} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverEmailUpdateSettings(body: UpdateServerEmailSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetServerEmailSettings> {
            const localVarFetchArgs = ServerEmailApiFetchParamCreator(configuration).serverEmailUpdateSettings(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ServerEmailApi - factory interface
 * @export
 */
export const ServerEmailApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve the email settings configured for the server. The password field will be masked if present.
         * @summary Get server email settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverEmailGetSettings(options?: any) {
            return ServerEmailApiFp(configuration).serverEmailGetSettings(options)(fetch, basePath);
        },
        /**
         * Update server's email settings.
         * @summary Update server email settings
         * @param {UpdateServerEmailSettings} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverEmailUpdateSettings(body: UpdateServerEmailSettings, options?: any) {
            return ServerEmailApiFp(configuration).serverEmailUpdateSettings(body, options)(fetch, basePath);
        },
    };
};

/**
 * ServerEmailApi - object-oriented interface
 * @export
 * @class ServerEmailApi
 * @extends {BaseAPI}
 */
export class ServerEmailApi extends BaseAPI {
    /**
     * Retrieve the email settings configured for the server. The password field will be masked if present.
     * @summary Get server email settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerEmailApi
     */
    public serverEmailGetSettings(options?: any) {
        return ServerEmailApiFp(this.configuration).serverEmailGetSettings(options)(this.fetch, this.basePath);
    }

    /**
     * Update server's email settings.
     * @summary Update server email settings
     * @param {UpdateServerEmailSettings} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerEmailApi
     */
    public serverEmailUpdateSettings(body: UpdateServerEmailSettings, options?: any) {
        return ServerEmailApiFp(this.configuration).serverEmailUpdateSettings(body, options)(this.fetch, this.basePath);
    }

}
/**
 * ServerInfoApi - fetch parameter creator
 * @export
 */
export const ServerInfoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * View information about the store's roles at the server's scope
         * @summary Get store's roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverGetStoreRoles(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/server/roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Information about the server, chains and sync states
         * @summary Get server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverInfoGetServerInfo(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/server/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerInfoApi - functional programming interface
 * @export
 */
export const ServerInfoApiFp = function (configuration?: Configuration) {
    return {
        /**
         * View information about the store's roles at the server's scope
         * @summary Get store's roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverGetStoreRoles(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleData> {
            const localVarFetchArgs = ServerInfoApiFetchParamCreator(configuration).serverGetStoreRoles(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Information about the server, chains and sync states
         * @summary Get server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverInfoGetServerInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationServerInfoData> {
            const localVarFetchArgs = ServerInfoApiFetchParamCreator(configuration).serverInfoGetServerInfo(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ServerInfoApi - factory interface
 * @export
 */
export const ServerInfoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * View information about the store's roles at the server's scope
         * @summary Get store's roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverGetStoreRoles(options?: any) {
            return ServerInfoApiFp(configuration).serverGetStoreRoles(options)(fetch, basePath);
        },
        /**
         * Information about the server, chains and sync states
         * @summary Get server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverInfoGetServerInfo(options?: any) {
            return ServerInfoApiFp(configuration).serverInfoGetServerInfo(options)(fetch, basePath);
        },
    };
};

/**
 * ServerInfoApi - object-oriented interface
 * @export
 * @class ServerInfoApi
 * @extends {BaseAPI}
 */
export class ServerInfoApi extends BaseAPI {
    /**
     * View information about the store's roles at the server's scope
     * @summary Get store's roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public serverGetStoreRoles(options?: any) {
        return ServerInfoApiFp(this.configuration).serverGetStoreRoles(options)(this.fetch, this.basePath);
    }

    /**
     * Information about the server, chains and sync states
     * @summary Get server info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerInfoApi
     */
    public serverInfoGetServerInfo(options?: any) {
        return ServerInfoApiFp(this.configuration).serverInfoGetServerInfo(options)(this.fetch, this.basePath);
    }

}
/**
 * StorePaymentMethodsApi - fetch parameter creator
 * @export
 */
export const StorePaymentMethodsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete information about the stores' configured payment method
         * @summary Delete store's payment method
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePaymentMethodsDeleteStorePaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storePaymentMethodsDeleteStorePaymentMethod.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storePaymentMethodsDeleteStorePaymentMethod.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the stores' configured payment method
         * @summary Get store payment method
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {boolean} [includeConfig] Fetch the config of the payment methods, if &#x60;true&#x60;, the permission &#x60;btcpay.store.canmodifystoresettings&#x60; is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePaymentMethodsGetStorePaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, includeConfig?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storePaymentMethodsGetStorePaymentMethod.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storePaymentMethodsGetStorePaymentMethod.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (includeConfig !== undefined) {
                localVarQueryParameter['includeConfig'] = includeConfig;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the stores' configured payment methods
         * @summary Get store payment methods
         * @param {StoreId} storeId The store ID
         * @param {boolean} [onlyEnabled] Fetch payment methods that are enabled/disabled only
         * @param {boolean} [includeConfig] Fetch the config of the payment methods, if &#x60;true&#x60;, the permission &#x60;btcpay.store.canmodifystoresettings&#x60; is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePaymentMethodsGetStorePaymentMethods(storeId: StoreId, onlyEnabled?: boolean, includeConfig?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storePaymentMethodsGetStorePaymentMethods.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (onlyEnabled !== undefined) {
                localVarQueryParameter['onlyEnabled'] = onlyEnabled;
            }

            if (includeConfig !== undefined) {
                localVarQueryParameter['includeConfig'] = includeConfig;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update information about the stores' configured payment method
         * @summary Update store's payment method
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {UpdatePaymentMethodConfig} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePaymentMethodsUpdateStorePaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, body?: UpdatePaymentMethodConfig, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storePaymentMethodsUpdateStorePaymentMethod.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storePaymentMethodsUpdateStorePaymentMethod.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdatePaymentMethodConfig" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorePaymentMethodsApi - functional programming interface
 * @export
 */
export const StorePaymentMethodsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Delete information about the stores' configured payment method
         * @summary Delete store's payment method
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePaymentMethodsDeleteStorePaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StorePaymentMethodsApiFetchParamCreator(configuration).storePaymentMethodsDeleteStorePaymentMethod(paymentMethodId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the stores' configured payment method
         * @summary Get store payment method
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {boolean} [includeConfig] Fetch the config of the payment methods, if &#x60;true&#x60;, the permission &#x60;btcpay.store.canmodifystoresettings&#x60; is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePaymentMethodsGetStorePaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, includeConfig?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GenericPaymentMethodData> {
            const localVarFetchArgs = StorePaymentMethodsApiFetchParamCreator(configuration).storePaymentMethodsGetStorePaymentMethod(paymentMethodId, storeId, includeConfig, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the stores' configured payment methods
         * @summary Get store payment methods
         * @param {StoreId} storeId The store ID
         * @param {boolean} [onlyEnabled] Fetch payment methods that are enabled/disabled only
         * @param {boolean} [includeConfig] Fetch the config of the payment methods, if &#x60;true&#x60;, the permission &#x60;btcpay.store.canmodifystoresettings&#x60; is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePaymentMethodsGetStorePaymentMethods(storeId: StoreId, onlyEnabled?: boolean, includeConfig?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GenericPaymentMethodData>> {
            const localVarFetchArgs = StorePaymentMethodsApiFetchParamCreator(configuration).storePaymentMethodsGetStorePaymentMethods(storeId, onlyEnabled, includeConfig, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update information about the stores' configured payment method
         * @summary Update store's payment method
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {UpdatePaymentMethodConfig} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePaymentMethodsUpdateStorePaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, body?: UpdatePaymentMethodConfig, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GenericPaymentMethodData> {
            const localVarFetchArgs = StorePaymentMethodsApiFetchParamCreator(configuration).storePaymentMethodsUpdateStorePaymentMethod(paymentMethodId, storeId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StorePaymentMethodsApi - factory interface
 * @export
 */
export const StorePaymentMethodsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete information about the stores' configured payment method
         * @summary Delete store's payment method
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePaymentMethodsDeleteStorePaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
            return StorePaymentMethodsApiFp(configuration).storePaymentMethodsDeleteStorePaymentMethod(paymentMethodId, storeId, options)(fetch, basePath);
        },
        /**
         * View information about the stores' configured payment method
         * @summary Get store payment method
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {boolean} [includeConfig] Fetch the config of the payment methods, if &#x60;true&#x60;, the permission &#x60;btcpay.store.canmodifystoresettings&#x60; is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePaymentMethodsGetStorePaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, includeConfig?: boolean, options?: any) {
            return StorePaymentMethodsApiFp(configuration).storePaymentMethodsGetStorePaymentMethod(paymentMethodId, storeId, includeConfig, options)(fetch, basePath);
        },
        /**
         * View information about the stores' configured payment methods
         * @summary Get store payment methods
         * @param {StoreId} storeId The store ID
         * @param {boolean} [onlyEnabled] Fetch payment methods that are enabled/disabled only
         * @param {boolean} [includeConfig] Fetch the config of the payment methods, if &#x60;true&#x60;, the permission &#x60;btcpay.store.canmodifystoresettings&#x60; is required.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePaymentMethodsGetStorePaymentMethods(storeId: StoreId, onlyEnabled?: boolean, includeConfig?: boolean, options?: any) {
            return StorePaymentMethodsApiFp(configuration).storePaymentMethodsGetStorePaymentMethods(storeId, onlyEnabled, includeConfig, options)(fetch, basePath);
        },
        /**
         * Update information about the stores' configured payment method
         * @summary Update store's payment method
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {UpdatePaymentMethodConfig} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePaymentMethodsUpdateStorePaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, body?: UpdatePaymentMethodConfig, options?: any) {
            return StorePaymentMethodsApiFp(configuration).storePaymentMethodsUpdateStorePaymentMethod(paymentMethodId, storeId, body, options)(fetch, basePath);
        },
    };
};

/**
 * StorePaymentMethodsApi - object-oriented interface
 * @export
 * @class StorePaymentMethodsApi
 * @extends {BaseAPI}
 */
export class StorePaymentMethodsApi extends BaseAPI {
    /**
     * Delete information about the stores' configured payment method
     * @summary Delete store's payment method
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorePaymentMethodsApi
     */
    public storePaymentMethodsDeleteStorePaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
        return StorePaymentMethodsApiFp(this.configuration).storePaymentMethodsDeleteStorePaymentMethod(paymentMethodId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the stores' configured payment method
     * @summary Get store payment method
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {boolean} [includeConfig] Fetch the config of the payment methods, if &#x60;true&#x60;, the permission &#x60;btcpay.store.canmodifystoresettings&#x60; is required.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorePaymentMethodsApi
     */
    public storePaymentMethodsGetStorePaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, includeConfig?: boolean, options?: any) {
        return StorePaymentMethodsApiFp(this.configuration).storePaymentMethodsGetStorePaymentMethod(paymentMethodId, storeId, includeConfig, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the stores' configured payment methods
     * @summary Get store payment methods
     * @param {StoreId} storeId The store ID
     * @param {boolean} [onlyEnabled] Fetch payment methods that are enabled/disabled only
     * @param {boolean} [includeConfig] Fetch the config of the payment methods, if &#x60;true&#x60;, the permission &#x60;btcpay.store.canmodifystoresettings&#x60; is required.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorePaymentMethodsApi
     */
    public storePaymentMethodsGetStorePaymentMethods(storeId: StoreId, onlyEnabled?: boolean, includeConfig?: boolean, options?: any) {
        return StorePaymentMethodsApiFp(this.configuration).storePaymentMethodsGetStorePaymentMethods(storeId, onlyEnabled, includeConfig, options)(this.fetch, this.basePath);
    }

    /**
     * Update information about the stores' configured payment method
     * @summary Update store's payment method
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {UpdatePaymentMethodConfig} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorePaymentMethodsApi
     */
    public storePaymentMethodsUpdateStorePaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, body?: UpdatePaymentMethodConfig, options?: any) {
        return StorePaymentMethodsApiFp(this.configuration).storePaymentMethodsUpdateStorePaymentMethod(paymentMethodId, storeId, body, options)(this.fetch, this.basePath);
    }

}
/**
 * StoreWalletOnChainApi - fetch parameter creator
 * @export
 */
export const StoreWalletOnChainApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate a wallet and update the specified store's payment method to it
         * @summary Generate store on-chain wallet
         * @param {GenerateOnChainWalletRequest} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainPaymentMethodsGenerateOnChainWallet(body: GenerateOnChainWalletRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storeOnChainPaymentMethodsGenerateOnChainWallet.');
            }
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainPaymentMethodsGenerateOnChainWallet.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainPaymentMethodsGenerateOnChainWallet.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/generate`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GenerateOnChainWalletRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View addresses of the current payment method of the store
         * @summary Preview store on-chain payment method addresses
         * @param {StoreId} storeId The store ID
         * @param {string} paymentMethodId The payment method id of the payment method to update
         * @param {number} [offset] From which index to fetch the addresses
         * @param {number} [count] Number of addresses to preview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview(storeId: StoreId, paymentMethodId: string, offset?: number, count?: number, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview.');
            }
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/preview`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View addresses of a proposed payment method of the store
         * @summary Preview proposed store on-chain payment method addresses
         * @param {WalletPreviewBody} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {number} [offset] From which index to fetch the addresses
         * @param {number} [count] Number of addresses to preview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview(body: WalletPreviewBody, paymentMethodId: PaymentMethodId, storeId: StoreId, offset?: number, count?: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview.');
            }
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/preview`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WalletPreviewBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add/Update wallet object link
         * @summary Add/Update store on-chain wallet object link
         * @param {AddOnChainWalletObjectLinkRequest} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} objectId The object id to fetch
         * @param {string} objectType The object type to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsAddOrUpdateOnChainWalletLink(body: AddOnChainWalletObjectLinkRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, objectId: string, objectType: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storeOnChainWalletsAddOrUpdateOnChainWalletLink.');
            }
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsAddOrUpdateOnChainWalletLink.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsAddOrUpdateOnChainWalletLink.');
            }
            // verify required parameter 'objectId' is not null or undefined
            if (objectId === null || objectId === undefined) {
                throw new RequiredError('objectId', 'Required parameter objectId was null or undefined when calling storeOnChainWalletsAddOrUpdateOnChainWalletLink.');
            }
            // verify required parameter 'objectType' is not null or undefined
            if (objectType === null || objectType === undefined) {
                throw new RequiredError('objectType', 'Required parameter objectType was null or undefined when calling storeOnChainWalletsAddOrUpdateOnChainWalletLink.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects/{objectType}/{objectId}/links`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"objectId"}}`, encodeURIComponent((objectId)))
                .replace(`{${"objectType"}}`, encodeURIComponent((objectType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddOnChainWalletObjectLinkRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add/Update wallet objects
         * @summary Add/Update store on-chain wallet objects
         * @param {OnChainWalletObjectData} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsAddOrUpdateOnChainWalletObjects(body: OnChainWalletObjectData, paymentMethodId: PaymentMethodId, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storeOnChainWalletsAddOrUpdateOnChainWalletObjects.');
            }
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsAddOrUpdateOnChainWalletObjects.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsAddOrUpdateOnChainWalletObjects.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OnChainWalletObjectData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create store on-chain wallet transaction
         * @summary Create store on-chain wallet transaction
         * @param {CreateOnChainTransactionRequest} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsCreateOnChainTransaction(body: CreateOnChainTransactionRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storeOnChainWalletsCreateOnChainTransaction.');
            }
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsCreateOnChainTransaction.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsCreateOnChainTransaction.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/transactions`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateOnChainTransactionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get wallet onchain fee rate
         * @summary Get store on-chain wallet fee rate
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {number} [blockTarget] The number of blocks away you are willing to target for confirmation. Defaults to the wallet&#x27;s configured &#x60;RecommendedFeeBlockTarget&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainFeeRate(paymentMethodId: PaymentMethodId, storeId: StoreId, blockTarget?: number, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsGetOnChainFeeRate.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsGetOnChainFeeRate.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/feerate`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (blockTarget !== undefined) {
                localVarQueryParameter['blockTarget'] = blockTarget;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View wallet object
         * @summary Get store on-chain wallet object
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} objectId The object id to fetch
         * @param {string} objectType The object type to fetch
         * @param {boolean} [includeNeighbourData] Whether or not you should include neighbour&#x27;s node data in the result (ie, &#x60;links.objectData&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainWalletObject(paymentMethodId: PaymentMethodId, storeId: StoreId, objectId: string, objectType: string, includeNeighbourData?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsGetOnChainWalletObject.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsGetOnChainWalletObject.');
            }
            // verify required parameter 'objectId' is not null or undefined
            if (objectId === null || objectId === undefined) {
                throw new RequiredError('objectId', 'Required parameter objectId was null or undefined when calling storeOnChainWalletsGetOnChainWalletObject.');
            }
            // verify required parameter 'objectType' is not null or undefined
            if (objectType === null || objectType === undefined) {
                throw new RequiredError('objectType', 'Required parameter objectType was null or undefined when calling storeOnChainWalletsGetOnChainWalletObject.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects/{objectType}/{objectId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"objectId"}}`, encodeURIComponent((objectId)))
                .replace(`{${"objectType"}}`, encodeURIComponent((objectType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (includeNeighbourData !== undefined) {
                localVarQueryParameter['includeNeighbourData'] = includeNeighbourData;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View wallet objects
         * @summary Get store on-chain wallet objects
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {Array<string>} [ids] The ids of objects to fetch, if used, type should be specified
         * @param {string} [type] The type of object to fetch
         * @param {boolean} [includeNeighbourData] Whether or not you should include neighbour&#x27;s node data in the result (ie, &#x60;links.objectData&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainWalletObjects(paymentMethodId: PaymentMethodId, storeId: StoreId, ids?: Array<string>, type?: string, includeNeighbourData?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsGetOnChainWalletObjects.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsGetOnChainWalletObjects.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (includeNeighbourData !== undefined) {
                localVarQueryParameter['includeNeighbourData'] = includeNeighbourData;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get or generate address for wallet
         * @summary Get store on-chain wallet address
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {boolean} [forceGenerate] Whether to generate a new address for this request even if the previous one was not used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainWalletReceiveAddress(paymentMethodId: PaymentMethodId, storeId: StoreId, forceGenerate?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsGetOnChainWalletReceiveAddress.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsGetOnChainWalletReceiveAddress.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/address`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (forceGenerate !== undefined) {
                localVarQueryParameter['forceGenerate'] = forceGenerate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get store on-chain wallet transaction
         * @summary Get store on-chain wallet transaction
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} transactionId The transaction id to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainWalletTransaction(paymentMethodId: PaymentMethodId, storeId: StoreId, transactionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsGetOnChainWalletTransaction.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsGetOnChainWalletTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling storeOnChainWalletsGetOnChainWalletTransaction.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/transactions/{transactionId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"transactionId"}}`, encodeURIComponent((transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get store on-chain wallet utxos
         * @summary Get store on-chain wallet UTXOS
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainWalletUTXOs(paymentMethodId: PaymentMethodId, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsGetOnChainWalletUTXOs.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsGetOnChainWalletUTXOs.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/utxos`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch store on-chain wallet transaction info
         * @summary Patch store on-chain wallet transaction info
         * @param {PatchOnChainTransactionRequest} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} transactionId The transaction id to fetch
         * @param {string} [force] Whether to update the label/comments even if the transaction does not yet exist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsPatchOnChainWalletTransaction(body: PatchOnChainTransactionRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, transactionId: string, force?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storeOnChainWalletsPatchOnChainWalletTransaction.');
            }
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsPatchOnChainWalletTransaction.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsPatchOnChainWalletTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling storeOnChainWalletsPatchOnChainWalletTransaction.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/transactions/{transactionId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"transactionId"}}`, encodeURIComponent((transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchOnChainTransactionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove wallet object link
         * @summary Remove store on-chain wallet object links
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} linkId The object id of the linked neighbour
         * @param {string} objectId The object id to fetch
         * @param {string} linkType The object type of the linked neighbour
         * @param {string} objectType The object type to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsRemoveOnChainWalletLink(paymentMethodId: PaymentMethodId, storeId: StoreId, linkId: string, objectId: string, linkType: string, objectType: string, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsRemoveOnChainWalletLink.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsRemoveOnChainWalletLink.');
            }
            // verify required parameter 'linkId' is not null or undefined
            if (linkId === null || linkId === undefined) {
                throw new RequiredError('linkId', 'Required parameter linkId was null or undefined when calling storeOnChainWalletsRemoveOnChainWalletLink.');
            }
            // verify required parameter 'objectId' is not null or undefined
            if (objectId === null || objectId === undefined) {
                throw new RequiredError('objectId', 'Required parameter objectId was null or undefined when calling storeOnChainWalletsRemoveOnChainWalletLink.');
            }
            // verify required parameter 'linkType' is not null or undefined
            if (linkType === null || linkType === undefined) {
                throw new RequiredError('linkType', 'Required parameter linkType was null or undefined when calling storeOnChainWalletsRemoveOnChainWalletLink.');
            }
            // verify required parameter 'objectType' is not null or undefined
            if (objectType === null || objectType === undefined) {
                throw new RequiredError('objectType', 'Required parameter objectType was null or undefined when calling storeOnChainWalletsRemoveOnChainWalletLink.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects/{objectType}/{objectId}/links/{linkType}/{linkId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"linkId"}}`, encodeURIComponent((linkId)))
                .replace(`{${"objectId"}}`, encodeURIComponent((objectId)))
                .replace(`{${"linkType"}}`, encodeURIComponent((linkType)))
                .replace(`{${"objectType"}}`, encodeURIComponent((objectType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove wallet object
         * @summary Remove store on-chain wallet objects
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} objectId The object id to fetch
         * @param {string} objectType The object type to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsRemoveOnChainWalletObject(paymentMethodId: PaymentMethodId, storeId: StoreId, objectId: string, objectType: string, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsRemoveOnChainWalletObject.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsRemoveOnChainWalletObject.');
            }
            // verify required parameter 'objectId' is not null or undefined
            if (objectId === null || objectId === undefined) {
                throw new RequiredError('objectId', 'Required parameter objectId was null or undefined when calling storeOnChainWalletsRemoveOnChainWalletObject.');
            }
            // verify required parameter 'objectType' is not null or undefined
            if (objectType === null || objectType === undefined) {
                throw new RequiredError('objectType', 'Required parameter objectType was null or undefined when calling storeOnChainWalletsRemoveOnChainWalletObject.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/objects/{objectType}/{objectId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"objectId"}}`, encodeURIComponent((objectId)))
                .replace(`{${"objectType"}}`, encodeURIComponent((objectType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View the balance histogram of the specified wallet
         * @summary Get store on-chain wallet balance histogram
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsShowOnChainWalletHistogram(paymentMethodId: PaymentMethodId, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsShowOnChainWalletHistogram.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsShowOnChainWalletHistogram.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/histogram`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the specified wallet
         * @summary Get store on-chain wallet overview
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsShowOnChainWalletOverview(paymentMethodId: PaymentMethodId, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsShowOnChainWalletOverview.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsShowOnChainWalletOverview.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get store on-chain wallet transactions
         * @summary Get store on-chain wallet transactions
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} [labelFilter] Transaction label to filter by
         * @param {number} [limit] Maximum number of transactions to return
         * @param {number} [skip] Number of transactions to skip from the start
         * @param {Array<TransactionStatus>} [statusFilter] Statuses to filter the transactions with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsShowOnChainWalletTransactions(paymentMethodId: PaymentMethodId, storeId: StoreId, labelFilter?: string, limit?: number, skip?: number, statusFilter?: Array<TransactionStatus>, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsShowOnChainWalletTransactions.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsShowOnChainWalletTransactions.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/transactions`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (labelFilter !== undefined) {
                localVarQueryParameter['labelFilter'] = labelFilter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (statusFilter) {
                localVarQueryParameter['statusFilter'] = statusFilter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * UnReserve address
         * @summary UnReserve last store on-chain wallet address
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsUnReserveOnChainWalletReceiveAddress(paymentMethodId: PaymentMethodId, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storeOnChainWalletsUnReserveOnChainWalletReceiveAddress.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storeOnChainWalletsUnReserveOnChainWalletReceiveAddress.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payment-methods/{paymentMethodId}/wallet/address`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreWalletOnChainApi - functional programming interface
 * @export
 */
export const StoreWalletOnChainApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Generate a wallet and update the specified store's payment method to it
         * @summary Generate store on-chain wallet
         * @param {GenerateOnChainWalletRequest} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainPaymentMethodsGenerateOnChainWallet(body: GenerateOnChainWalletRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainPaymentMethodsGenerateOnChainWallet(body, paymentMethodId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View addresses of the current payment method of the store
         * @summary Preview store on-chain payment method addresses
         * @param {StoreId} storeId The store ID
         * @param {string} paymentMethodId The payment method id of the payment method to update
         * @param {number} [offset] From which index to fetch the addresses
         * @param {number} [count] Number of addresses to preview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview(storeId: StoreId, paymentMethodId: string, offset?: number, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OnChainPaymentMethodPreviewResultData> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview(storeId, paymentMethodId, offset, count, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View addresses of a proposed payment method of the store
         * @summary Preview proposed store on-chain payment method addresses
         * @param {WalletPreviewBody} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {number} [offset] From which index to fetch the addresses
         * @param {number} [count] Number of addresses to preview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview(body: WalletPreviewBody, paymentMethodId: PaymentMethodId, storeId: StoreId, offset?: number, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OnChainPaymentMethodPreviewResultData> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview(body, paymentMethodId, storeId, offset, count, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add/Update wallet object link
         * @summary Add/Update store on-chain wallet object link
         * @param {AddOnChainWalletObjectLinkRequest} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} objectId The object id to fetch
         * @param {string} objectType The object type to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsAddOrUpdateOnChainWalletLink(body: AddOnChainWalletObjectLinkRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, objectId: string, objectType: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsAddOrUpdateOnChainWalletLink(body, paymentMethodId, storeId, objectId, objectType, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add/Update wallet objects
         * @summary Add/Update store on-chain wallet objects
         * @param {OnChainWalletObjectData} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsAddOrUpdateOnChainWalletObjects(body: OnChainWalletObjectData, paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OnChainWalletObjectData> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsAddOrUpdateOnChainWalletObjects(body, paymentMethodId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create store on-chain wallet transaction
         * @summary Create store on-chain wallet transaction
         * @param {CreateOnChainTransactionRequest} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsCreateOnChainTransaction(body: CreateOnChainTransactionRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsCreateOnChainTransaction(body, paymentMethodId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get wallet onchain fee rate
         * @summary Get store on-chain wallet fee rate
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {number} [blockTarget] The number of blocks away you are willing to target for confirmation. Defaults to the wallet&#x27;s configured &#x60;RecommendedFeeBlockTarget&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainFeeRate(paymentMethodId: PaymentMethodId, storeId: StoreId, blockTarget?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OnChainWalletFeeRateData> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsGetOnChainFeeRate(paymentMethodId, storeId, blockTarget, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View wallet object
         * @summary Get store on-chain wallet object
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} objectId The object id to fetch
         * @param {string} objectType The object type to fetch
         * @param {boolean} [includeNeighbourData] Whether or not you should include neighbour&#x27;s node data in the result (ie, &#x60;links.objectData&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainWalletObject(paymentMethodId: PaymentMethodId, storeId: StoreId, objectId: string, objectType: string, includeNeighbourData?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OnChainWalletObjectData> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsGetOnChainWalletObject(paymentMethodId, storeId, objectId, objectType, includeNeighbourData, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View wallet objects
         * @summary Get store on-chain wallet objects
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {Array<string>} [ids] The ids of objects to fetch, if used, type should be specified
         * @param {string} [type] The type of object to fetch
         * @param {boolean} [includeNeighbourData] Whether or not you should include neighbour&#x27;s node data in the result (ie, &#x60;links.objectData&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainWalletObjects(paymentMethodId: PaymentMethodId, storeId: StoreId, ids?: Array<string>, type?: string, includeNeighbourData?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OnChainWalletObjectData>> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsGetOnChainWalletObjects(paymentMethodId, storeId, ids, type, includeNeighbourData, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get or generate address for wallet
         * @summary Get store on-chain wallet address
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {boolean} [forceGenerate] Whether to generate a new address for this request even if the previous one was not used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainWalletReceiveAddress(paymentMethodId: PaymentMethodId, storeId: StoreId, forceGenerate?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OnChainWalletAddressData> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsGetOnChainWalletReceiveAddress(paymentMethodId, storeId, forceGenerate, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get store on-chain wallet transaction
         * @summary Get store on-chain wallet transaction
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} transactionId The transaction id to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainWalletTransaction(paymentMethodId: PaymentMethodId, storeId: StoreId, transactionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OnChainWalletTransactionData> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsGetOnChainWalletTransaction(paymentMethodId, storeId, transactionId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get store on-chain wallet utxos
         * @summary Get store on-chain wallet UTXOS
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainWalletUTXOs(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OnChainWalletUTXOData>> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsGetOnChainWalletUTXOs(paymentMethodId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Patch store on-chain wallet transaction info
         * @summary Patch store on-chain wallet transaction info
         * @param {PatchOnChainTransactionRequest} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} transactionId The transaction id to fetch
         * @param {string} [force] Whether to update the label/comments even if the transaction does not yet exist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsPatchOnChainWalletTransaction(body: PatchOnChainTransactionRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, transactionId: string, force?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OnChainWalletTransactionData> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsPatchOnChainWalletTransaction(body, paymentMethodId, storeId, transactionId, force, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove wallet object link
         * @summary Remove store on-chain wallet object links
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} linkId The object id of the linked neighbour
         * @param {string} objectId The object id to fetch
         * @param {string} linkType The object type of the linked neighbour
         * @param {string} objectType The object type to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsRemoveOnChainWalletLink(paymentMethodId: PaymentMethodId, storeId: StoreId, linkId: string, objectId: string, linkType: string, objectType: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsRemoveOnChainWalletLink(paymentMethodId, storeId, linkId, objectId, linkType, objectType, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove wallet object
         * @summary Remove store on-chain wallet objects
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} objectId The object id to fetch
         * @param {string} objectType The object type to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsRemoveOnChainWalletObject(paymentMethodId: PaymentMethodId, storeId: StoreId, objectId: string, objectType: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsRemoveOnChainWalletObject(paymentMethodId, storeId, objectId, objectType, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View the balance histogram of the specified wallet
         * @summary Get store on-chain wallet balance histogram
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsShowOnChainWalletHistogram(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HistogramData> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsShowOnChainWalletHistogram(paymentMethodId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the specified wallet
         * @summary Get store on-chain wallet overview
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsShowOnChainWalletOverview(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OnChainWalletOverviewData> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsShowOnChainWalletOverview(paymentMethodId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get store on-chain wallet transactions
         * @summary Get store on-chain wallet transactions
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} [labelFilter] Transaction label to filter by
         * @param {number} [limit] Maximum number of transactions to return
         * @param {number} [skip] Number of transactions to skip from the start
         * @param {Array<TransactionStatus>} [statusFilter] Statuses to filter the transactions with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsShowOnChainWalletTransactions(paymentMethodId: PaymentMethodId, storeId: StoreId, labelFilter?: string, limit?: number, skip?: number, statusFilter?: Array<TransactionStatus>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OnChainWalletTransactionData>> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsShowOnChainWalletTransactions(paymentMethodId, storeId, labelFilter, limit, skip, statusFilter, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * UnReserve address
         * @summary UnReserve last store on-chain wallet address
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsUnReserveOnChainWalletReceiveAddress(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StoreWalletOnChainApiFetchParamCreator(configuration).storeOnChainWalletsUnReserveOnChainWalletReceiveAddress(paymentMethodId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StoreWalletOnChainApi - factory interface
 * @export
 */
export const StoreWalletOnChainApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Generate a wallet and update the specified store's payment method to it
         * @summary Generate store on-chain wallet
         * @param {GenerateOnChainWalletRequest} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainPaymentMethodsGenerateOnChainWallet(body: GenerateOnChainWalletRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainPaymentMethodsGenerateOnChainWallet(body, paymentMethodId, storeId, options)(fetch, basePath);
        },
        /**
         * View addresses of the current payment method of the store
         * @summary Preview store on-chain payment method addresses
         * @param {StoreId} storeId The store ID
         * @param {string} paymentMethodId The payment method id of the payment method to update
         * @param {number} [offset] From which index to fetch the addresses
         * @param {number} [count] Number of addresses to preview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview(storeId: StoreId, paymentMethodId: string, offset?: number, count?: number, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview(storeId, paymentMethodId, offset, count, options)(fetch, basePath);
        },
        /**
         * View addresses of a proposed payment method of the store
         * @summary Preview proposed store on-chain payment method addresses
         * @param {WalletPreviewBody} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {number} [offset] From which index to fetch the addresses
         * @param {number} [count] Number of addresses to preview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview(body: WalletPreviewBody, paymentMethodId: PaymentMethodId, storeId: StoreId, offset?: number, count?: number, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview(body, paymentMethodId, storeId, offset, count, options)(fetch, basePath);
        },
        /**
         * Add/Update wallet object link
         * @summary Add/Update store on-chain wallet object link
         * @param {AddOnChainWalletObjectLinkRequest} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} objectId The object id to fetch
         * @param {string} objectType The object type to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsAddOrUpdateOnChainWalletLink(body: AddOnChainWalletObjectLinkRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, objectId: string, objectType: string, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsAddOrUpdateOnChainWalletLink(body, paymentMethodId, storeId, objectId, objectType, options)(fetch, basePath);
        },
        /**
         * Add/Update wallet objects
         * @summary Add/Update store on-chain wallet objects
         * @param {OnChainWalletObjectData} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsAddOrUpdateOnChainWalletObjects(body: OnChainWalletObjectData, paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsAddOrUpdateOnChainWalletObjects(body, paymentMethodId, storeId, options)(fetch, basePath);
        },
        /**
         * Create store on-chain wallet transaction
         * @summary Create store on-chain wallet transaction
         * @param {CreateOnChainTransactionRequest} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsCreateOnChainTransaction(body: CreateOnChainTransactionRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsCreateOnChainTransaction(body, paymentMethodId, storeId, options)(fetch, basePath);
        },
        /**
         * Get wallet onchain fee rate
         * @summary Get store on-chain wallet fee rate
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {number} [blockTarget] The number of blocks away you are willing to target for confirmation. Defaults to the wallet&#x27;s configured &#x60;RecommendedFeeBlockTarget&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainFeeRate(paymentMethodId: PaymentMethodId, storeId: StoreId, blockTarget?: number, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsGetOnChainFeeRate(paymentMethodId, storeId, blockTarget, options)(fetch, basePath);
        },
        /**
         * View wallet object
         * @summary Get store on-chain wallet object
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} objectId The object id to fetch
         * @param {string} objectType The object type to fetch
         * @param {boolean} [includeNeighbourData] Whether or not you should include neighbour&#x27;s node data in the result (ie, &#x60;links.objectData&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainWalletObject(paymentMethodId: PaymentMethodId, storeId: StoreId, objectId: string, objectType: string, includeNeighbourData?: boolean, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsGetOnChainWalletObject(paymentMethodId, storeId, objectId, objectType, includeNeighbourData, options)(fetch, basePath);
        },
        /**
         * View wallet objects
         * @summary Get store on-chain wallet objects
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {Array<string>} [ids] The ids of objects to fetch, if used, type should be specified
         * @param {string} [type] The type of object to fetch
         * @param {boolean} [includeNeighbourData] Whether or not you should include neighbour&#x27;s node data in the result (ie, &#x60;links.objectData&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainWalletObjects(paymentMethodId: PaymentMethodId, storeId: StoreId, ids?: Array<string>, type?: string, includeNeighbourData?: boolean, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsGetOnChainWalletObjects(paymentMethodId, storeId, ids, type, includeNeighbourData, options)(fetch, basePath);
        },
        /**
         * Get or generate address for wallet
         * @summary Get store on-chain wallet address
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {boolean} [forceGenerate] Whether to generate a new address for this request even if the previous one was not used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainWalletReceiveAddress(paymentMethodId: PaymentMethodId, storeId: StoreId, forceGenerate?: boolean, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsGetOnChainWalletReceiveAddress(paymentMethodId, storeId, forceGenerate, options)(fetch, basePath);
        },
        /**
         * Get store on-chain wallet transaction
         * @summary Get store on-chain wallet transaction
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} transactionId The transaction id to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainWalletTransaction(paymentMethodId: PaymentMethodId, storeId: StoreId, transactionId: string, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsGetOnChainWalletTransaction(paymentMethodId, storeId, transactionId, options)(fetch, basePath);
        },
        /**
         * Get store on-chain wallet utxos
         * @summary Get store on-chain wallet UTXOS
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsGetOnChainWalletUTXOs(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsGetOnChainWalletUTXOs(paymentMethodId, storeId, options)(fetch, basePath);
        },
        /**
         * Patch store on-chain wallet transaction info
         * @summary Patch store on-chain wallet transaction info
         * @param {PatchOnChainTransactionRequest} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} transactionId The transaction id to fetch
         * @param {string} [force] Whether to update the label/comments even if the transaction does not yet exist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsPatchOnChainWalletTransaction(body: PatchOnChainTransactionRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, transactionId: string, force?: string, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsPatchOnChainWalletTransaction(body, paymentMethodId, storeId, transactionId, force, options)(fetch, basePath);
        },
        /**
         * Remove wallet object link
         * @summary Remove store on-chain wallet object links
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} linkId The object id of the linked neighbour
         * @param {string} objectId The object id to fetch
         * @param {string} linkType The object type of the linked neighbour
         * @param {string} objectType The object type to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsRemoveOnChainWalletLink(paymentMethodId: PaymentMethodId, storeId: StoreId, linkId: string, objectId: string, linkType: string, objectType: string, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsRemoveOnChainWalletLink(paymentMethodId, storeId, linkId, objectId, linkType, objectType, options)(fetch, basePath);
        },
        /**
         * Remove wallet object
         * @summary Remove store on-chain wallet objects
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} objectId The object id to fetch
         * @param {string} objectType The object type to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsRemoveOnChainWalletObject(paymentMethodId: PaymentMethodId, storeId: StoreId, objectId: string, objectType: string, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsRemoveOnChainWalletObject(paymentMethodId, storeId, objectId, objectType, options)(fetch, basePath);
        },
        /**
         * View the balance histogram of the specified wallet
         * @summary Get store on-chain wallet balance histogram
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsShowOnChainWalletHistogram(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsShowOnChainWalletHistogram(paymentMethodId, storeId, options)(fetch, basePath);
        },
        /**
         * View information about the specified wallet
         * @summary Get store on-chain wallet overview
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsShowOnChainWalletOverview(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsShowOnChainWalletOverview(paymentMethodId, storeId, options)(fetch, basePath);
        },
        /**
         * Get store on-chain wallet transactions
         * @summary Get store on-chain wallet transactions
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} [labelFilter] Transaction label to filter by
         * @param {number} [limit] Maximum number of transactions to return
         * @param {number} [skip] Number of transactions to skip from the start
         * @param {Array<TransactionStatus>} [statusFilter] Statuses to filter the transactions with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsShowOnChainWalletTransactions(paymentMethodId: PaymentMethodId, storeId: StoreId, labelFilter?: string, limit?: number, skip?: number, statusFilter?: Array<TransactionStatus>, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsShowOnChainWalletTransactions(paymentMethodId, storeId, labelFilter, limit, skip, statusFilter, options)(fetch, basePath);
        },
        /**
         * UnReserve address
         * @summary UnReserve last store on-chain wallet address
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeOnChainWalletsUnReserveOnChainWalletReceiveAddress(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
            return StoreWalletOnChainApiFp(configuration).storeOnChainWalletsUnReserveOnChainWalletReceiveAddress(paymentMethodId, storeId, options)(fetch, basePath);
        },
    };
};

/**
 * StoreWalletOnChainApi - object-oriented interface
 * @export
 * @class StoreWalletOnChainApi
 * @extends {BaseAPI}
 */
export class StoreWalletOnChainApi extends BaseAPI {
    /**
     * Generate a wallet and update the specified store's payment method to it
     * @summary Generate store on-chain wallet
     * @param {GenerateOnChainWalletRequest} body 
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainPaymentMethodsGenerateOnChainWallet(body: GenerateOnChainWalletRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainPaymentMethodsGenerateOnChainWallet(body, paymentMethodId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * View addresses of the current payment method of the store
     * @summary Preview store on-chain payment method addresses
     * @param {StoreId} storeId The store ID
     * @param {string} paymentMethodId The payment method id of the payment method to update
     * @param {number} [offset] From which index to fetch the addresses
     * @param {number} [count] Number of addresses to preview
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview(storeId: StoreId, paymentMethodId: string, offset?: number, count?: number, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainPaymentMethodsGetOnChainPaymentMethodPreview(storeId, paymentMethodId, offset, count, options)(this.fetch, this.basePath);
    }

    /**
     * View addresses of a proposed payment method of the store
     * @summary Preview proposed store on-chain payment method addresses
     * @param {WalletPreviewBody} body 
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {number} [offset] From which index to fetch the addresses
     * @param {number} [count] Number of addresses to preview
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview(body: WalletPreviewBody, paymentMethodId: PaymentMethodId, storeId: StoreId, offset?: number, count?: number, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainPaymentMethodsPOSTOnChainPaymentMethodPreview(body, paymentMethodId, storeId, offset, count, options)(this.fetch, this.basePath);
    }

    /**
     * Add/Update wallet object link
     * @summary Add/Update store on-chain wallet object link
     * @param {AddOnChainWalletObjectLinkRequest} body 
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {string} objectId The object id to fetch
     * @param {string} objectType The object type to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsAddOrUpdateOnChainWalletLink(body: AddOnChainWalletObjectLinkRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, objectId: string, objectType: string, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsAddOrUpdateOnChainWalletLink(body, paymentMethodId, storeId, objectId, objectType, options)(this.fetch, this.basePath);
    }

    /**
     * Add/Update wallet objects
     * @summary Add/Update store on-chain wallet objects
     * @param {OnChainWalletObjectData} body 
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsAddOrUpdateOnChainWalletObjects(body: OnChainWalletObjectData, paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsAddOrUpdateOnChainWalletObjects(body, paymentMethodId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Create store on-chain wallet transaction
     * @summary Create store on-chain wallet transaction
     * @param {CreateOnChainTransactionRequest} body 
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsCreateOnChainTransaction(body: CreateOnChainTransactionRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsCreateOnChainTransaction(body, paymentMethodId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Get wallet onchain fee rate
     * @summary Get store on-chain wallet fee rate
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {number} [blockTarget] The number of blocks away you are willing to target for confirmation. Defaults to the wallet&#x27;s configured &#x60;RecommendedFeeBlockTarget&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsGetOnChainFeeRate(paymentMethodId: PaymentMethodId, storeId: StoreId, blockTarget?: number, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsGetOnChainFeeRate(paymentMethodId, storeId, blockTarget, options)(this.fetch, this.basePath);
    }

    /**
     * View wallet object
     * @summary Get store on-chain wallet object
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {string} objectId The object id to fetch
     * @param {string} objectType The object type to fetch
     * @param {boolean} [includeNeighbourData] Whether or not you should include neighbour&#x27;s node data in the result (ie, &#x60;links.objectData&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsGetOnChainWalletObject(paymentMethodId: PaymentMethodId, storeId: StoreId, objectId: string, objectType: string, includeNeighbourData?: boolean, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsGetOnChainWalletObject(paymentMethodId, storeId, objectId, objectType, includeNeighbourData, options)(this.fetch, this.basePath);
    }

    /**
     * View wallet objects
     * @summary Get store on-chain wallet objects
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {Array<string>} [ids] The ids of objects to fetch, if used, type should be specified
     * @param {string} [type] The type of object to fetch
     * @param {boolean} [includeNeighbourData] Whether or not you should include neighbour&#x27;s node data in the result (ie, &#x60;links.objectData&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsGetOnChainWalletObjects(paymentMethodId: PaymentMethodId, storeId: StoreId, ids?: Array<string>, type?: string, includeNeighbourData?: boolean, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsGetOnChainWalletObjects(paymentMethodId, storeId, ids, type, includeNeighbourData, options)(this.fetch, this.basePath);
    }

    /**
     * Get or generate address for wallet
     * @summary Get store on-chain wallet address
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {boolean} [forceGenerate] Whether to generate a new address for this request even if the previous one was not used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsGetOnChainWalletReceiveAddress(paymentMethodId: PaymentMethodId, storeId: StoreId, forceGenerate?: boolean, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsGetOnChainWalletReceiveAddress(paymentMethodId, storeId, forceGenerate, options)(this.fetch, this.basePath);
    }

    /**
     * Get store on-chain wallet transaction
     * @summary Get store on-chain wallet transaction
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {string} transactionId The transaction id to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsGetOnChainWalletTransaction(paymentMethodId: PaymentMethodId, storeId: StoreId, transactionId: string, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsGetOnChainWalletTransaction(paymentMethodId, storeId, transactionId, options)(this.fetch, this.basePath);
    }

    /**
     * Get store on-chain wallet utxos
     * @summary Get store on-chain wallet UTXOS
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsGetOnChainWalletUTXOs(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsGetOnChainWalletUTXOs(paymentMethodId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Patch store on-chain wallet transaction info
     * @summary Patch store on-chain wallet transaction info
     * @param {PatchOnChainTransactionRequest} body 
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {string} transactionId The transaction id to fetch
     * @param {string} [force] Whether to update the label/comments even if the transaction does not yet exist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsPatchOnChainWalletTransaction(body: PatchOnChainTransactionRequest, paymentMethodId: PaymentMethodId, storeId: StoreId, transactionId: string, force?: string, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsPatchOnChainWalletTransaction(body, paymentMethodId, storeId, transactionId, force, options)(this.fetch, this.basePath);
    }

    /**
     * Remove wallet object link
     * @summary Remove store on-chain wallet object links
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {string} linkId The object id of the linked neighbour
     * @param {string} objectId The object id to fetch
     * @param {string} linkType The object type of the linked neighbour
     * @param {string} objectType The object type to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsRemoveOnChainWalletLink(paymentMethodId: PaymentMethodId, storeId: StoreId, linkId: string, objectId: string, linkType: string, objectType: string, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsRemoveOnChainWalletLink(paymentMethodId, storeId, linkId, objectId, linkType, objectType, options)(this.fetch, this.basePath);
    }

    /**
     * Remove wallet object
     * @summary Remove store on-chain wallet objects
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {string} objectId The object id to fetch
     * @param {string} objectType The object type to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsRemoveOnChainWalletObject(paymentMethodId: PaymentMethodId, storeId: StoreId, objectId: string, objectType: string, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsRemoveOnChainWalletObject(paymentMethodId, storeId, objectId, objectType, options)(this.fetch, this.basePath);
    }

    /**
     * View the balance histogram of the specified wallet
     * @summary Get store on-chain wallet balance histogram
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsShowOnChainWalletHistogram(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsShowOnChainWalletHistogram(paymentMethodId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the specified wallet
     * @summary Get store on-chain wallet overview
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsShowOnChainWalletOverview(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsShowOnChainWalletOverview(paymentMethodId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Get store on-chain wallet transactions
     * @summary Get store on-chain wallet transactions
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {string} [labelFilter] Transaction label to filter by
     * @param {number} [limit] Maximum number of transactions to return
     * @param {number} [skip] Number of transactions to skip from the start
     * @param {Array<TransactionStatus>} [statusFilter] Statuses to filter the transactions with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsShowOnChainWalletTransactions(paymentMethodId: PaymentMethodId, storeId: StoreId, labelFilter?: string, limit?: number, skip?: number, statusFilter?: Array<TransactionStatus>, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsShowOnChainWalletTransactions(paymentMethodId, storeId, labelFilter, limit, skip, statusFilter, options)(this.fetch, this.basePath);
    }

    /**
     * UnReserve address
     * @summary UnReserve last store on-chain wallet address
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreWalletOnChainApi
     */
    public storeOnChainWalletsUnReserveOnChainWalletReceiveAddress(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
        return StoreWalletOnChainApiFp(this.configuration).storeOnChainWalletsUnReserveOnChainWalletReceiveAddress(paymentMethodId, storeId, options)(this.fetch, this.basePath);
    }

}
/**
 * StoresApi - fetch parameter creator
 * @export
 */
export const StoresApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new store
         * @summary Create a new store
         * @param {StoreBaseData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesCreateStore(body: StoreBaseData, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storesCreateStore.');
            }
            const localVarPath = `/api/v1/stores`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StoreBaseData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the specified store. If there is another user with access, only your access will be removed.
         * @summary Remove Store
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesDeleteStore(storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesDeleteStore.');
            }
            const localVarPath = `/api/v1/stores/{storeId}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the store's logo
         * @summary Deletes the store logo
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesDeleteStoreLogo(storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesDeleteStoreLogo.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/logo`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the specified store
         * @summary Get store
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStore(storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesGetStore.');
            }
            const localVarPath = `/api/v1/stores/{storeId}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the specified store's roles
         * @summary Get store's roles
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStoreRoles(storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesGetStoreRoles.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/roles`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the available stores
         * @summary Get stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStores(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/stores`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the specified store
         * @summary Update store
         * @param {StoreData} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesUpdateStore(body: StoreData, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storesUpdateStore.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesUpdateStore.');
            }
            const localVarPath = `/api/v1/stores/{storeId}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StoreData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a logo for the store
         * @summary Uploads a logo for the store
         * @param {StoreId} storeId The store ID
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesUploadStoreLogo(storeId: StoreId, file?: Blob, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesUploadStoreLogo.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/logo`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoresApi - functional programming interface
 * @export
 */
export const StoresApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Create a new store
         * @summary Create a new store
         * @param {StoreBaseData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesCreateStore(body: StoreBaseData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StoreData> {
            const localVarFetchArgs = StoresApiFetchParamCreator(configuration).storesCreateStore(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Removes the specified store. If there is another user with access, only your access will be removed.
         * @summary Remove Store
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesDeleteStore(storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StoresApiFetchParamCreator(configuration).storesDeleteStore(storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete the store's logo
         * @summary Deletes the store logo
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesDeleteStoreLogo(storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StoresApiFetchParamCreator(configuration).storesDeleteStoreLogo(storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the specified store
         * @summary Get store
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStore(storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StoreData> {
            const localVarFetchArgs = StoresApiFetchParamCreator(configuration).storesGetStore(storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the specified store's roles
         * @summary Get store's roles
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStoreRoles(storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleData> {
            const localVarFetchArgs = StoresApiFetchParamCreator(configuration).storesGetStoreRoles(storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the available stores
         * @summary Get stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStores(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StoreDataList> {
            const localVarFetchArgs = StoresApiFetchParamCreator(configuration).storesGetStores(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the specified store
         * @summary Update store
         * @param {StoreData} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesUpdateStore(body: StoreData, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StoreData> {
            const localVarFetchArgs = StoresApiFetchParamCreator(configuration).storesUpdateStore(body, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Uploads a logo for the store
         * @summary Uploads a logo for the store
         * @param {StoreId} storeId The store ID
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesUploadStoreLogo(storeId: StoreId, file?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationUserData> {
            const localVarFetchArgs = StoresApiFetchParamCreator(configuration).storesUploadStoreLogo(storeId, file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StoresApi - factory interface
 * @export
 */
export const StoresApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new store
         * @summary Create a new store
         * @param {StoreBaseData} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesCreateStore(body: StoreBaseData, options?: any) {
            return StoresApiFp(configuration).storesCreateStore(body, options)(fetch, basePath);
        },
        /**
         * Removes the specified store. If there is another user with access, only your access will be removed.
         * @summary Remove Store
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesDeleteStore(storeId: StoreId, options?: any) {
            return StoresApiFp(configuration).storesDeleteStore(storeId, options)(fetch, basePath);
        },
        /**
         * Delete the store's logo
         * @summary Deletes the store logo
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesDeleteStoreLogo(storeId: StoreId, options?: any) {
            return StoresApiFp(configuration).storesDeleteStoreLogo(storeId, options)(fetch, basePath);
        },
        /**
         * View information about the specified store
         * @summary Get store
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStore(storeId: StoreId, options?: any) {
            return StoresApiFp(configuration).storesGetStore(storeId, options)(fetch, basePath);
        },
        /**
         * View information about the specified store's roles
         * @summary Get store's roles
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStoreRoles(storeId: StoreId, options?: any) {
            return StoresApiFp(configuration).storesGetStoreRoles(storeId, options)(fetch, basePath);
        },
        /**
         * View information about the available stores
         * @summary Get stores
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStores(options?: any) {
            return StoresApiFp(configuration).storesGetStores(options)(fetch, basePath);
        },
        /**
         * Update the specified store
         * @summary Update store
         * @param {StoreData} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesUpdateStore(body: StoreData, storeId: StoreId, options?: any) {
            return StoresApiFp(configuration).storesUpdateStore(body, storeId, options)(fetch, basePath);
        },
        /**
         * Uploads a logo for the store
         * @summary Uploads a logo for the store
         * @param {StoreId} storeId The store ID
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesUploadStoreLogo(storeId: StoreId, file?: Blob, options?: any) {
            return StoresApiFp(configuration).storesUploadStoreLogo(storeId, file, options)(fetch, basePath);
        },
    };
};

/**
 * StoresApi - object-oriented interface
 * @export
 * @class StoresApi
 * @extends {BaseAPI}
 */
export class StoresApi extends BaseAPI {
    /**
     * Create a new store
     * @summary Create a new store
     * @param {StoreBaseData} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresApi
     */
    public storesCreateStore(body: StoreBaseData, options?: any) {
        return StoresApiFp(this.configuration).storesCreateStore(body, options)(this.fetch, this.basePath);
    }

    /**
     * Removes the specified store. If there is another user with access, only your access will be removed.
     * @summary Remove Store
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresApi
     */
    public storesDeleteStore(storeId: StoreId, options?: any) {
        return StoresApiFp(this.configuration).storesDeleteStore(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Delete the store's logo
     * @summary Deletes the store logo
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresApi
     */
    public storesDeleteStoreLogo(storeId: StoreId, options?: any) {
        return StoresApiFp(this.configuration).storesDeleteStoreLogo(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the specified store
     * @summary Get store
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresApi
     */
    public storesGetStore(storeId: StoreId, options?: any) {
        return StoresApiFp(this.configuration).storesGetStore(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the specified store's roles
     * @summary Get store's roles
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresApi
     */
    public storesGetStoreRoles(storeId: StoreId, options?: any) {
        return StoresApiFp(this.configuration).storesGetStoreRoles(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the available stores
     * @summary Get stores
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresApi
     */
    public storesGetStores(options?: any) {
        return StoresApiFp(this.configuration).storesGetStores(options)(this.fetch, this.basePath);
    }

    /**
     * Update the specified store
     * @summary Update store
     * @param {StoreData} body 
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresApi
     */
    public storesUpdateStore(body: StoreData, storeId: StoreId, options?: any) {
        return StoresApiFp(this.configuration).storesUpdateStore(body, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Uploads a logo for the store
     * @summary Uploads a logo for the store
     * @param {StoreId} storeId The store ID
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresApi
     */
    public storesUploadStoreLogo(storeId: StoreId, file?: Blob, options?: any) {
        return StoresApiFp(this.configuration).storesUploadStoreLogo(storeId, file, options)(this.fetch, this.basePath);
    }

}
/**
 * StoresEmailApi - fetch parameter creator
 * @export
 */
export const StoresEmailApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the email settings configured for specific store. The password field will be masked if present.
         * @summary Get store email settings
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStoreEmailSettings(storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesGetStoreEmailSettings.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/email`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an email using the store's SMTP server
         * @summary Send an email for a store
         * @param {EmailSendBody} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesSendStoreEmail(body: EmailSendBody, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storesSendStoreEmail.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesSendStoreEmail.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/email/send`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailSendBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a store's email settings
         * @summary Update store email settings
         * @param {UpdateEmailSettings} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesUpdateStoreEmailSettings(body: UpdateEmailSettings, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storesUpdateStoreEmailSettings.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesUpdateStoreEmailSettings.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/email`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateEmailSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoresEmailApi - functional programming interface
 * @export
 */
export const StoresEmailApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the email settings configured for specific store. The password field will be masked if present.
         * @summary Get store email settings
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStoreEmailSettings(storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetEmailSettings> {
            const localVarFetchArgs = StoresEmailApiFetchParamCreator(configuration).storesGetStoreEmailSettings(storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send an email using the store's SMTP server
         * @summary Send an email for a store
         * @param {EmailSendBody} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesSendStoreEmail(body: EmailSendBody, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StoresEmailApiFetchParamCreator(configuration).storesSendStoreEmail(body, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a store's email settings
         * @summary Update store email settings
         * @param {UpdateEmailSettings} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesUpdateStoreEmailSettings(body: UpdateEmailSettings, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetEmailSettings> {
            const localVarFetchArgs = StoresEmailApiFetchParamCreator(configuration).storesUpdateStoreEmailSettings(body, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StoresEmailApi - factory interface
 * @export
 */
export const StoresEmailApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve the email settings configured for specific store. The password field will be masked if present.
         * @summary Get store email settings
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStoreEmailSettings(storeId: StoreId, options?: any) {
            return StoresEmailApiFp(configuration).storesGetStoreEmailSettings(storeId, options)(fetch, basePath);
        },
        /**
         * Send an email using the store's SMTP server
         * @summary Send an email for a store
         * @param {EmailSendBody} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesSendStoreEmail(body: EmailSendBody, storeId: StoreId, options?: any) {
            return StoresEmailApiFp(configuration).storesSendStoreEmail(body, storeId, options)(fetch, basePath);
        },
        /**
         * Update a store's email settings
         * @summary Update store email settings
         * @param {UpdateEmailSettings} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesUpdateStoreEmailSettings(body: UpdateEmailSettings, storeId: StoreId, options?: any) {
            return StoresEmailApiFp(configuration).storesUpdateStoreEmailSettings(body, storeId, options)(fetch, basePath);
        },
    };
};

/**
 * StoresEmailApi - object-oriented interface
 * @export
 * @class StoresEmailApi
 * @extends {BaseAPI}
 */
export class StoresEmailApi extends BaseAPI {
    /**
     * Retrieve the email settings configured for specific store. The password field will be masked if present.
     * @summary Get store email settings
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresEmailApi
     */
    public storesGetStoreEmailSettings(storeId: StoreId, options?: any) {
        return StoresEmailApiFp(this.configuration).storesGetStoreEmailSettings(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Send an email using the store's SMTP server
     * @summary Send an email for a store
     * @param {EmailSendBody} body 
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresEmailApi
     */
    public storesSendStoreEmail(body: EmailSendBody, storeId: StoreId, options?: any) {
        return StoresEmailApiFp(this.configuration).storesSendStoreEmail(body, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Update a store's email settings
     * @summary Update store email settings
     * @param {UpdateEmailSettings} body 
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresEmailApi
     */
    public storesUpdateStoreEmailSettings(body: UpdateEmailSettings, storeId: StoreId, options?: any) {
        return StoresEmailApiFp(this.configuration).storesUpdateStoreEmailSettings(body, storeId, options)(this.fetch, this.basePath);
    }

}
/**
 * StoresPayoutProcessorsApi - fetch parameter creator
 * @export
 */
export const StoresPayoutProcessorsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get configured store Lightning automated payout processors
         * @summary Get configured store Lightning automated payout processors
         * @param {PayoutMethodId} payoutMethodId The payout method id
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutProcessorsForPaymentMethod(payoutMethodId: PayoutMethodId, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'payoutMethodId' is not null or undefined
            if (payoutMethodId === null || payoutMethodId === undefined) {
                throw new RequiredError('payoutMethodId', 'Required parameter payoutMethodId was null or undefined when calling greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutProcessorsForPaymentMethod.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutProcessorsForPaymentMethod.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payout-processors/LightningAutomatedPayoutSenderFactory/{payoutMethodId}`
                .replace(`{${"payoutMethodId"}}`, encodeURIComponent((payoutMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get configured store Lightning automated payout processors
         * @summary Get configured store Lightning automated payout processors
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutSenderFactory(storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutSenderFactory.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payout-processors/LightningAutomatedPayoutSenderFactory`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update configured store Lightning automated payout processors
         * @summary Update configured store Lightning automated payout processors
         * @param {UpdateLightningAutomatedTransferSettings} body 
         * @param {PayoutMethodId} payoutMethodId The payout method id
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedLightningPayoutProcessorsControllerUpdateStoreLightningAutomatedPayoutProcessor(body: UpdateLightningAutomatedTransferSettings, payoutMethodId: PayoutMethodId, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling greenfieldStoreAutomatedLightningPayoutProcessorsControllerUpdateStoreLightningAutomatedPayoutProcessor.');
            }
            // verify required parameter 'payoutMethodId' is not null or undefined
            if (payoutMethodId === null || payoutMethodId === undefined) {
                throw new RequiredError('payoutMethodId', 'Required parameter payoutMethodId was null or undefined when calling greenfieldStoreAutomatedLightningPayoutProcessorsControllerUpdateStoreLightningAutomatedPayoutProcessor.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling greenfieldStoreAutomatedLightningPayoutProcessorsControllerUpdateStoreLightningAutomatedPayoutProcessor.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payout-processors/LightningAutomatedPayoutSenderFactory/{payoutMethodId}`
                .replace(`{${"payoutMethodId"}}`, encodeURIComponent((payoutMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateLightningAutomatedTransferSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get configured store onchain automated payout processors
         * @summary Get configured store onchain automated payout processors
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedPayoutProcessorsForPaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedPayoutProcessorsForPaymentMethod.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedPayoutProcessorsForPaymentMethod.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payout-processors/OnChainAutomatedPayoutSenderFactory/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get configured store onchain automated payout processors
         * @summary Get configured store onchain automated payout processors
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedTransferSenderFactory(storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedTransferSenderFactory.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payout-processors/OnChainAutomatedTransferSenderFactory`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update configured store onchain automated payout processors
         * @summary Update configured store onchain automated payout processors
         * @param {UpdateOnChainAutomatedTransferSettings} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedPayoutProcessorForPaymentMethod(body: UpdateOnChainAutomatedTransferSettings, paymentMethodId: PaymentMethodId, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedPayoutProcessorForPaymentMethod.');
            }
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedPayoutProcessorForPaymentMethod.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedPayoutProcessorForPaymentMethod.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payout-processors/OnChainAutomatedPayoutSenderFactory/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateOnChainAutomatedTransferSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update configured store onchain automated payout processors
         * @summary Update configured store onchain automated payout processors
         * @param {UpdateOnChainAutomatedTransferSettings} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedTransferSenderFactory(body: UpdateOnChainAutomatedTransferSettings, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedTransferSenderFactory.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedTransferSenderFactory.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payout-processors/OnChainAutomatedTransferSenderFactory`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateOnChainAutomatedTransferSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get store configured payout processors
         * @summary Get store configured payout processors
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePayoutProcessorsGetStorePayoutProcessors(storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storePayoutProcessorsGetStorePayoutProcessors.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payout-processors`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove store configured payout processor
         * @summary Remove store configured payout processor
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} processor The processor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePayoutProcessorsRemoveStorePayoutProcessor(paymentMethodId: PaymentMethodId, storeId: StoreId, processor: string, options: any = {}): FetchArgs {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId', 'Required parameter paymentMethodId was null or undefined when calling storePayoutProcessorsRemoveStorePayoutProcessor.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storePayoutProcessorsRemoveStorePayoutProcessor.');
            }
            // verify required parameter 'processor' is not null or undefined
            if (processor === null || processor === undefined) {
                throw new RequiredError('processor', 'Required parameter processor was null or undefined when calling storePayoutProcessorsRemoveStorePayoutProcessor.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payout-processors/{processor}/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent((paymentMethodId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"processor"}}`, encodeURIComponent((processor)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoresPayoutProcessorsApi - functional programming interface
 * @export
 */
export const StoresPayoutProcessorsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Get configured store Lightning automated payout processors
         * @summary Get configured store Lightning automated payout processors
         * @param {PayoutMethodId} payoutMethodId The payout method id
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutProcessorsForPaymentMethod(payoutMethodId: PayoutMethodId, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LightningAutomatedTransferSettings>> {
            const localVarFetchArgs = StoresPayoutProcessorsApiFetchParamCreator(configuration).greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutProcessorsForPaymentMethod(payoutMethodId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get configured store Lightning automated payout processors
         * @summary Get configured store Lightning automated payout processors
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutSenderFactory(storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LightningAutomatedTransferSettings>> {
            const localVarFetchArgs = StoresPayoutProcessorsApiFetchParamCreator(configuration).greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutSenderFactory(storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update configured store Lightning automated payout processors
         * @summary Update configured store Lightning automated payout processors
         * @param {UpdateLightningAutomatedTransferSettings} body 
         * @param {PayoutMethodId} payoutMethodId The payout method id
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedLightningPayoutProcessorsControllerUpdateStoreLightningAutomatedPayoutProcessor(body: UpdateLightningAutomatedTransferSettings, payoutMethodId: PayoutMethodId, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LightningAutomatedTransferSettings> {
            const localVarFetchArgs = StoresPayoutProcessorsApiFetchParamCreator(configuration).greenfieldStoreAutomatedLightningPayoutProcessorsControllerUpdateStoreLightningAutomatedPayoutProcessor(body, payoutMethodId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get configured store onchain automated payout processors
         * @summary Get configured store onchain automated payout processors
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedPayoutProcessorsForPaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OnChainAutomatedTransferSettings>> {
            const localVarFetchArgs = StoresPayoutProcessorsApiFetchParamCreator(configuration).greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedPayoutProcessorsForPaymentMethod(paymentMethodId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get configured store onchain automated payout processors
         * @summary Get configured store onchain automated payout processors
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedTransferSenderFactory(storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OnChainAutomatedTransferSettings>> {
            const localVarFetchArgs = StoresPayoutProcessorsApiFetchParamCreator(configuration).greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedTransferSenderFactory(storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update configured store onchain automated payout processors
         * @summary Update configured store onchain automated payout processors
         * @param {UpdateOnChainAutomatedTransferSettings} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedPayoutProcessorForPaymentMethod(body: UpdateOnChainAutomatedTransferSettings, paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OnChainAutomatedTransferSettings> {
            const localVarFetchArgs = StoresPayoutProcessorsApiFetchParamCreator(configuration).greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedPayoutProcessorForPaymentMethod(body, paymentMethodId, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update configured store onchain automated payout processors
         * @summary Update configured store onchain automated payout processors
         * @param {UpdateOnChainAutomatedTransferSettings} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedTransferSenderFactory(body: UpdateOnChainAutomatedTransferSettings, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OnChainAutomatedTransferSettings> {
            const localVarFetchArgs = StoresPayoutProcessorsApiFetchParamCreator(configuration).greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedTransferSenderFactory(body, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get store configured payout processors
         * @summary Get store configured payout processors
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePayoutProcessorsGetStorePayoutProcessors(storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PayoutProcessorData>> {
            const localVarFetchArgs = StoresPayoutProcessorsApiFetchParamCreator(configuration).storePayoutProcessorsGetStorePayoutProcessors(storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove store configured payout processor
         * @summary Remove store configured payout processor
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} processor The processor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePayoutProcessorsRemoveStorePayoutProcessor(paymentMethodId: PaymentMethodId, storeId: StoreId, processor: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StoresPayoutProcessorsApiFetchParamCreator(configuration).storePayoutProcessorsRemoveStorePayoutProcessor(paymentMethodId, storeId, processor, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StoresPayoutProcessorsApi - factory interface
 * @export
 */
export const StoresPayoutProcessorsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get configured store Lightning automated payout processors
         * @summary Get configured store Lightning automated payout processors
         * @param {PayoutMethodId} payoutMethodId The payout method id
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutProcessorsForPaymentMethod(payoutMethodId: PayoutMethodId, storeId: StoreId, options?: any) {
            return StoresPayoutProcessorsApiFp(configuration).greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutProcessorsForPaymentMethod(payoutMethodId, storeId, options)(fetch, basePath);
        },
        /**
         * Get configured store Lightning automated payout processors
         * @summary Get configured store Lightning automated payout processors
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutSenderFactory(storeId: StoreId, options?: any) {
            return StoresPayoutProcessorsApiFp(configuration).greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutSenderFactory(storeId, options)(fetch, basePath);
        },
        /**
         * Update configured store Lightning automated payout processors
         * @summary Update configured store Lightning automated payout processors
         * @param {UpdateLightningAutomatedTransferSettings} body 
         * @param {PayoutMethodId} payoutMethodId The payout method id
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedLightningPayoutProcessorsControllerUpdateStoreLightningAutomatedPayoutProcessor(body: UpdateLightningAutomatedTransferSettings, payoutMethodId: PayoutMethodId, storeId: StoreId, options?: any) {
            return StoresPayoutProcessorsApiFp(configuration).greenfieldStoreAutomatedLightningPayoutProcessorsControllerUpdateStoreLightningAutomatedPayoutProcessor(body, payoutMethodId, storeId, options)(fetch, basePath);
        },
        /**
         * Get configured store onchain automated payout processors
         * @summary Get configured store onchain automated payout processors
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedPayoutProcessorsForPaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
            return StoresPayoutProcessorsApiFp(configuration).greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedPayoutProcessorsForPaymentMethod(paymentMethodId, storeId, options)(fetch, basePath);
        },
        /**
         * Get configured store onchain automated payout processors
         * @summary Get configured store onchain automated payout processors
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedTransferSenderFactory(storeId: StoreId, options?: any) {
            return StoresPayoutProcessorsApiFp(configuration).greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedTransferSenderFactory(storeId, options)(fetch, basePath);
        },
        /**
         * Update configured store onchain automated payout processors
         * @summary Update configured store onchain automated payout processors
         * @param {UpdateOnChainAutomatedTransferSettings} body 
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedPayoutProcessorForPaymentMethod(body: UpdateOnChainAutomatedTransferSettings, paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
            return StoresPayoutProcessorsApiFp(configuration).greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedPayoutProcessorForPaymentMethod(body, paymentMethodId, storeId, options)(fetch, basePath);
        },
        /**
         * Update configured store onchain automated payout processors
         * @summary Update configured store onchain automated payout processors
         * @param {UpdateOnChainAutomatedTransferSettings} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedTransferSenderFactory(body: UpdateOnChainAutomatedTransferSettings, storeId: StoreId, options?: any) {
            return StoresPayoutProcessorsApiFp(configuration).greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedTransferSenderFactory(body, storeId, options)(fetch, basePath);
        },
        /**
         * Get store configured payout processors
         * @summary Get store configured payout processors
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePayoutProcessorsGetStorePayoutProcessors(storeId: StoreId, options?: any) {
            return StoresPayoutProcessorsApiFp(configuration).storePayoutProcessorsGetStorePayoutProcessors(storeId, options)(fetch, basePath);
        },
        /**
         * Remove store configured payout processor
         * @summary Remove store configured payout processor
         * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
         * @param {StoreId} storeId The store ID
         * @param {string} processor The processor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePayoutProcessorsRemoveStorePayoutProcessor(paymentMethodId: PaymentMethodId, storeId: StoreId, processor: string, options?: any) {
            return StoresPayoutProcessorsApiFp(configuration).storePayoutProcessorsRemoveStorePayoutProcessor(paymentMethodId, storeId, processor, options)(fetch, basePath);
        },
    };
};

/**
 * StoresPayoutProcessorsApi - object-oriented interface
 * @export
 * @class StoresPayoutProcessorsApi
 * @extends {BaseAPI}
 */
export class StoresPayoutProcessorsApi extends BaseAPI {
    /**
     * Get configured store Lightning automated payout processors
     * @summary Get configured store Lightning automated payout processors
     * @param {PayoutMethodId} payoutMethodId The payout method id
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutProcessorsApi
     */
    public greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutProcessorsForPaymentMethod(payoutMethodId: PayoutMethodId, storeId: StoreId, options?: any) {
        return StoresPayoutProcessorsApiFp(this.configuration).greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutProcessorsForPaymentMethod(payoutMethodId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Get configured store Lightning automated payout processors
     * @summary Get configured store Lightning automated payout processors
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutProcessorsApi
     */
    public greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutSenderFactory(storeId: StoreId, options?: any) {
        return StoresPayoutProcessorsApiFp(this.configuration).greenfieldStoreAutomatedLightningPayoutProcessorsControllerGetStoreLightningAutomatedPayoutSenderFactory(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Update configured store Lightning automated payout processors
     * @summary Update configured store Lightning automated payout processors
     * @param {UpdateLightningAutomatedTransferSettings} body 
     * @param {PayoutMethodId} payoutMethodId The payout method id
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutProcessorsApi
     */
    public greenfieldStoreAutomatedLightningPayoutProcessorsControllerUpdateStoreLightningAutomatedPayoutProcessor(body: UpdateLightningAutomatedTransferSettings, payoutMethodId: PayoutMethodId, storeId: StoreId, options?: any) {
        return StoresPayoutProcessorsApiFp(this.configuration).greenfieldStoreAutomatedLightningPayoutProcessorsControllerUpdateStoreLightningAutomatedPayoutProcessor(body, payoutMethodId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Get configured store onchain automated payout processors
     * @summary Get configured store onchain automated payout processors
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutProcessorsApi
     */
    public greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedPayoutProcessorsForPaymentMethod(paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
        return StoresPayoutProcessorsApiFp(this.configuration).greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedPayoutProcessorsForPaymentMethod(paymentMethodId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Get configured store onchain automated payout processors
     * @summary Get configured store onchain automated payout processors
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutProcessorsApi
     */
    public greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedTransferSenderFactory(storeId: StoreId, options?: any) {
        return StoresPayoutProcessorsApiFp(this.configuration).greenfieldStoreAutomatedOnChainPayoutProcessorsControllerGetStoreOnChainAutomatedTransferSenderFactory(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Update configured store onchain automated payout processors
     * @summary Update configured store onchain automated payout processors
     * @param {UpdateOnChainAutomatedTransferSettings} body 
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutProcessorsApi
     */
    public greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedPayoutProcessorForPaymentMethod(body: UpdateOnChainAutomatedTransferSettings, paymentMethodId: PaymentMethodId, storeId: StoreId, options?: any) {
        return StoresPayoutProcessorsApiFp(this.configuration).greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedPayoutProcessorForPaymentMethod(body, paymentMethodId, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Update configured store onchain automated payout processors
     * @summary Update configured store onchain automated payout processors
     * @param {UpdateOnChainAutomatedTransferSettings} body 
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutProcessorsApi
     */
    public greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedTransferSenderFactory(body: UpdateOnChainAutomatedTransferSettings, storeId: StoreId, options?: any) {
        return StoresPayoutProcessorsApiFp(this.configuration).greenfieldStoreAutomatedOnChainPayoutProcessorsControllerUpdateStoreOnChainAutomatedTransferSenderFactory(body, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Get store configured payout processors
     * @summary Get store configured payout processors
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutProcessorsApi
     */
    public storePayoutProcessorsGetStorePayoutProcessors(storeId: StoreId, options?: any) {
        return StoresPayoutProcessorsApiFp(this.configuration).storePayoutProcessorsGetStorePayoutProcessors(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Remove store configured payout processor
     * @summary Remove store configured payout processor
     * @param {PaymentMethodId} paymentMethodId The payment method id of the payment method to update
     * @param {StoreId} storeId The store ID
     * @param {string} processor The processor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutProcessorsApi
     */
    public storePayoutProcessorsRemoveStorePayoutProcessor(paymentMethodId: PaymentMethodId, storeId: StoreId, processor: string, options?: any) {
        return StoresPayoutProcessorsApiFp(this.configuration).storePayoutProcessorsRemoveStorePayoutProcessor(paymentMethodId, storeId, processor, options)(this.fetch, this.basePath);
    }

}
/**
 * StoresPayoutsApi - fetch parameter creator
 * @export
 */
export const StoresPayoutsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get payout
         * @summary Get Payout
         * @param {StoreId} storeId The store ID
         * @param {string} payoutId The ID of the payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorePayout(storeId: StoreId, payoutId: string, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling getStorePayout.');
            }
            // verify required parameter 'payoutId' is not null or undefined
            if (payoutId === null || payoutId === undefined) {
                throw new RequiredError('payoutId', 'Required parameter payoutId was null or undefined when calling getStorePayout.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payouts/{payoutId}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"payoutId"}}`, encodeURIComponent((payoutId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new payout
         * @summary Create Payout
         * @param {CreatePayoutThroughStoreRequest} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutsCreatePayoutThroughStore(body: CreatePayoutThroughStoreRequest, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling payoutsCreatePayoutThroughStore.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling payoutsCreatePayoutThroughStore.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payouts`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreatePayoutThroughStoreRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Approve a payout
         * @summary Approve Payout
         * @param {StoreId} storeId The store ID
         * @param {string} payoutId The ID of the payout
         * @param {PayoutsPayoutIdBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsApprovePayout(storeId: StoreId, payoutId: string, body?: PayoutsPayoutIdBody, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling pullPaymentsApprovePayout.');
            }
            // verify required parameter 'payoutId' is not null or undefined
            if (payoutId === null || payoutId === undefined) {
                throw new RequiredError('payoutId', 'Required parameter payoutId was null or undefined when calling pullPaymentsApprovePayout.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payouts/{payoutId}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"payoutId"}}`, encodeURIComponent((payoutId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PayoutsPayoutIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel the payout
         * @summary Cancel Payout
         * @param {StoreId} storeId The store ID
         * @param {string} payoutId The ID of the payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsCancelPayout(storeId: StoreId, payoutId: string, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling pullPaymentsCancelPayout.');
            }
            // verify required parameter 'payoutId' is not null or undefined
            if (payoutId === null || payoutId === undefined) {
                throw new RequiredError('payoutId', 'Required parameter payoutId was null or undefined when calling pullPaymentsCancelPayout.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payouts/{payoutId}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"payoutId"}}`, encodeURIComponent((payoutId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payouts
         * @summary Get Store Payouts
         * @param {StoreId} storeId The store ID
         * @param {boolean} [includeCancelled] Whether this should list cancelled payouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetStorePayouts(storeId: StoreId, includeCancelled?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling pullPaymentsGetStorePayouts.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payouts`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeCancelled !== undefined) {
                localVarQueryParameter['includeCancelled'] = includeCancelled;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark a payout with a state
         * @summary Mark Payout
         * @param {StoreId} storeId The store ID
         * @param {string} payoutId The ID of the payout
         * @param {PayoutIdMarkBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsMarkPayout(storeId: StoreId, payoutId: string, body?: PayoutIdMarkBody, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling pullPaymentsMarkPayout.');
            }
            // verify required parameter 'payoutId' is not null or undefined
            if (payoutId === null || payoutId === undefined) {
                throw new RequiredError('payoutId', 'Required parameter payoutId was null or undefined when calling pullPaymentsMarkPayout.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payouts/{payoutId}/mark`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"payoutId"}}`, encodeURIComponent((payoutId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PayoutIdMarkBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark a payout as paid
         * @summary Mark Payout as Paid
         * @param {StoreId} storeId The store ID
         * @param {string} payoutId The ID of the payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsMarkPayoutPaid(storeId: StoreId, payoutId: string, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling pullPaymentsMarkPayoutPaid.');
            }
            // verify required parameter 'payoutId' is not null or undefined
            if (payoutId === null || payoutId === undefined) {
                throw new RequiredError('payoutId', 'Required parameter payoutId was null or undefined when calling pullPaymentsMarkPayoutPaid.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/payouts/{payoutId}/mark-paid`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"payoutId"}}`, encodeURIComponent((payoutId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoresPayoutsApi - functional programming interface
 * @export
 */
export const StoresPayoutsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Get payout
         * @summary Get Payout
         * @param {StoreId} storeId The store ID
         * @param {string} payoutId The ID of the payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorePayout(storeId: StoreId, payoutId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayoutData> {
            const localVarFetchArgs = StoresPayoutsApiFetchParamCreator(configuration).getStorePayout(storeId, payoutId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new payout
         * @summary Create Payout
         * @param {CreatePayoutThroughStoreRequest} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutsCreatePayoutThroughStore(body: CreatePayoutThroughStoreRequest, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayoutData> {
            const localVarFetchArgs = StoresPayoutsApiFetchParamCreator(configuration).payoutsCreatePayoutThroughStore(body, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Approve a payout
         * @summary Approve Payout
         * @param {StoreId} storeId The store ID
         * @param {string} payoutId The ID of the payout
         * @param {PayoutsPayoutIdBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsApprovePayout(storeId: StoreId, payoutId: string, body?: PayoutsPayoutIdBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayoutData> {
            const localVarFetchArgs = StoresPayoutsApiFetchParamCreator(configuration).pullPaymentsApprovePayout(storeId, payoutId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Cancel the payout
         * @summary Cancel Payout
         * @param {StoreId} storeId The store ID
         * @param {string} payoutId The ID of the payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsCancelPayout(storeId: StoreId, payoutId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StoresPayoutsApiFetchParamCreator(configuration).pullPaymentsCancelPayout(storeId, payoutId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get payouts
         * @summary Get Store Payouts
         * @param {StoreId} storeId The store ID
         * @param {boolean} [includeCancelled] Whether this should list cancelled payouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetStorePayouts(storeId: StoreId, includeCancelled?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PayoutDataList> {
            const localVarFetchArgs = StoresPayoutsApiFetchParamCreator(configuration).pullPaymentsGetStorePayouts(storeId, includeCancelled, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Mark a payout with a state
         * @summary Mark Payout
         * @param {StoreId} storeId The store ID
         * @param {string} payoutId The ID of the payout
         * @param {PayoutIdMarkBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsMarkPayout(storeId: StoreId, payoutId: string, body?: PayoutIdMarkBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StoresPayoutsApiFetchParamCreator(configuration).pullPaymentsMarkPayout(storeId, payoutId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Mark a payout as paid
         * @summary Mark Payout as Paid
         * @param {StoreId} storeId The store ID
         * @param {string} payoutId The ID of the payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsMarkPayoutPaid(storeId: StoreId, payoutId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StoresPayoutsApiFetchParamCreator(configuration).pullPaymentsMarkPayoutPaid(storeId, payoutId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StoresPayoutsApi - factory interface
 * @export
 */
export const StoresPayoutsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get payout
         * @summary Get Payout
         * @param {StoreId} storeId The store ID
         * @param {string} payoutId The ID of the payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorePayout(storeId: StoreId, payoutId: string, options?: any) {
            return StoresPayoutsApiFp(configuration).getStorePayout(storeId, payoutId, options)(fetch, basePath);
        },
        /**
         * Create a new payout
         * @summary Create Payout
         * @param {CreatePayoutThroughStoreRequest} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutsCreatePayoutThroughStore(body: CreatePayoutThroughStoreRequest, storeId: StoreId, options?: any) {
            return StoresPayoutsApiFp(configuration).payoutsCreatePayoutThroughStore(body, storeId, options)(fetch, basePath);
        },
        /**
         * Approve a payout
         * @summary Approve Payout
         * @param {StoreId} storeId The store ID
         * @param {string} payoutId The ID of the payout
         * @param {PayoutsPayoutIdBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsApprovePayout(storeId: StoreId, payoutId: string, body?: PayoutsPayoutIdBody, options?: any) {
            return StoresPayoutsApiFp(configuration).pullPaymentsApprovePayout(storeId, payoutId, body, options)(fetch, basePath);
        },
        /**
         * Cancel the payout
         * @summary Cancel Payout
         * @param {StoreId} storeId The store ID
         * @param {string} payoutId The ID of the payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsCancelPayout(storeId: StoreId, payoutId: string, options?: any) {
            return StoresPayoutsApiFp(configuration).pullPaymentsCancelPayout(storeId, payoutId, options)(fetch, basePath);
        },
        /**
         * Get payouts
         * @summary Get Store Payouts
         * @param {StoreId} storeId The store ID
         * @param {boolean} [includeCancelled] Whether this should list cancelled payouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsGetStorePayouts(storeId: StoreId, includeCancelled?: boolean, options?: any) {
            return StoresPayoutsApiFp(configuration).pullPaymentsGetStorePayouts(storeId, includeCancelled, options)(fetch, basePath);
        },
        /**
         * Mark a payout with a state
         * @summary Mark Payout
         * @param {StoreId} storeId The store ID
         * @param {string} payoutId The ID of the payout
         * @param {PayoutIdMarkBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsMarkPayout(storeId: StoreId, payoutId: string, body?: PayoutIdMarkBody, options?: any) {
            return StoresPayoutsApiFp(configuration).pullPaymentsMarkPayout(storeId, payoutId, body, options)(fetch, basePath);
        },
        /**
         * Mark a payout as paid
         * @summary Mark Payout as Paid
         * @param {StoreId} storeId The store ID
         * @param {string} payoutId The ID of the payout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pullPaymentsMarkPayoutPaid(storeId: StoreId, payoutId: string, options?: any) {
            return StoresPayoutsApiFp(configuration).pullPaymentsMarkPayoutPaid(storeId, payoutId, options)(fetch, basePath);
        },
    };
};

/**
 * StoresPayoutsApi - object-oriented interface
 * @export
 * @class StoresPayoutsApi
 * @extends {BaseAPI}
 */
export class StoresPayoutsApi extends BaseAPI {
    /**
     * Get payout
     * @summary Get Payout
     * @param {StoreId} storeId The store ID
     * @param {string} payoutId The ID of the payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutsApi
     */
    public getStorePayout(storeId: StoreId, payoutId: string, options?: any) {
        return StoresPayoutsApiFp(this.configuration).getStorePayout(storeId, payoutId, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new payout
     * @summary Create Payout
     * @param {CreatePayoutThroughStoreRequest} body 
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutsApi
     */
    public payoutsCreatePayoutThroughStore(body: CreatePayoutThroughStoreRequest, storeId: StoreId, options?: any) {
        return StoresPayoutsApiFp(this.configuration).payoutsCreatePayoutThroughStore(body, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Approve a payout
     * @summary Approve Payout
     * @param {StoreId} storeId The store ID
     * @param {string} payoutId The ID of the payout
     * @param {PayoutsPayoutIdBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutsApi
     */
    public pullPaymentsApprovePayout(storeId: StoreId, payoutId: string, body?: PayoutsPayoutIdBody, options?: any) {
        return StoresPayoutsApiFp(this.configuration).pullPaymentsApprovePayout(storeId, payoutId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Cancel the payout
     * @summary Cancel Payout
     * @param {StoreId} storeId The store ID
     * @param {string} payoutId The ID of the payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutsApi
     */
    public pullPaymentsCancelPayout(storeId: StoreId, payoutId: string, options?: any) {
        return StoresPayoutsApiFp(this.configuration).pullPaymentsCancelPayout(storeId, payoutId, options)(this.fetch, this.basePath);
    }

    /**
     * Get payouts
     * @summary Get Store Payouts
     * @param {StoreId} storeId The store ID
     * @param {boolean} [includeCancelled] Whether this should list cancelled payouts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutsApi
     */
    public pullPaymentsGetStorePayouts(storeId: StoreId, includeCancelled?: boolean, options?: any) {
        return StoresPayoutsApiFp(this.configuration).pullPaymentsGetStorePayouts(storeId, includeCancelled, options)(this.fetch, this.basePath);
    }

    /**
     * Mark a payout with a state
     * @summary Mark Payout
     * @param {StoreId} storeId The store ID
     * @param {string} payoutId The ID of the payout
     * @param {PayoutIdMarkBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutsApi
     */
    public pullPaymentsMarkPayout(storeId: StoreId, payoutId: string, body?: PayoutIdMarkBody, options?: any) {
        return StoresPayoutsApiFp(this.configuration).pullPaymentsMarkPayout(storeId, payoutId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Mark a payout as paid
     * @summary Mark Payout as Paid
     * @param {StoreId} storeId The store ID
     * @param {string} payoutId The ID of the payout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresPayoutsApi
     */
    public pullPaymentsMarkPayoutPaid(storeId: StoreId, payoutId: string, options?: any) {
        return StoresPayoutsApiFp(this.configuration).pullPaymentsMarkPayoutPaid(storeId, payoutId, options)(this.fetch, this.basePath);
    }

}
/**
 * StoresRatesApi - fetch parameter creator
 * @export
 */
export const StoresRatesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get rates on the store
         * @summary Get rates
         * @param {StoreId} storeId The store ID
         * @param {Array<string>} [currencyPair] The currency pairs to fetch rates for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStoreRates(storeId: StoreId, currencyPair?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesGetStoreRates.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/rates`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (currencyPair) {
                localVarQueryParameter['currencyPair'] = currencyPair;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoresRatesApi - functional programming interface
 * @export
 */
export const StoresRatesApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Get rates on the store
         * @summary Get rates
         * @param {StoreId} storeId The store ID
         * @param {Array<string>} [currencyPair] The currency pairs to fetch rates for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStoreRates(storeId: StoreId, currencyPair?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<StoreRateResult>> {
            const localVarFetchArgs = StoresRatesApiFetchParamCreator(configuration).storesGetStoreRates(storeId, currencyPair, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StoresRatesApi - factory interface
 * @export
 */
export const StoresRatesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get rates on the store
         * @summary Get rates
         * @param {StoreId} storeId The store ID
         * @param {Array<string>} [currencyPair] The currency pairs to fetch rates for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStoreRates(storeId: StoreId, currencyPair?: Array<string>, options?: any) {
            return StoresRatesApiFp(configuration).storesGetStoreRates(storeId, currencyPair, options)(fetch, basePath);
        },
    };
};

/**
 * StoresRatesApi - object-oriented interface
 * @export
 * @class StoresRatesApi
 * @extends {BaseAPI}
 */
export class StoresRatesApi extends BaseAPI {
    /**
     * Get rates on the store
     * @summary Get rates
     * @param {StoreId} storeId The store ID
     * @param {Array<string>} [currencyPair] The currency pairs to fetch rates for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresRatesApi
     */
    public storesGetStoreRates(storeId: StoreId, currencyPair?: Array<string>, options?: any) {
        return StoresRatesApiFp(this.configuration).storesGetStoreRates(storeId, currencyPair, options)(this.fetch, this.basePath);
    }

}
/**
 * StoresRatesConfigApi - fetch parameter creator
 * @export
 */
export const StoresRatesConfigApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * View rate settings of the specified store
         * @summary Get store rate settings
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStoreRateConfiguration(storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesGetStoreRateConfiguration.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/rates/configuration`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Preview rate configuration results before you set it on the store
         * @summary Preview rate configuration results
         * @param {StoreRateConfiguration} body 
         * @param {StoreId} storeId The store ID
         * @param {Array<string>} [currencyPair] The currency pairs to preview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesPreviewStoreRateConfiguration(body: StoreRateConfiguration, storeId: StoreId, currencyPair?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storesPreviewStoreRateConfiguration.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesPreviewStoreRateConfiguration.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/rates/configuration/preview`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (currencyPair) {
                localVarQueryParameter['currencyPair'] = currencyPair;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StoreRateConfiguration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a store's rate settings
         * @summary Update store rate settings
         * @param {StoreRateConfiguration} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesUpdateStoreRateConfiguration(body: StoreRateConfiguration, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storesUpdateStoreRateConfiguration.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesUpdateStoreRateConfiguration.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/rates/configuration`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StoreRateConfiguration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoresRatesConfigApi - functional programming interface
 * @export
 */
export const StoresRatesConfigApiFp = function (configuration?: Configuration) {
    return {
        /**
         * View rate settings of the specified store
         * @summary Get store rate settings
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStoreRateConfiguration(storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StoreRateConfiguration> {
            const localVarFetchArgs = StoresRatesConfigApiFetchParamCreator(configuration).storesGetStoreRateConfiguration(storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Preview rate configuration results before you set it on the store
         * @summary Preview rate configuration results
         * @param {StoreRateConfiguration} body 
         * @param {StoreId} storeId The store ID
         * @param {Array<string>} [currencyPair] The currency pairs to preview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesPreviewStoreRateConfiguration(body: StoreRateConfiguration, storeId: StoreId, currencyPair?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<StoreRateResult>> {
            const localVarFetchArgs = StoresRatesConfigApiFetchParamCreator(configuration).storesPreviewStoreRateConfiguration(body, storeId, currencyPair, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a store's rate settings
         * @summary Update store rate settings
         * @param {StoreRateConfiguration} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesUpdateStoreRateConfiguration(body: StoreRateConfiguration, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StoreRateConfiguration> {
            const localVarFetchArgs = StoresRatesConfigApiFetchParamCreator(configuration).storesUpdateStoreRateConfiguration(body, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StoresRatesConfigApi - factory interface
 * @export
 */
export const StoresRatesConfigApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * View rate settings of the specified store
         * @summary Get store rate settings
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStoreRateConfiguration(storeId: StoreId, options?: any) {
            return StoresRatesConfigApiFp(configuration).storesGetStoreRateConfiguration(storeId, options)(fetch, basePath);
        },
        /**
         * Preview rate configuration results before you set it on the store
         * @summary Preview rate configuration results
         * @param {StoreRateConfiguration} body 
         * @param {StoreId} storeId The store ID
         * @param {Array<string>} [currencyPair] The currency pairs to preview
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesPreviewStoreRateConfiguration(body: StoreRateConfiguration, storeId: StoreId, currencyPair?: Array<string>, options?: any) {
            return StoresRatesConfigApiFp(configuration).storesPreviewStoreRateConfiguration(body, storeId, currencyPair, options)(fetch, basePath);
        },
        /**
         * Update a store's rate settings
         * @summary Update store rate settings
         * @param {StoreRateConfiguration} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesUpdateStoreRateConfiguration(body: StoreRateConfiguration, storeId: StoreId, options?: any) {
            return StoresRatesConfigApiFp(configuration).storesUpdateStoreRateConfiguration(body, storeId, options)(fetch, basePath);
        },
    };
};

/**
 * StoresRatesConfigApi - object-oriented interface
 * @export
 * @class StoresRatesConfigApi
 * @extends {BaseAPI}
 */
export class StoresRatesConfigApi extends BaseAPI {
    /**
     * View rate settings of the specified store
     * @summary Get store rate settings
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresRatesConfigApi
     */
    public storesGetStoreRateConfiguration(storeId: StoreId, options?: any) {
        return StoresRatesConfigApiFp(this.configuration).storesGetStoreRateConfiguration(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Preview rate configuration results before you set it on the store
     * @summary Preview rate configuration results
     * @param {StoreRateConfiguration} body 
     * @param {StoreId} storeId The store ID
     * @param {Array<string>} [currencyPair] The currency pairs to preview
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresRatesConfigApi
     */
    public storesPreviewStoreRateConfiguration(body: StoreRateConfiguration, storeId: StoreId, currencyPair?: Array<string>, options?: any) {
        return StoresRatesConfigApiFp(this.configuration).storesPreviewStoreRateConfiguration(body, storeId, currencyPair, options)(this.fetch, this.basePath);
    }

    /**
     * Update a store's rate settings
     * @summary Update store rate settings
     * @param {StoreRateConfiguration} body 
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresRatesConfigApi
     */
    public storesUpdateStoreRateConfiguration(body: StoreRateConfiguration, storeId: StoreId, options?: any) {
        return StoresRatesConfigApiFp(this.configuration).storesUpdateStoreRateConfiguration(body, storeId, options)(this.fetch, this.basePath);
    }

}
/**
 * StoresUsersApi - fetch parameter creator
 * @export
 */
export const StoresUsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a store user
         * @summary Add a store user
         * @param {StoreUserData} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesAddStoreUser(body: StoreUserData, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storesAddStoreUser.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesAddStoreUser.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/users`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StoreUserData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View users of the specified store
         * @summary Get store users
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStoreUsers(storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesGetStoreUsers.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/users`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the specified store user. If there is no other owner, this endpoint will fail.
         * @summary Remove Store User
         * @param {StoreId} storeId The store ID
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesRemoveStoreUser(storeId: StoreId, idOrEmail: string, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesRemoveStoreUser.');
            }
            // verify required parameter 'idOrEmail' is not null or undefined
            if (idOrEmail === null || idOrEmail === undefined) {
                throw new RequiredError('idOrEmail', 'Required parameter idOrEmail was null or undefined when calling storesRemoveStoreUser.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/users/{idOrEmail}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"idOrEmail"}}`, encodeURIComponent((idOrEmail)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a store user
         * @summary Updates a store user
         * @param {StoreUserData} body 
         * @param {StoreId} storeId The store ID
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesUpdateStoreUser(body: StoreUserData, storeId: StoreId, idOrEmail: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling storesUpdateStoreUser.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling storesUpdateStoreUser.');
            }
            // verify required parameter 'idOrEmail' is not null or undefined
            if (idOrEmail === null || idOrEmail === undefined) {
                throw new RequiredError('idOrEmail', 'Required parameter idOrEmail was null or undefined when calling storesUpdateStoreUser.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/users/{idOrEmail}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"idOrEmail"}}`, encodeURIComponent((idOrEmail)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StoreUserData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoresUsersApi - functional programming interface
 * @export
 */
export const StoresUsersApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Add a store user
         * @summary Add a store user
         * @param {StoreUserData} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesAddStoreUser(body: StoreUserData, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StoresUsersApiFetchParamCreator(configuration).storesAddStoreUser(body, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View users of the specified store
         * @summary Get store users
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStoreUsers(storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StoreUserDataList> {
            const localVarFetchArgs = StoresUsersApiFetchParamCreator(configuration).storesGetStoreUsers(storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Removes the specified store user. If there is no other owner, this endpoint will fail.
         * @summary Remove Store User
         * @param {StoreId} storeId The store ID
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesRemoveStoreUser(storeId: StoreId, idOrEmail: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StoresUsersApiFetchParamCreator(configuration).storesRemoveStoreUser(storeId, idOrEmail, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a store user
         * @summary Updates a store user
         * @param {StoreUserData} body 
         * @param {StoreId} storeId The store ID
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesUpdateStoreUser(body: StoreUserData, storeId: StoreId, idOrEmail: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StoresUsersApiFetchParamCreator(configuration).storesUpdateStoreUser(body, storeId, idOrEmail, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StoresUsersApi - factory interface
 * @export
 */
export const StoresUsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add a store user
         * @summary Add a store user
         * @param {StoreUserData} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesAddStoreUser(body: StoreUserData, storeId: StoreId, options?: any) {
            return StoresUsersApiFp(configuration).storesAddStoreUser(body, storeId, options)(fetch, basePath);
        },
        /**
         * View users of the specified store
         * @summary Get store users
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesGetStoreUsers(storeId: StoreId, options?: any) {
            return StoresUsersApiFp(configuration).storesGetStoreUsers(storeId, options)(fetch, basePath);
        },
        /**
         * Removes the specified store user. If there is no other owner, this endpoint will fail.
         * @summary Remove Store User
         * @param {StoreId} storeId The store ID
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesRemoveStoreUser(storeId: StoreId, idOrEmail: string, options?: any) {
            return StoresUsersApiFp(configuration).storesRemoveStoreUser(storeId, idOrEmail, options)(fetch, basePath);
        },
        /**
         * Updates a store user
         * @summary Updates a store user
         * @param {StoreUserData} body 
         * @param {StoreId} storeId The store ID
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storesUpdateStoreUser(body: StoreUserData, storeId: StoreId, idOrEmail: string, options?: any) {
            return StoresUsersApiFp(configuration).storesUpdateStoreUser(body, storeId, idOrEmail, options)(fetch, basePath);
        },
    };
};

/**
 * StoresUsersApi - object-oriented interface
 * @export
 * @class StoresUsersApi
 * @extends {BaseAPI}
 */
export class StoresUsersApi extends BaseAPI {
    /**
     * Add a store user
     * @summary Add a store user
     * @param {StoreUserData} body 
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresUsersApi
     */
    public storesAddStoreUser(body: StoreUserData, storeId: StoreId, options?: any) {
        return StoresUsersApiFp(this.configuration).storesAddStoreUser(body, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * View users of the specified store
     * @summary Get store users
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresUsersApi
     */
    public storesGetStoreUsers(storeId: StoreId, options?: any) {
        return StoresUsersApiFp(this.configuration).storesGetStoreUsers(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Removes the specified store user. If there is no other owner, this endpoint will fail.
     * @summary Remove Store User
     * @param {StoreId} storeId The store ID
     * @param {string} idOrEmail The user&#x27;s id or email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresUsersApi
     */
    public storesRemoveStoreUser(storeId: StoreId, idOrEmail: string, options?: any) {
        return StoresUsersApiFp(this.configuration).storesRemoveStoreUser(storeId, idOrEmail, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a store user
     * @summary Updates a store user
     * @param {StoreUserData} body 
     * @param {StoreId} storeId The store ID
     * @param {string} idOrEmail The user&#x27;s id or email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoresUsersApi
     */
    public storesUpdateStoreUser(body: StoreUserData, storeId: StoreId, idOrEmail: string, options?: any) {
        return StoresUsersApiFp(this.configuration).storesUpdateStoreUser(body, storeId, idOrEmail, options)(this.fetch, this.basePath);
    }

}
/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user.  This operation can be called without authentication in any of this cases: * There is not any administrator yet on the server, * User registrations are not disabled in the server's policies.  If the first administrator is created by this call, user registrations are automatically disabled.
         * @summary Create user
         * @param {V1UsersBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreateUser(body: V1UsersBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling usersCreateUser.');
            }
            const localVarPath = `/api/v1/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1UsersBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes user profile and associated user data for user making the request
         * @summary Deletes user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteCurrentUser(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the user profile picture
         * @summary Deletes user profile picture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteCurrentUserProfilePicture(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users/me/picture`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user.  Must be an admin to perform this operation.  Attempting to delete the only admin user will not succeed.  All data associated with the user will be deleted as well if the operation succeeds.
         * @summary Delete user
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteUser(idOrEmail: string, options: any = {}): FetchArgs {
            // verify required parameter 'idOrEmail' is not null or undefined
            if (idOrEmail === null || idOrEmail === undefined) {
                throw new RequiredError('idOrEmail', 'Required parameter idOrEmail was null or undefined when calling usersDeleteUser.');
            }
            const localVarPath = `/api/v1/users/{idOrEmail}`
                .replace(`{${"idOrEmail"}}`, encodeURIComponent((idOrEmail)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View information about the current user
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetCurrentUser(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get 1 user by ID or Email.
         * @summary Get user by ID or Email
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetUser(idOrEmail: string, options: any = {}): FetchArgs {
            // verify required parameter 'idOrEmail' is not null or undefined
            if (idOrEmail === null || idOrEmail === undefined) {
                throw new RequiredError('idOrEmail', 'Required parameter idOrEmail was null or undefined when calling usersGetUser.');
            }
            const localVarPath = `/api/v1/users/{idOrEmail}`
                .replace(`{${"idOrEmail"}}`, encodeURIComponent((idOrEmail)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Load all users that exist.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetUsers(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Approve or unapprove a user.  Must be an admin to perform this operation.  Attempting to (un)approve a user for which this requirement does not exist will not succeed.
         * @summary Toggle user approval
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {ApproveUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersToggleUserApproval(idOrEmail: string, body?: ApproveUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'idOrEmail' is not null or undefined
            if (idOrEmail === null || idOrEmail === undefined) {
                throw new RequiredError('idOrEmail', 'Required parameter idOrEmail was null or undefined when calling usersToggleUserApproval.');
            }
            const localVarPath = `/api/v1/users/{idOrEmail}/approve`
                .replace(`{${"idOrEmail"}}`, encodeURIComponent((idOrEmail)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ApproveUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lock or unlock a user.  Must be an admin to perform this operation.  Attempting to lock the only admin user will not succeed.
         * @summary Toggle user lock out
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {LockUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersToggleUserLock(idOrEmail: string, body?: LockUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'idOrEmail' is not null or undefined
            if (idOrEmail === null || idOrEmail === undefined) {
                throw new RequiredError('idOrEmail', 'Required parameter idOrEmail was null or undefined when calling usersToggleUserLock.');
            }
            const localVarPath = `/api/v1/users/{idOrEmail}/lock`
                .replace(`{${"idOrEmail"}}`, encodeURIComponent((idOrEmail)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LockUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the current user
         * @summary Update current user information
         * @param {UsersMeBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdateCurrentUser(body: UsersMeBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling usersUpdateCurrentUser.');
            }
            const localVarPath = `/api/v1/users/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UsersMeBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a profile picture for the current user
         * @summary Uploads a profile picture for the current user
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUploadCurrentUserProfilePicture(file?: Blob, options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users/me/picture`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user.  This operation can be called without authentication in any of this cases: * There is not any administrator yet on the server, * User registrations are not disabled in the server's policies.  If the first administrator is created by this call, user registrations are automatically disabled.
         * @summary Create user
         * @param {V1UsersBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreateUser(body: V1UsersBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationUserData> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersCreateUser(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes user profile and associated user data for user making the request
         * @summary Deletes user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteCurrentUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersDeleteCurrentUser(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes the user profile picture
         * @summary Deletes user profile picture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteCurrentUserProfilePicture(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersDeleteCurrentUserProfilePicture(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a user.  Must be an admin to perform this operation.  Attempting to delete the only admin user will not succeed.  All data associated with the user will be deleted as well if the operation succeeds.
         * @summary Delete user
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteUser(idOrEmail: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersDeleteUser(idOrEmail, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View information about the current user
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetCurrentUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationUserData> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersGetCurrentUser(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get 1 user by ID or Email.
         * @summary Get user by ID or Email
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetUser(idOrEmail: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationUserData> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersGetUser(idOrEmail, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Load all users that exist.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersGetUsers(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Approve or unapprove a user.  Must be an admin to perform this operation.  Attempting to (un)approve a user for which this requirement does not exist will not succeed.
         * @summary Toggle user approval
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {ApproveUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersToggleUserApproval(idOrEmail: string, body?: ApproveUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersToggleUserApproval(idOrEmail, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Lock or unlock a user.  Must be an admin to perform this operation.  Attempting to lock the only admin user will not succeed.
         * @summary Toggle user lock out
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {LockUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersToggleUserLock(idOrEmail: string, body?: LockUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersToggleUserLock(idOrEmail, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the current user
         * @summary Update current user information
         * @param {UsersMeBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdateCurrentUser(body: UsersMeBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationUserData> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersUpdateCurrentUser(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Uploads a profile picture for the current user
         * @summary Uploads a profile picture for the current user
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUploadCurrentUserProfilePicture(file?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationUserData> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).usersUploadCurrentUserProfilePicture(file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new user.  This operation can be called without authentication in any of this cases: * There is not any administrator yet on the server, * User registrations are not disabled in the server's policies.  If the first administrator is created by this call, user registrations are automatically disabled.
         * @summary Create user
         * @param {V1UsersBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreateUser(body: V1UsersBody, options?: any) {
            return UsersApiFp(configuration).usersCreateUser(body, options)(fetch, basePath);
        },
        /**
         * Deletes user profile and associated user data for user making the request
         * @summary Deletes user profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteCurrentUser(options?: any) {
            return UsersApiFp(configuration).usersDeleteCurrentUser(options)(fetch, basePath);
        },
        /**
         * Deletes the user profile picture
         * @summary Deletes user profile picture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteCurrentUserProfilePicture(options?: any) {
            return UsersApiFp(configuration).usersDeleteCurrentUserProfilePicture(options)(fetch, basePath);
        },
        /**
         * Delete a user.  Must be an admin to perform this operation.  Attempting to delete the only admin user will not succeed.  All data associated with the user will be deleted as well if the operation succeeds.
         * @summary Delete user
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteUser(idOrEmail: string, options?: any) {
            return UsersApiFp(configuration).usersDeleteUser(idOrEmail, options)(fetch, basePath);
        },
        /**
         * View information about the current user
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetCurrentUser(options?: any) {
            return UsersApiFp(configuration).usersGetCurrentUser(options)(fetch, basePath);
        },
        /**
         * Get 1 user by ID or Email.
         * @summary Get user by ID or Email
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetUser(idOrEmail: string, options?: any) {
            return UsersApiFp(configuration).usersGetUser(idOrEmail, options)(fetch, basePath);
        },
        /**
         * Load all users that exist.
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetUsers(options?: any) {
            return UsersApiFp(configuration).usersGetUsers(options)(fetch, basePath);
        },
        /**
         * Approve or unapprove a user.  Must be an admin to perform this operation.  Attempting to (un)approve a user for which this requirement does not exist will not succeed.
         * @summary Toggle user approval
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {ApproveUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersToggleUserApproval(idOrEmail: string, body?: ApproveUserRequest, options?: any) {
            return UsersApiFp(configuration).usersToggleUserApproval(idOrEmail, body, options)(fetch, basePath);
        },
        /**
         * Lock or unlock a user.  Must be an admin to perform this operation.  Attempting to lock the only admin user will not succeed.
         * @summary Toggle user lock out
         * @param {string} idOrEmail The user&#x27;s id or email
         * @param {LockUserRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersToggleUserLock(idOrEmail: string, body?: LockUserRequest, options?: any) {
            return UsersApiFp(configuration).usersToggleUserLock(idOrEmail, body, options)(fetch, basePath);
        },
        /**
         * Update the current user
         * @summary Update current user information
         * @param {UsersMeBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdateCurrentUser(body: UsersMeBody, options?: any) {
            return UsersApiFp(configuration).usersUpdateCurrentUser(body, options)(fetch, basePath);
        },
        /**
         * Uploads a profile picture for the current user
         * @summary Uploads a profile picture for the current user
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUploadCurrentUserProfilePicture(file?: Blob, options?: any) {
            return UsersApiFp(configuration).usersUploadCurrentUserProfilePicture(file, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Create a new user.  This operation can be called without authentication in any of this cases: * There is not any administrator yet on the server, * User registrations are not disabled in the server's policies.  If the first administrator is created by this call, user registrations are automatically disabled.
     * @summary Create user
     * @param {V1UsersBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCreateUser(body: V1UsersBody, options?: any) {
        return UsersApiFp(this.configuration).usersCreateUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes user profile and associated user data for user making the request
     * @summary Deletes user profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDeleteCurrentUser(options?: any) {
        return UsersApiFp(this.configuration).usersDeleteCurrentUser(options)(this.fetch, this.basePath);
    }

    /**
     * Deletes the user profile picture
     * @summary Deletes user profile picture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDeleteCurrentUserProfilePicture(options?: any) {
        return UsersApiFp(this.configuration).usersDeleteCurrentUserProfilePicture(options)(this.fetch, this.basePath);
    }

    /**
     * Delete a user.  Must be an admin to perform this operation.  Attempting to delete the only admin user will not succeed.  All data associated with the user will be deleted as well if the operation succeeds.
     * @summary Delete user
     * @param {string} idOrEmail The user&#x27;s id or email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDeleteUser(idOrEmail: string, options?: any) {
        return UsersApiFp(this.configuration).usersDeleteUser(idOrEmail, options)(this.fetch, this.basePath);
    }

    /**
     * View information about the current user
     * @summary Get current user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGetCurrentUser(options?: any) {
        return UsersApiFp(this.configuration).usersGetCurrentUser(options)(this.fetch, this.basePath);
    }

    /**
     * Get 1 user by ID or Email.
     * @summary Get user by ID or Email
     * @param {string} idOrEmail The user&#x27;s id or email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGetUser(idOrEmail: string, options?: any) {
        return UsersApiFp(this.configuration).usersGetUser(idOrEmail, options)(this.fetch, this.basePath);
    }

    /**
     * Load all users that exist.
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGetUsers(options?: any) {
        return UsersApiFp(this.configuration).usersGetUsers(options)(this.fetch, this.basePath);
    }

    /**
     * Approve or unapprove a user.  Must be an admin to perform this operation.  Attempting to (un)approve a user for which this requirement does not exist will not succeed.
     * @summary Toggle user approval
     * @param {string} idOrEmail The user&#x27;s id or email
     * @param {ApproveUserRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersToggleUserApproval(idOrEmail: string, body?: ApproveUserRequest, options?: any) {
        return UsersApiFp(this.configuration).usersToggleUserApproval(idOrEmail, body, options)(this.fetch, this.basePath);
    }

    /**
     * Lock or unlock a user.  Must be an admin to perform this operation.  Attempting to lock the only admin user will not succeed.
     * @summary Toggle user lock out
     * @param {string} idOrEmail The user&#x27;s id or email
     * @param {LockUserRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersToggleUserLock(idOrEmail: string, body?: LockUserRequest, options?: any) {
        return UsersApiFp(this.configuration).usersToggleUserLock(idOrEmail, body, options)(this.fetch, this.basePath);
    }

    /**
     * Update the current user
     * @summary Update current user information
     * @param {UsersMeBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdateCurrentUser(body: UsersMeBody, options?: any) {
        return UsersApiFp(this.configuration).usersUpdateCurrentUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * Uploads a profile picture for the current user
     * @summary Uploads a profile picture for the current user
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUploadCurrentUserProfilePicture(file?: Blob, options?: any) {
        return UsersApiFp(this.configuration).usersUploadCurrentUserProfilePicture(file, options)(this.fetch, this.basePath);
    }

}
/**
 * WebhooksApi - fetch parameter creator
 * @export
 */
export const WebhooksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new webhook
         * @summary Create a new webhook
         * @param {WebhookDataCreate} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksCreateWebhook(body: WebhookDataCreate, storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling webhooksCreateWebhook.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling webhooksCreateWebhook.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/webhooks`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookDataCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook
         * @summary Delete a webhook
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksDeleteWebhook(storeId: StoreId, webhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling webhooksDeleteWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling webhooksDeleteWebhook.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/webhooks/{webhookId}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent((webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View webhook of a store
         * @summary Get a webhook of a store
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetWebhook(storeId: StoreId, webhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling webhooksGetWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling webhooksGetWebhook.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/webhooks/{webhookId}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent((webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the latest deliveries to the webhook, ordered from the most recent
         * @summary Get latest deliveries
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {string} [count] The number of latest deliveries to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetWebhookDeliveries(storeId: StoreId, webhookId: string, count?: string, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling webhooksGetWebhookDeliveries.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling webhooksGetWebhookDeliveries.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/webhooks/{webhookId}/deliveries`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent((webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Information about a webhook delivery
         * @summary Get a webhook delivery
         * @param {string} deliveryId The id of the delivery
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetWebhookDelivery(deliveryId: string, storeId: StoreId, webhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'deliveryId' is not null or undefined
            if (deliveryId === null || deliveryId === undefined) {
                throw new RequiredError('deliveryId', 'Required parameter deliveryId was null or undefined when calling webhooksGetWebhookDelivery.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling webhooksGetWebhookDelivery.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling webhooksGetWebhookDelivery.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/webhooks/{webhookId}/deliveries/{deliveryId}`
                .replace(`{${"deliveryId"}}`, encodeURIComponent((deliveryId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent((webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The delivery's JSON request sent to the endpoint
         * @summary Get the delivery's request
         * @param {string} deliveryId The id of the delivery
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetWebhookDeliveryRequests(deliveryId: string, storeId: StoreId, webhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'deliveryId' is not null or undefined
            if (deliveryId === null || deliveryId === undefined) {
                throw new RequiredError('deliveryId', 'Required parameter deliveryId was null or undefined when calling webhooksGetWebhookDeliveryRequests.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling webhooksGetWebhookDeliveryRequests.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling webhooksGetWebhookDeliveryRequests.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/webhooks/{webhookId}/deliveries/{deliveryId}/request`
                .replace(`{${"deliveryId"}}`, encodeURIComponent((deliveryId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent((webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View webhooks of a store
         * @summary Get webhooks of a store
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetWebhooks(storeId: StoreId, options: any = {}): FetchArgs {
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling webhooksGetWebhooks.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/webhooks`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redeliver the delivery
         * @summary Redeliver the delivery
         * @param {string} deliveryId The id of the delivery
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksRedeliverWebhookDelivery(deliveryId: string, storeId: StoreId, webhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'deliveryId' is not null or undefined
            if (deliveryId === null || deliveryId === undefined) {
                throw new RequiredError('deliveryId', 'Required parameter deliveryId was null or undefined when calling webhooksRedeliverWebhookDelivery.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling webhooksRedeliverWebhookDelivery.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling webhooksRedeliverWebhookDelivery.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/webhooks/{webhookId}/deliveries/{deliveryId}/redeliver`
                .replace(`{${"deliveryId"}}`, encodeURIComponent((deliveryId)))
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent((webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a webhook
         * @summary Update a webhook
         * @param {WebhookDataUpdate} body 
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksUpdateWebhook(body: WebhookDataUpdate, storeId: StoreId, webhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling webhooksUpdateWebhook.');
            }
            // verify required parameter 'storeId' is not null or undefined
            if (storeId === null || storeId === undefined) {
                throw new RequiredError('storeId', 'Required parameter storeId was null or undefined when calling webhooksUpdateWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling webhooksUpdateWebhook.');
            }
            const localVarPath = `/api/v1/stores/{storeId}/webhooks/{webhookId}`
                .replace(`{${"storeId"}}`, encodeURIComponent((storeId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent((webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookDataUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Create a new webhook
         * @summary Create a new webhook
         * @param {WebhookDataCreate} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksCreateWebhook(body: WebhookDataCreate, storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookDataCreateResult> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).webhooksCreateWebhook(body, storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a webhook
         * @summary Delete a webhook
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksDeleteWebhook(storeId: StoreId, webhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).webhooksDeleteWebhook(storeId, webhookId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View webhook of a store
         * @summary Get a webhook of a store
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetWebhook(storeId: StoreId, webhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookData> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).webhooksGetWebhook(storeId, webhookId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List the latest deliveries to the webhook, ordered from the most recent
         * @summary Get latest deliveries
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {string} [count] The number of latest deliveries to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetWebhookDeliveries(storeId: StoreId, webhookId: string, count?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookDeliveryList> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).webhooksGetWebhookDeliveries(storeId, webhookId, count, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Information about a webhook delivery
         * @summary Get a webhook delivery
         * @param {string} deliveryId The id of the delivery
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetWebhookDelivery(deliveryId: string, storeId: StoreId, webhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookDeliveryData> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).webhooksGetWebhookDelivery(deliveryId, storeId, webhookId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The delivery's JSON request sent to the endpoint
         * @summary Get the delivery's request
         * @param {string} deliveryId The id of the delivery
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetWebhookDeliveryRequests(deliveryId: string, storeId: StoreId, webhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: any; }> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).webhooksGetWebhookDeliveryRequests(deliveryId, storeId, webhookId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * View webhooks of a store
         * @summary Get webhooks of a store
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetWebhooks(storeId: StoreId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookDataList> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).webhooksGetWebhooks(storeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Redeliver the delivery
         * @summary Redeliver the delivery
         * @param {string} deliveryId The id of the delivery
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksRedeliverWebhookDelivery(deliveryId: string, storeId: StoreId, webhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).webhooksRedeliverWebhookDelivery(deliveryId, storeId, webhookId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a webhook
         * @summary Update a webhook
         * @param {WebhookDataUpdate} body 
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksUpdateWebhook(body: WebhookDataUpdate, storeId: StoreId, webhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookData> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).webhooksUpdateWebhook(body, storeId, webhookId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new webhook
         * @summary Create a new webhook
         * @param {WebhookDataCreate} body 
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksCreateWebhook(body: WebhookDataCreate, storeId: StoreId, options?: any) {
            return WebhooksApiFp(configuration).webhooksCreateWebhook(body, storeId, options)(fetch, basePath);
        },
        /**
         * Delete a webhook
         * @summary Delete a webhook
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksDeleteWebhook(storeId: StoreId, webhookId: string, options?: any) {
            return WebhooksApiFp(configuration).webhooksDeleteWebhook(storeId, webhookId, options)(fetch, basePath);
        },
        /**
         * View webhook of a store
         * @summary Get a webhook of a store
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetWebhook(storeId: StoreId, webhookId: string, options?: any) {
            return WebhooksApiFp(configuration).webhooksGetWebhook(storeId, webhookId, options)(fetch, basePath);
        },
        /**
         * List the latest deliveries to the webhook, ordered from the most recent
         * @summary Get latest deliveries
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {string} [count] The number of latest deliveries to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetWebhookDeliveries(storeId: StoreId, webhookId: string, count?: string, options?: any) {
            return WebhooksApiFp(configuration).webhooksGetWebhookDeliveries(storeId, webhookId, count, options)(fetch, basePath);
        },
        /**
         * Information about a webhook delivery
         * @summary Get a webhook delivery
         * @param {string} deliveryId The id of the delivery
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetWebhookDelivery(deliveryId: string, storeId: StoreId, webhookId: string, options?: any) {
            return WebhooksApiFp(configuration).webhooksGetWebhookDelivery(deliveryId, storeId, webhookId, options)(fetch, basePath);
        },
        /**
         * The delivery's JSON request sent to the endpoint
         * @summary Get the delivery's request
         * @param {string} deliveryId The id of the delivery
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetWebhookDeliveryRequests(deliveryId: string, storeId: StoreId, webhookId: string, options?: any) {
            return WebhooksApiFp(configuration).webhooksGetWebhookDeliveryRequests(deliveryId, storeId, webhookId, options)(fetch, basePath);
        },
        /**
         * View webhooks of a store
         * @summary Get webhooks of a store
         * @param {StoreId} storeId The store ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGetWebhooks(storeId: StoreId, options?: any) {
            return WebhooksApiFp(configuration).webhooksGetWebhooks(storeId, options)(fetch, basePath);
        },
        /**
         * Redeliver the delivery
         * @summary Redeliver the delivery
         * @param {string} deliveryId The id of the delivery
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksRedeliverWebhookDelivery(deliveryId: string, storeId: StoreId, webhookId: string, options?: any) {
            return WebhooksApiFp(configuration).webhooksRedeliverWebhookDelivery(deliveryId, storeId, webhookId, options)(fetch, basePath);
        },
        /**
         * Update a webhook
         * @summary Update a webhook
         * @param {WebhookDataUpdate} body 
         * @param {StoreId} storeId The store ID
         * @param {string} webhookId The webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksUpdateWebhook(body: WebhookDataUpdate, storeId: StoreId, webhookId: string, options?: any) {
            return WebhooksApiFp(configuration).webhooksUpdateWebhook(body, storeId, webhookId, options)(fetch, basePath);
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Create a new webhook
     * @summary Create a new webhook
     * @param {WebhookDataCreate} body 
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksCreateWebhook(body: WebhookDataCreate, storeId: StoreId, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksCreateWebhook(body, storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a webhook
     * @summary Delete a webhook
     * @param {StoreId} storeId The store ID
     * @param {string} webhookId The webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksDeleteWebhook(storeId: StoreId, webhookId: string, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksDeleteWebhook(storeId, webhookId, options)(this.fetch, this.basePath);
    }

    /**
     * View webhook of a store
     * @summary Get a webhook of a store
     * @param {StoreId} storeId The store ID
     * @param {string} webhookId The webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksGetWebhook(storeId: StoreId, webhookId: string, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksGetWebhook(storeId, webhookId, options)(this.fetch, this.basePath);
    }

    /**
     * List the latest deliveries to the webhook, ordered from the most recent
     * @summary Get latest deliveries
     * @param {StoreId} storeId The store ID
     * @param {string} webhookId The webhook id
     * @param {string} [count] The number of latest deliveries to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksGetWebhookDeliveries(storeId: StoreId, webhookId: string, count?: string, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksGetWebhookDeliveries(storeId, webhookId, count, options)(this.fetch, this.basePath);
    }

    /**
     * Information about a webhook delivery
     * @summary Get a webhook delivery
     * @param {string} deliveryId The id of the delivery
     * @param {StoreId} storeId The store ID
     * @param {string} webhookId The webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksGetWebhookDelivery(deliveryId: string, storeId: StoreId, webhookId: string, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksGetWebhookDelivery(deliveryId, storeId, webhookId, options)(this.fetch, this.basePath);
    }

    /**
     * The delivery's JSON request sent to the endpoint
     * @summary Get the delivery's request
     * @param {string} deliveryId The id of the delivery
     * @param {StoreId} storeId The store ID
     * @param {string} webhookId The webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksGetWebhookDeliveryRequests(deliveryId: string, storeId: StoreId, webhookId: string, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksGetWebhookDeliveryRequests(deliveryId, storeId, webhookId, options)(this.fetch, this.basePath);
    }

    /**
     * View webhooks of a store
     * @summary Get webhooks of a store
     * @param {StoreId} storeId The store ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksGetWebhooks(storeId: StoreId, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksGetWebhooks(storeId, options)(this.fetch, this.basePath);
    }

    /**
     * Redeliver the delivery
     * @summary Redeliver the delivery
     * @param {string} deliveryId The id of the delivery
     * @param {StoreId} storeId The store ID
     * @param {string} webhookId The webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksRedeliverWebhookDelivery(deliveryId: string, storeId: StoreId, webhookId: string, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksRedeliverWebhookDelivery(deliveryId, storeId, webhookId, options)(this.fetch, this.basePath);
    }

    /**
     * Update a webhook
     * @summary Update a webhook
     * @param {WebhookDataUpdate} body 
     * @param {StoreId} storeId The store ID
     * @param {string} webhookId The webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksUpdateWebhook(body: WebhookDataUpdate, storeId: StoreId, webhookId: string, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksUpdateWebhook(body, storeId, webhookId, options)(this.fetch, this.basePath);
    }

}
