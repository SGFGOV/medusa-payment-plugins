import { Logger } from "@medusajs/medusa";
import {
    Options,
    RazorpayOptions,
    RazorpayProviderConfig,
    WebhookEventData
} from "../types";
import Razorpay from "razorpay";
import crypto from "crypto";
import { EOL } from "os";

import {
    AuthorizePaymentInput,
    AuthorizePaymentOutput,
    CancelPaymentInput,
    CancelPaymentOutput,
    CapturePaymentInput,
    CapturePaymentOutput,
    CartDTO,
    CustomerDTO,
    DeletePaymentInput,
    DeletePaymentOutput,
    GetPaymentStatusInput,
    GetPaymentStatusOutput,
    HttpTypes,
    ICartModuleService,
    ICustomerModuleService,
    InitiatePaymentInput,
    InitiatePaymentOutput,
    IPaymentModuleService,
    ProviderWebhookPayload,
    RefundPaymentInput,
    RefundPaymentOutput,
    RetrievePaymentInput,
    RetrievePaymentOutput,
    StoreCart,
    UpdatePaymentInput,
    UpdatePaymentOutput,
    WebhookActionResult
} from "@medusajs/framework/types";
import {
    AbstractPaymentProvider,
    ContainerRegistrationKeys,
    isDefined,
    MedusaError,
    MedusaErrorCodes,
    MedusaErrorTypes,
    Modules,
    PaymentActions,
    PaymentSessionStatus
} from "@medusajs/framework/utils";
import { ErrorCodes, PaymentIntentOptions } from "../types";
import { getAmountFromSmallestUnit } from "../utils/get-smallest-unit";
import { Customers } from "razorpay/dist/types/customers";
import { Orders } from "razorpay/dist/types/orders";
import { Payments } from "razorpay/dist/types/payments";
import { Refunds } from "razorpay/dist/types/refunds";
import { updateRazorpayCustomerMetadataWorkflow } from "../workflows/update-razorpay-customer-metadata";
import { MedusaContainer } from "@medusajs/framework";

/**
 * The paymentIntent object corresponds to a razorpay order.
 *
 */

abstract class RazorpayBase extends AbstractPaymentProvider<RazorpayOptions> {
    static identifier = "razorpay";

    protected readonly options_: RazorpayProviderConfig & Options;
    protected razorpay_: Razorpay;
    logger: Logger;
    container_: MedusaContainer;
    customerService: ICustomerModuleService;
    paymentService: IPaymentModuleService;
    cartService: ICartModuleService;

    protected constructor(container: MedusaContainer, options) {
        super(container, options);

        this.options_ = options;
        this.logger = container[ContainerRegistrationKeys.LOGGER];
        this.customerService = container[Modules.CUSTOMER];
        this.paymentService = container[Modules.PAYMENT];
        this.cartService = container[Modules.CART];
        this.container_ = container;
        this.options_ = options;

        this.init();
    }

    static validateOptions(options: RazorpayOptions): void {
        if (!isDefined(options.key_id)!) {
            throw new Error(
                "Required option `key_id` is missing in Razorpay plugin"
            );
        }
        if (!isDefined(options.key_secret)!) {
            throw new Error(
                "Required option `key_secret` is missing in Razorpay plugin"
            );
        }
        if (!isDefined(options.razorpay_account)!) {
            throw new Error(
                "Required option `razorpay_account` is missing in Razorpay plugin"
            );
        }
        if (!isDefined(options.automatic_expiry_period)!) {
            if (!isDefined(options.manual_expiry_period)!) {
                throw new Error(
                    "Required option `manual_expiry_period` is missing in Razorpay plugin"
                );
            }
            throw new Error(
                "Required option `automatic_expiry_period` is missing in Razorpay plugin"
            );
        }

        if (!isDefined(options.webhook_secret)!) {
            throw new Error(
                "Required option `webhook_secret` is missing in Razorpay plugin"
            );
        }
    }

    protected init(): void {
        const provider = this.options_.providers?.find(
            (p) => p.id == RazorpayBase.identifier
        );
        if (!provider && !this.options_.key_id) {
            throw new MedusaError(
                MedusaErrorTypes.INVALID_ARGUMENT,
                "razorpay not configured",
                MedusaErrorCodes.CART_INCOMPATIBLE_STATE
            );
        }
        this.razorpay_ =
            this.razorpay_ ||
            new Razorpay({
                key_id: this.options_.key_id ?? provider?.options.key_id,
                key_secret:
                    this.options_.key_secret ?? provider?.options.key_secret,
                headers: {
                    "Content-Type": "application/json",
                    "X-Razorpay-Account":
                        this.options_.razorpay_account ??
                        provider?.options.razorpay_account ??
                        undefined
                }
            });
    }

    abstract get paymentIntentOptions(): PaymentIntentOptions;

    getPaymentIntentOptions(): Partial<PaymentIntentOptions> {
        const options: Partial<PaymentIntentOptions> = {};

        if (this?.paymentIntentOptions?.capture_method) {
            options.capture_method = this.paymentIntentOptions.capture_method;
        }

        if (this?.paymentIntentOptions?.setup_future_usage) {
            options.setup_future_usage =
                this.paymentIntentOptions.setup_future_usage;
        }

        if (this?.paymentIntentOptions?.payment_method_types) {
            options.payment_method_types =
                this.paymentIntentOptions.payment_method_types;
        }

        return options;
    }

    _validateSignature(
        razorpay_payment_id: string,
        razorpay_order_id: string,
        razorpay_signature: string
    ): boolean {
        const body = razorpay_order_id + "|" + razorpay_payment_id;
        const provider = this.options_.providers?.find(
            (p) => p.id == RazorpayBase.identifier
        );

        if (!provider && !this.options_.key_id) {
            throw new MedusaError(
                MedusaErrorTypes.INVALID_ARGUMENT,
                "razorpay not configured",
                MedusaErrorCodes.CART_INCOMPATIBLE_STATE
            );
        }
        const expectedSignature = crypto
            .createHmac(
                "sha256",
                this.options_.key_secret ??
                    (provider!.options.key_secret as string)
            )
            .update(body.toString())
            .digest("hex");
        return expectedSignature === razorpay_signature;
    }

    async getRazorpayPaymentStatus(
        paymentIntent: Orders.RazorpayOrder,
        attempts: {
            entity: string;
            count: number;
            items: Array<Payments.RazorpayPayment>;
        }
    ): Promise<PaymentSessionStatus> {
        if (!paymentIntent) {
            return PaymentSessionStatus.ERROR;
        } else {
            const authorisedAttempts = attempts.items.filter(
                (i) => i.status == PaymentSessionStatus.AUTHORIZED
            );
            const totalAuthorised = authorisedAttempts.reduce((p, c) => {
                p += parseInt(`${c.amount}`);
                return p;
            }, 0);
            return totalAuthorised == paymentIntent.amount
                ? PaymentSessionStatus.AUTHORIZED
                : PaymentSessionStatus.REQUIRES_MORE;
        }
    }

    async getPaymentStatus(
        input: GetPaymentStatusInput
    ): Promise<GetPaymentStatusOutput> {
        const razorpayOrder = input.data as unknown as Orders.RazorpayOrder;
        const id = razorpayOrder.id as string;

        let paymentIntent: Orders.RazorpayOrder;
        let paymentsAttempted: {
            entity: string;
            count: number;
            items: Array<Payments.RazorpayPayment>;
        };
        try {
            paymentIntent = await this.razorpay_.orders.fetch(id);
            paymentsAttempted = await this.razorpay_.orders.fetchPayments(id);
        } catch (e) {
            const orderId = (input.data as unknown as Payments.RazorpayPayment)
                .order_id as string;
            this.logger.warn(
                "received payment data from session not order data"
            );
            paymentIntent = await this.razorpay_.orders.fetch(orderId);
            paymentsAttempted = await this.razorpay_.orders.fetchPayments(
                orderId
            );
        }
        let status: PaymentSessionStatus = PaymentSessionStatus.PENDING;
        switch (paymentIntent.status) {
            // created' | 'authorized' | 'captured' | 'refunded' | 'failed'
            case "created":
                status = PaymentSessionStatus.REQUIRES_MORE;
                break;
            case "paid":
                status = PaymentSessionStatus.AUTHORIZED;
                break;

            case "attempted":
                status = await this.getRazorpayPaymentStatus(
                    paymentIntent,
                    paymentsAttempted
                );
                break;
            default:
                status = PaymentSessionStatus.PENDING;
        }
        return { status };
    }

    async updateRazorpayMetadataInCustomer(
        customer: CustomerDTO,
        parameterName: string,
        parameterValue: string
    ): Promise<CustomerDTO> {
        const metadata = customer.metadata;
        let razorpay = metadata?.razorpay as Record<string, string>;
        if (razorpay) {
            razorpay[parameterName] = parameterValue;
        } else {
            razorpay = {};
            razorpay[parameterName] = parameterValue;
        }
        //
        const x = await updateRazorpayCustomerMetadataWorkflow(
            this.container_
        ).run({
            input: {
                medusa_customer_id: customer.id,
                razorpay
            }
        });
        const result = x.result.customer;

        return result;
    }
    // @Todo refactor this function to 3 simple functions to make it more readable
    // 1. check existing customer
    // 2. create customer
    // 3. update customer

    async editExistingRpCustomer(
        customer: CustomerDTO,
        intentRequest,
        extra: CartDTO
    ): Promise<Customers.RazorpayCustomer | undefined> {
        let razorpayCustomer: Customers.RazorpayCustomer | undefined;

        const razorpay_id =
            intentRequest.notes?.razorpay_id ||
            (customer.metadata?.razorpay_id as string) ||
            (customer.metadata as any)?.razorpay?.rp_customer_id;
        try {
            razorpayCustomer = await this.razorpay_.customers.fetch(
                razorpay_id
            );
        } catch (e) {
            this.logger.warn(
                "unable to fetch customer in the razorpay payment processor"
            );
        }
        // edit the customer once fetched
        if (razorpayCustomer) {
            const editEmail = customer.email;
            const editName =
                `${customer.first_name} ${customer.last_name}`.trim();
            const editPhone =
                customer?.phone ||
                customer?.addresses.find((v) => v.phone != undefined)?.phone;
            try {
                const updateRazorpayCustomer =
                    await this.razorpay_.customers.edit(razorpayCustomer.id, {
                        email: editEmail ?? razorpayCustomer.email,
                        contact: editPhone ?? razorpayCustomer.contact!,
                        name: editName != "" ? editName : razorpayCustomer.name
                    });
                razorpayCustomer = updateRazorpayCustomer;
            } catch (e) {
                this.logger.warn(
                    "unable to edit customer in the razorpay payment processor"
                );
            }
        }

        if (!razorpayCustomer) {
            try {
                razorpayCustomer = await this.createRazorpayCustomer(
                    customer,

                    intentRequest,
                    extra
                );
            } catch (e) {
                this.logger.error(
                    "something is very wrong please check customer in the dashboard."
                );
            }
        }
        return razorpayCustomer; // returning un modified razorpay customer
    }

    async createRazorpayCustomer(
        customer: CustomerDTO,
        intentRequest,
        extra: CartDTO
    ): Promise<Customers.RazorpayCustomer | undefined> {
        let razorpayCustomer: Customers.RazorpayCustomer;
        const phone =
            customer.phone ??
            extra.billing_address?.phone ??
            customer?.addresses.find((v) => v.phone != undefined)?.phone;

        const gstin = (customer?.metadata?.gstin as string) ?? undefined;
        if (!phone) {
            throw new Error("phone number to create razorpay customer");
        }
        if (!customer.email) {
            throw new Error("email to create razorpay customer");
        }
        const firstName = customer.first_name ?? "";
        const lastName = customer.last_name ?? "";
        try {
            const customerParams: Customers.RazorpayCustomerCreateRequestBody =
                {
                    email: customer.email,
                    contact: phone,
                    gstin: gstin,
                    fail_existing: 0,
                    name: `${firstName} ${lastName} `,
                    notes: {
                        updated_at: new Date().toISOString()
                    }
                };
            razorpayCustomer = await this.razorpay_.customers.create(
                customerParams
            );

            intentRequest.notes!.razorpay_id = razorpayCustomer?.id;
            if (customer && customer.id) {
                await this.updateRazorpayMetadataInCustomer(
                    customer,
                    "rp_customer_id",
                    razorpayCustomer.id
                );
            }
            return razorpayCustomer;
        } catch (e) {
            this.logger.error(
                "unable to create customer in the razorpay payment processor"
            );
            return;
        }
    }

    async pollAndRetrieveCustomer(
        customer: CustomerDTO
    ): Promise<Customers.RazorpayCustomer> {
        let customerList: Customers.RazorpayCustomer[] = [];
        let razorpayCustomer: Customers.RazorpayCustomer;
        const count = 10;
        let skip = 0;
        do {
            customerList = (
                await this.razorpay_.customers.all({
                    count,
                    skip
                })
            )?.items;
            razorpayCustomer =
                customerList?.find(
                    (c) =>
                        c.contact == customer?.phone ||
                        c.email == customer.email
                ) ?? customerList?.[0];
            if (razorpayCustomer) {
                await this.updateRazorpayMetadataInCustomer(
                    customer,
                    "rp_customer_id",
                    razorpayCustomer.id
                );
                break;
            }
            if (!customerList || !razorpayCustomer) {
                throw new Error(
                    "no customers and cant create customers in razorpay"
                );
            }
            skip += count;
        } while (customerList?.length == 0);

        return razorpayCustomer;
    }

    async fetchOrPollForCustomer(
        customer: CustomerDTO
    ): Promise<Customers.RazorpayCustomer | undefined> {
        let razorpayCustomer: Customers.RazorpayCustomer | undefined;
        try {
            const rp_customer_id = (
                customer.metadata?.razorpay as Record<string, string>
            )?.rp_customer_id;
            if (rp_customer_id) {
                razorpayCustomer = await this.razorpay_.customers.fetch(
                    rp_customer_id
                );
            } else {
                razorpayCustomer = await this.pollAndRetrieveCustomer(customer);

                this.logger.debug(
                    `updated customer ${razorpayCustomer.email} with RpId :${razorpayCustomer.id}`
                );
            }
            return razorpayCustomer;
        } catch (e) {
            this.logger.error(
                "unable to poll customer in the razorpay payment processor"
            );
            return;
        }
    }

    async createOrUpdateCustomer(
        intentRequest,
        customer: CustomerDTO,
        extra: CartDTO
    ): Promise<Customers.RazorpayCustomer | undefined> {
        let razorpayCustomer: Customers.RazorpayCustomer | undefined;
        try {
            const razorpay_id =
                (customer.metadata as any)?.razorpay?.rp_customer_id ||
                intentRequest.notes.razorpay_id;
            try {
                if (razorpay_id) {
                    this.logger.info(
                        "the updating  existing customer  in razorpay"
                    );

                    razorpayCustomer = await this.editExistingRpCustomer(
                        customer,
                        intentRequest,
                        extra
                    );
                }
            } catch (e) {
                this.logger.info("the customer doesn't exist in razopay");
            }
            try {
                if (!razorpayCustomer) {
                    this.logger.info("the creating  customer  in razopay");

                    razorpayCustomer = await this.createRazorpayCustomer(
                        customer,
                        intentRequest,
                        extra
                    );
                }
            } catch (e) {
                // if customer already exists in razorpay but isn't associated with a customer in medsusa
            }
            if (!razorpayCustomer) {
                try {
                    this.logger.info(
                        "relinking  customer  in razorpay by polling"
                    );

                    razorpayCustomer = await this.fetchOrPollForCustomer(
                        customer
                    );
                } catch (e) {
                    this.logger.error(
                        "unable to poll customer customer in the razorpay payment processor"
                    );
                }
            }
            return razorpayCustomer;
        } catch (e) {
            this.logger.error("unable to retrieve customer from cart");
        }
        return razorpayCustomer;
    }
    async getEntityFromTable<T>(
        table_name: string,
        id: string[],
        field = "id"
    ): Promise<T[]> {
        const connection = this.container[
            ContainerRegistrationKeys.PG_CONNECTION
        ] as any;
        const items = await connection
            .table(table_name)
            .select("*")
            .where(field, "in", id);
        return items as T[];
    }
    async getAllEntityFromTable<T>(table_name: string): Promise<T[]> {
        const connection = this.container[
            ContainerRegistrationKeys.PG_CONNECTION
        ] as any;
        const items = await connection.table(table_name).select("*");

        return items as T[];
    }
    private async getCartId(idempotency_key: string): Promise<string> {
        const ps = await this.paymentService.retrievePaymentSession(
            idempotency_key!
        );

        const cart_payment_collections = await this.getEntityFromTable<{
            cart_id: string;
            payment_collection_id: string;
            id: string;
        }>(
            "cart_payment_collection",
            [ps.payment_collection_id],
            "payment_collection_id"
        );
        const cartId = cart_payment_collections[0]?.cart_id as string;
        return cartId;
    }

    async createRazorpayCustomerFromCustomerDetails()
    {
        try {
            const razorpayCustomer = await this.createOrUpdateCustomer(
                intentRequest,
                customerDetails,
                cart
            );
            try {
                if (razorpayCustomer) {
                    this.logger.debug(
                        `the intent: ${JSON.stringify(intentRequest)}`
                    );
                } else {
                    this.logger.error("unable to find razorpay customer");
                }
                const phoneNumber =
                    customerDetails.phone ?? cart.billing_address?.phone;
                if (!phoneNumber) {
                    const e = new MedusaError(
                        MedusaError.Types.INVALID_DATA,
                        "no phone number",
                        MedusaError.Codes.CART_INCOMPATIBLE_STATE
                    );
                    return this.buildError(
                        "An error occurred in InitiatePayment during the " +
                            "invalid phone number: " +
                            JSON.stringify(e),
                        e
                    );
                }
                session_data = await this.razorpay_.orders.create({
                    ...intentRequest
                });
            } catch (e) {
                return this.buildError(
                    "An error occurred in InitiatePayment during the " +
                        "creation of the razorpay payment intent: " +
                        JSON.stringify(e),
                    e
                );
            }
        } catch (e) {
            return this.buildError(
                "An error occurred in creating customer request:" +
                    e.message,
                e
            );
        }
    }

    async initiatePayment(
        input: InitiatePaymentInput
    ): Promise<InitiatePaymentOutput> {
        // const intentRequestData = this.getPaymentIntentOptions();

        const paymentSessionId = input.context?.idempotency_key;

        const cartId = await this.getCartId(paymentSessionId!);
        const cart = await this.cartService.retrieveCart(cartId, {
            relations: ["billing_address", "shipping_address"]
        });

        const { currency_code, amount } = input;

        if (!cart) {
            throw new MedusaError(
                MedusaError.Types.INVALID_DATA,
                "cart not ready",
                MedusaError.Codes.CART_INCOMPATIBLE_STATE
            );
        }
        let toPay = getAmountFromSmallestUnit(
            Math.round(parseInt(amount.toString())),
            currency_code.toUpperCase()
        );
        toPay =
            currency_code.toUpperCase() == "INR" ? toPay * 100 * 100 : toPay;
        const intentRequest: Orders.RazorpayOrderCreateRequestBody = {
            amount: toPay,
            currency: currency_code.toUpperCase(),
            notes: {
                cart_id: cart?.id as string
            },
            payment: {
                capture:
                    this.options_.auto_capture ?? true ? "automatic" : "manual",
                capture_options: {
                    refund_speed: this.options_.refund_speed ?? "normal",
                    automatic_expiry_period: Math.max(
                        this.options_.automatic_expiry_period ?? 20,
                        12
                    ),
                    manual_expiry_period: Math.max(
                        this.options_.manual_expiry_period ?? 10,
                        7200
                    )
                }
            }
        };
        let session_data: Orders.RazorpayOrder;
        let customerDetails: CustomerDTO;
        if (input.context?.customer) {
            customerDetails = await this.customerService.retrieveCustomer(
                input.context.customer.id
            );

            
        }
        return {
            id: session_data.id,
            data: { ...session_data, intentRequest: intentRequest }
        };
    }

    async authorizePayment(
        input: AuthorizePaymentInput
    ): Promise<AuthorizePaymentOutput> {
        const paymentSessionData =
            input.data as unknown as Orders.RazorpayOrder;
        const paymentStatusRequest: GetPaymentStatusInput = {
            ...input
        };
        const status = await this.getPaymentStatus(paymentStatusRequest);
        return {
            status: status.status,
            data: {
                ...paymentSessionData
            }
        };
    }

    async cancelPayment(
        input: CancelPaymentInput
    ): Promise<CancelPaymentOutput> {
        return {
            data: input.data
        };

        // const error: PaymentProviderError = {
        //     error: "Unable to cancel as razorpay doesn't support cancellation",
        //     code: ErrorCodes.UNSUPPORTED_OPERATION
        // };
        // return error;
    }

    async capturePayment(
        input: CapturePaymentInput
    ): Promise<CapturePaymentOutput> {
        const paymentSessionData =
            input.data as unknown as Orders.RazorpayOrder;
        const order_id = paymentSessionData.id;
        const paymentsResponse = await this.razorpay_.orders.fetchPayments(
            order_id
        );
        const possibleCaptures = paymentsResponse.items?.filter(
            (item) => item.status == "authorized"
        );
        const result = possibleCaptures?.map(async (payment) => {
            const { id, amount, currency } = payment;
            const toPay =
                getAmountFromSmallestUnit(
                    Math.round(parseInt(amount.toString())),
                    currency.toUpperCase()
                ) * 100;
            const paymentIntent = await this.razorpay_.payments.capture(
                id,
                toPay,
                currency as string
            );
            return paymentIntent;
        });
        if (result) {
            const payments = await Promise.all(result);
            const res = payments.reduce(
                (acc, curr) => ((acc[curr.id] = curr), acc),
                {}
            );
            (paymentSessionData as unknown as Orders.RazorpayOrder).payments =
                res;
        }
        return {
            data: {
                ...paymentSessionData,
                payments: result
            }
        };
    }

    async deletePayment(
        input: DeletePaymentInput
    ): Promise<DeletePaymentOutput> {
        return await this.cancelPayment(input);
    }

    async refundPayment(
        input: RefundPaymentInput
    ): Promise<RefundPaymentOutput> {
        const id = (input.data?.razorpayOrder as unknown as Orders.RazorpayOrder).id as string;
        const refundAmount = parseFloat(input.amount.toString());
        const paymentList = await this.razorpay_.orders.fetchPayments(id);

        const payment_id = paymentList.items?.find((p) => {
            return (
                parseInt(`${p.amount}`) >= refundAmount * 100 &&
                (p.status == "authorized" || p.status == "captured")
            );
        })?.id;
        if (payment_id) {
            const refundRequest = {
                amount: refundAmount * 100
            };
            try {
                const refundSession = await this.razorpay_.payments.refund(
                    payment_id,
                    refundRequest
                );
                let refundsIssued =
                    input.data as unknown as Refunds.RazorpayRefund[];
                if (refundsIssued?.length > 0) {
                    refundsIssued.push(refundSession);
                } else {
                    refundsIssued = [refundSession];
                }
                return {
                    data: { refundsIssued }
                };
            } catch (e) {
                return this.buildError("An error occurred in refundPayment", e);
            }
        } else {
            return {
                data: undefined
            };
        }
    }

    async retrievePayment(
        input: RetrievePaymentInput
    ): Promise<RetrievePaymentOutput> {
        let externalPaymentSession: Orders.RazorpayOrder =
            {} as Orders.RazorpayOrder;
        const paymentSessionData =
            input.data as unknown as Orders.RazorpayOrder;
        try {
            const id = (paymentSessionData as unknown as Orders.RazorpayOrder)
                .id as string;
            externalPaymentSession = await this.razorpay_.orders.fetch(id);
            return {
                data: { ...externalPaymentSession }
            };
        } catch (e) {
            const id = (
                paymentSessionData as unknown as Payments.RazorpayPayment
            ).order_id as string;
            try {
                externalPaymentSession = await this.razorpay_.orders.fetch(id);
            } catch (e) {
                this.buildError("An error occurred in retrievePayment", e);
            }
            return {
                data: { ...externalPaymentSession }
            };
        }
    }

    async updatePayment(
        input: UpdatePaymentInput
    ): Promise<UpdatePaymentOutput> {
        const { context } = input;
        if (!context) {
            return this.buildError(
                "An error occurred in updatePayment during the retrieve of the cart - no context",
                new Error(
                    "An error occurred in updatePayment during the retrieve of the cart - no context"
                )
            );
        }
        const { customer } = context;
        if (!customer || !customer?.billing_address) {
            const missingItem = customer
                ? "customer billing address"
                : "customer";
            return this.buildError(
                `An error occurred in updatePayment during the retrieve of the cart no ${missingItem}`,
                new Error(
                    `An error occurred in updatePayment during the retrieve of the cart no ${missingItem}`
                )
            );
        }

        let refreshedCustomer: CustomerDTO;
        let customerPhone = "";
        let razorpayId: string;
        if (customer) {
            try {
                refreshedCustomer = context.customer as CustomerDTO;
                razorpayId = (refreshedCustomer?.metadata as any)?.razorpay
                    ?.rp_customer_id;
                customerPhone =
                    refreshedCustomer?.phone ??
                    customer?.billing_address?.phone ??
                    "";
                if (
                    !refreshedCustomer.addresses.find(
                        (v) => v.id == customer?.billing_address?.id
                    )
                ) {
                    this.logger.warn("no customer billing found");
                }
            } catch {
                return this.buildError(
                    "An error occurred in updatePayment during the retrieve of the customer",
                    new Error(
                        "An error occurred in updatePayment during the retrieve of the customer"
                    )
                );
            }
        }
        const isNonEmptyPhone =
            customerPhone ||
            customer.billing_address?.phone ||
            customer?.phone ||
            "";
        if (!razorpayId!) {
            return this.buildError(
                "razorpay id not supported",
                new Error("the phone number wasn't specified")
            );
        }

        const detailedCustomer = await this.customerService.retrieveCustomer(
            customer.id
        );
        if (
            razorpayId !==
            (detailedCustomer.metadata as any)?.razorpay?.rp_customer_id
        ) {
            const phone = isNonEmptyPhone;

            if (!phone) {
                this.logger.warn("phone number wasn't specified");
                return this.buildError(
                    "An error occurred in updatePayment during the retrieve of the customer",
                    new Error("the phone number wasn't specified")
                );
            }
            const result = await this.initiatePayment(input);
            // if (this.isPaymentProviderError(result)) {
            //     return this.buildError(
            //         "An error occurred in updatePayment during the initiate of the new payment for the new customer",
            //         result
            //     );
            // }

            return result;
        } else {
            const amount = input.data?.amount;
            const currency_code = input.data?.currency_code as string;
            const extra = input.data?.extra as HttpTypes.StoreCart;
            if (!amount) {
                return this.buildError(
                    "update razorpay amount  not valid",
                    new MedusaError(
                        MedusaErrorTypes.INVALID_DATA,
                        "amount  not valid",
                        MedusaErrorCodes.CART_INCOMPATIBLE_STATE
                    )
                );
            }
            if (!currency_code) {
                return this.buildError(
                    "currency code not known",
                    new MedusaError(
                        MedusaErrorTypes.INVALID_DATA,
                        "currency code unknown",
                        MedusaErrorCodes.CART_INCOMPATIBLE_STATE
                    )
                );
            }

            try {
                const id = extra?.id as string;
                let sessionOrderData: Partial<Orders.RazorpayOrder> = {
                    currency: "INR"
                };
                if (id) {
                    sessionOrderData = (await this.razorpay_.orders.fetch(
                        id
                    )) as Partial<Orders.RazorpayOrder>;
                    delete sessionOrderData.id;
                    delete sessionOrderData.created_at;
                }
                input.currency_code =
                    currency_code?.toUpperCase() ??
                    sessionOrderData?.currency ??
                    "INR";
                const newPaymentSessionOrder = await this.initiatePayment(
                    input
                );

                return newPaymentSessionOrder;
            } catch (e) {
                return this.buildError("An error occurred in updatePayment", e);
            }
        }
    }

    // async updatePaymentData(
    //     input: UpdatePaymentDataInput
    // ): Promise<PaymentProviderSessionResponse | PaymentProviderError> {
    //     try {
    //         // Prevent from updating the amount from here as it should go through
    //         // the updatePayment method to perform the correct logic
    //         if (data.amount || data.currency) {
    //             throw new MedusaError(
    //                 MedusaError.Types.INVALID_DATA,
    //                 "Cannot update amount, use updatePayment instead"
    //             );
    //         }
    //         try {
    //             const paymentSession = await this.razorpay_.payments.fetch(
    //                 (data.data as Record<string, any>).id as string
    //             );
    //             if (data.notes || (data.data as any)?.notes) {
    //                 const notes = data.notes || (data.data as any)?.notes;
    //                 const result = (await this.razorpay_.orders.edit(
    //                     sessionId,
    //                     {
    //                         notes: { ...paymentSession.notes, ...notes }
    //                     }
    //                 )) as unknown as PaymentProviderSessionResponse;
    //                 return result;
    //             } else {
    //                 this.logger.warn(
    //                     "only notes can be updated in razorpay order"
    //                 );
    //                 return paymentSession as unknown as PaymentProviderSessionResponse;
    //             }
    //         } catch (e) {
    //             return (data as Record<string, any>).data ?? data;
    //         }
    //     } catch (e) {
    //         return this.buildError("An error occurred in updatePaymentData", e);
    //     }
    // }
    /*
  /**
   * Constructs Razorpay Webhook event
   * @param {object} data - the data of the webhook request: req.body
   * @param {object} signature - the Razorpay signature on the event, that
   *    ensures integrity of the webhook event
   * @return {object} Razorpay Webhook event
   */

    constructWebhookEvent(data, signature): boolean {
        const provider = this.options_.providers?.find(
            (p) => p.id == RazorpayBase.identifier
        );

        if (!provider && !this.options_.key_id) {
            throw new MedusaError(
                MedusaErrorTypes.INVALID_ARGUMENT,
                "razorpay not configured",
                MedusaErrorCodes.CART_INCOMPATIBLE_STATE
            );
        }
        return Razorpay.validateWebhookSignature(
            data,
            signature,
            this.options_.webhook_secret ?? provider?.options.webhook_secret
        );
    }

    // isPaymentProviderError(e): e is PaymentProviderError {
    //     return (
    //         typeof e === "object" &&
    //         e !== null &&
    //         "error" in e &&
    //         "code" in e &&
    //         "detail" in e
    //     );
    // }

    protected buildError(
        message: string,
        e: Error
    ): {
        id: string;
        data: Record<string, unknown>;
    } {
        return {
            id: "ERROR",
            data: {
                error: message,
                code: "code" in e ? e.code : "",
                detail: {
                    message: e.message,
                    stack: e.stack
                }
            }
        };
    }
    async getWebhookActionAndData(
        webhookData: ProviderWebhookPayload["payload"]
    ): Promise<WebhookActionResult> {
        const webhookSignature = webhookData.headers["x-razorpay-signature"];

        const webhookSecret =
            this.options_?.webhook_secret ||
            process.env.RAZORPAY_WEBHOOK_SECRET ||
            process.env.RAZORPAY_TEST_WEBHOOK_SECRET;

        const logger = this.logger;
        const data = webhookData.data;

        logger.info(
            `Received Razorpay webhook body as object : ${JSON.stringify(
                webhookData.data
            )}`
        );
        try {
            const validationResponse = Razorpay.validateWebhookSignature(
                webhookData.rawData.toString(),
                webhookSignature as string,
                webhookSecret!
            );
            // return if validation fails
            if (!validationResponse) {
                return { action: PaymentActions.FAILED };
            }
        } catch (error) {
            logger.error(`Razorpay webhook validation failed : ${error}`);

            return { action: PaymentActions.FAILED };
        }
        const paymentData = (webhookData.data as unknown as WebhookEventData)
            .payload?.payment?.entity;
        const event = data.event;

        const order = await this.razorpay_.orders.fetch(paymentData.order_id);
        /** sometimes this even fires before the order is updated in the remote system */
        const outstanding = getAmountFromSmallestUnit(
            order.amount_paid == 0 ? paymentData.amount : order.amount_paid,
            paymentData.currency.toUpperCase()
        );

        switch (event) {
            // payment authorization is handled in checkout flow. webhook not needed

            case "payment.captured":
                return {
                    action: PaymentActions.SUCCESSFUL,
                    data: {
                        session_id: (paymentData.notes as any)
                            .session_id as string,
                        amount: outstanding
                    }
                };

            case "payment.authorized":
                return {
                    action: PaymentActions.AUTHORIZED,
                    data: {
                        session_id: (paymentData.notes as any)
                            .session_id as string,
                        amount: outstanding
                    }
                };

            case "payment.failed":
                // TODO: notify customer of failed payment

                return {
                    action: PaymentActions.FAILED,
                    data: {
                        session_id: (paymentData.notes as any)
                            .session_id as string,
                        amount: outstanding
                    }
                };
                break;

            default:
                return { action: PaymentActions.NOT_SUPPORTED };
        }
    }
}

export default RazorpayBase;
